<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++后台开发学习路线</title>
      <link href="/2023/07/30/C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2023/07/30/C++%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="My-C-Learning-Route"><a href="#My-C-Learning-Route" class="headerlink" title="My C++ Learning Route"></a>My C++ Learning Route</h1><blockquote><p> myC++后端开发学习路线</p></blockquote><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><ol><li>cpp primer  （github 有笔记和课后练习）——c++黑马项目实现一遍 ——&#x3D;&#x3D;也可以写个贪吃蛇&#x3D;&#x3D;</li><li>effective c++ </li><li>stl源码刨析</li><li>c++面向对象模型 （重点是虚函数那一章，看完你就会对虚函数有新的认识了）</li></ol><h2 id="工作必备技术"><a href="#工作必备技术" class="headerlink" title="工作必备技术"></a>工作必备技术</h2><ul><li><p>必学</p><ol><li><p><strong>git&#x2F;github</strong></p></li><li><p><strong>vim</strong>（可以在学linux的时候学，在《鸟哥的Linux私房菜》中有）</p></li><li><p><strong>GUN make</strong></p></li><li><p><strong>CMake</strong></p></li></ol></li><li><p>额外</p><ol><li>Docker</li><li>CI&#x2F;CD</li></ol></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>开始刷题——之后每天坚持<ul><li>代码随想录</li><li>leetcode hot100</li><li>《剑指offer》</li></ul></li><li>复习<ul><li>面经</li></ul></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li><p>王道考研视频操作系统</p></li><li><p>《操作系统导论》</p></li><li><p>操作系统进阶</p><ul><li>复习一遍操作系统<ul><li>《操作系统导论》</li></ul></li><li>实践：《Linux内核设计与实现》</li><li>理论：《深入理解Linux内核》</li><li>《 Windows 核心编程 》</li></ul></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>《计算机网络：自顶向下》</li><li>计算机网络进阶<ul><li>《计算机网络：自顶向下》</li><li>《网络是怎样连接的》——看完上面那本书后一天左右就能看完</li><li>《TCP&#x2F;IP详解》、《图解HTTP》</li></ul></li></ul><h2 id="网络-系统编程"><a href="#网络-系统编程" class="headerlink" title="网络&amp;系统编程"></a>网络&amp;系统编程</h2><ul><li>书籍：《鸟叔的Linux私房菜》</li><li>书籍：《Linux高性能服务器编程》<ul><li>做webServer项目</li><li>用于学习系统编程，网络编程</li></ul></li><li>《Linux多线程服务端编程 使⽤muduo C++⽹络库》——继续深入学习</li><li>《Unix网络编程》——字典、抠细节<ul><li><a href="https://www.acfun.cn/v/ac23313591">网络编程-陈硕</a></li></ul></li><li>《Unix环境高级编程》——系统编程</li></ul><h2 id="学完计算机网络和操作系统后——修炼内功"><a href="#学完计算机网络和操作系统后——修炼内功" class="headerlink" title="学完计算机网络和操作系统后——修炼内功"></a>学完计算机网络和操作系统后——修炼内功</h2><ul><li><p>《深入理解计算机系统》</p><ul><li>网上评论<ul><li>就拿 CSAPP 来说，涉及了很多方面，但每个方面其实也不是特别深入，属实让人有点摸不着头脑，比如：<ul><li>讲编译链接的部分不如去看《程序员的自我修养》</li><li>异常虚拟内存等东西不如直接去看《操作系统》</li><li>网络编程不如直接看&#x3D;&#x3D;《TCP&#x2F;IP网络编程》&#x3D;&#x3D;</li></ul></li></ul></li></ul></li><li><p>《程序员自我修养》</p></li><li><p>《代码整洁之道》</p></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>《数据库系统概论》国内&#x2F;《数据库系统概念》国外</li><li>《MySQL必知必会》</li><li>极客时间MySQL实战45讲</li><li>MySQL技术引擎<ul><li>视频：黑马MySQL</li></ul></li><li>《redis设计与实现》</li></ul><blockquote><p><strong>极客时间- Redis核心技术与实战 （</strong>中科院的研究员开设的Redis专栏，个人已经买了，非常不错<strong>）</strong></p></blockquote><blockquote><p><strong>另外再推荐基本数据库底层的书籍：数据库系统实现（</strong>华东师范大学数据学院指定数据库原理书籍<strong>）、MySQL技术内幕 -InnoDB存储引擎（</strong>InnoDB的详细剖析<strong>）</strong></p></blockquote><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><ol><li>《大话设计模式》</li><li>《数据密集型应用系统设计》</li><li>《深入理解Ngnix》</li></ol><h2 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h2><p>算法类：<strong>蓝桥杯</strong>（就算拿不了奖也可以去锻炼一下）、PAT</p><p>​去年比赛的报名时间：2021年10月12日-2021年12月17日</p><p>项目类：互联网+（这个我还不是很了解，以后有什么消息可以互相交流一下）</p><h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><ul><li>项目经历<ul><li>在此之前就可以着手准备</li><li>特别是为项目准备个PPT展示</li></ul></li><li>为大三下3、4月份的暑期实习做准备<ul><li>刷题+复习</li><li>面试准备</li></ul></li></ul><h2 id="暑期实习-秋招"><a href="#暑期实习-秋招" class="headerlink" title="暑期实习+秋招"></a>暑期实习+秋招</h2><ul><li>刷题+复习</li><li>面试准备</li></ul><hr><h3 id="什么是暑期实习："><a href="#什么是暑期实习：" class="headerlink" title="什么是暑期实习："></a>什么是暑期实习：</h3><p>暑期实习一般要求全职实习2-4个月，一般情况含金量非常高，因为公司确定你能和正式员工一样稳定工作一段时间，就会给一些涉及到核心的工作内容给你做。如果是一些大公司，还会把暑期实习当作一个项目来运作，给暑期实习的同学非常好的环境、学习机会、福利等等。之所以有这样的机会，背后的逻辑是雇主品牌，大企业非常注重雇主品牌建设。企业希望你感受到企业的好之后，在你的圈子里面去宣传，通过你建立与未来雇员或者潜在雇员的一个良好关系，这就是雇主品牌。<strong>【一般每年的3月中旬到6月中旬都有在招聘】</strong></p><p>其实就是在3、4月份进行暑期实习面试，拿到offer后在大三暑假进行实习，能拿到转正offer最好，同时也要两手准备秋招以防转正失败</p><h3 id="什么是校招提前批："><a href="#什么是校招提前批：" class="headerlink" title="什么是校招提前批："></a>什么是校招提前批：</h3><p>可以把提前批称为互联网的“大牛”批次，历史背景是曾经大家都是9月份开学后招聘，结果阿里和腾讯觉得自己有实力，得提前到8月份，先把最优秀的同学招完。后来互联网公司还有很多做人工智能、芯片的公司觉得大家都是要顶尖人才，不能你一家招啊，就搞出一个提前批，在8月初就招，又过了一年，很多科技类公司，想要抢优秀人才的，就也模仿先行者，提前到七月底。一年又一年，现在基本提前批能提前到六月份，大四还没毕业呢，大三的全职招聘就来了。但是提前批一般不浪费秋招机会，大家都可以投递，但是筛选非常严格，面试也非常严格，只招聘最优秀的同学。不过提前批被筛选掉了，不影响秋招继续投递。PS：最近慢慢有一种趋势，就是校招和提前批都混在一起了，没有提前批的概念了，就是整个秋招都全部提前了。<strong>【一般6月份-8月份】</strong></p><h4 id="提前批"><a href="#提前批" class="headerlink" title="提前批"></a>提前批</h4><p>提前批主要是一些公司为了能够更快的抢到一些更好的人才、更优质的人才所设置的，所以提前批一般都是神仙打架（竞争极其激烈，各种本硕985人才），但是<strong>提前批是非常重要的</strong>。因为已经有越来越多的公司看中提前批，<strong>有不少公司都是给予二次投递机会的，也就是说如果提前批你挂了，正式批还是能够再次投递这个公司的。</strong></p><p>比如说，我想投递字节跳动的抖音旗下的算法工程师岗位，那么我可以在6月份的时候投递一份简历，如果能通过面试更好。即使不能顺利通过面试，那么在7-10月份秋招正式批的时候我还可以再投递一次算法工程师这个岗位，也就是说提前批给了你一次复活机会。能够有一个“复活甲”，岂不美滋滋儿。所以同学们千万要参加提前批，千万不要因为觉得自己学历不好或者水平不够就放弃了提前批，千万不要，切记切记！</p><p><strong>换一个角度来说</strong>，即使你是普通学校的学生没有什么很厉害的背景或者经历而被直接刷下来的话，你的简历也不会被直接弃之不用<strong>，而是会放在正式批里对你发起面试。说人话就是，你相当于是&#x3D;&#x3D;最早投递&#x3D;&#x3D;正式批的一批人了，比别人能更早被发起面试邀约。</strong></p><ul><li>如果你学校不错，自己也觉得自己可以，那就去投，毕竟能多一次机会；</li><li>如果你觉得自己学校一般，但自己已经准备差不多了，简历也OK了，那大可去试试；</li><li>如果你觉得自己的简历还没写好，或者说还没达到你心中满意的地步就不要去参加提前批了，好好迭代简历，系统准备就好。这一次机会你去试了反而可能会失败，并且留下一个很不ok的面评，得不偿失，没必要去；</li></ul><h3 id="走心建议"><a href="#走心建议" class="headerlink" title="走心建议"></a>走心建议</h3><p>虽然很多公司说提前批挂了也不影响正式批的投递，但不可能说是完全没有影响的。对于一些大型的招聘公司来说都是有自己的一套招聘系统的，你每一次的面试都会记录在案，也就是说如果你提前批、正式批都投递了这家公司的这个岗位，那么在正式批的时候面试官是<strong>能够看到你前一次提前批面试的面试结果</strong>的，包括前一个面试官给你打的面试评价和你的面试情况。</p><p>即使很多公司都说第二次面试不会受第一次面试结果的印象，emm，你要信你就信，反正我不信哈哈</p><p>如果你前一次面试评价极差，你觉得会没有影响吗？</p><p>因此并不建议盲目的去投递提前批，如果你提前批面试结果很差，在正式批的时候很可能会对你的面试有影响。</p><p>不要以一个纯小白的身份去投递这些大公司，因为大厂面试机会来之不易，不要直接拿大厂练手，最好将这些大厂放在个人秋招安排进程的中期，这个时候你已经有一定的面试经验了，成功率也更高一些。</p><p><strong>所以能去内推就尽量去内推，并且尽量找一些靠谱的内推人才是正道！</strong></p><p>这里附赠&#x3D;&#x3D;阿秀的<strong>字节</strong>内推码&#x3D;&#x3D;：<strong>RQ9JR4D</strong>，保证靠谱！</p><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>[<a href="https://www.acfun.cn/v/ac23313591]">https://www.acfun.cn/v/ac23313591]</a>: </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录刷题总结</title>
      <link href="/2023/07/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="数组-5"><a href="#数组-5" class="headerlink" title="数组-5"></a>数组-5</h1><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h2><blockquote><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h4></blockquote><ul><li><p>有序数组</p></li><li><p>left + right + mid</p></li></ul><h2 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2. 移除元素"></a>2. 移除元素</h2><blockquote><h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4></blockquote><ul><li>快慢指针</li></ul><h2 id="3-有序数组的平方"><a href="#3-有序数组的平方" class="headerlink" title="3. 有序数组的平方"></a>3. 有序数组的平方</h2><blockquote><h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h4></blockquote><ul><li>双指针：left &#x3D; 0，right &#x3D; nums.size() - 1;<ul><li>谁的平方大取谁</li><li>vector&lt;int&gt; res，从后往前</li></ul></li></ul><h2 id="4-长度最小的子数组"><a href="#4-长度最小的子数组" class="headerlink" title="4. 长度最小的子数组"></a>4. 长度最小的子数组</h2><blockquote><h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4></blockquote><ul><li>滑动窗口：left + right</li><li>一旦窗口总和大于目标值，记录最小长度，让left++，直到窗口和小于目标值</li></ul><h2 id="5-螺旋矩阵"><a href="#5-螺旋矩阵" class="headerlink" title="5. 螺旋矩阵"></a>5. 螺旋矩阵</h2><blockquote><h4 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h4></blockquote><ul><li>奇数的话最后要输出中间</li><li>loop &#x3D; n &#x2F; 2</li><li>每圈起始点</li><li>每圈长度</li></ul><h1 id="链表-6"><a href="#链表-6" class="headerlink" title="链表-6"></a>链表-6</h1><h2 id="1-移除链表元素"><a href="#1-移除链表元素" class="headerlink" title="1. 移除链表元素"></a>1. 移除链表元素</h2><blockquote><h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h4></blockquote><ul><li><p>第一种方法</p><ul><li>先处理头节点值为 val</li><li>在处理非头节点</li></ul></li><li><p>第二种方法</p><ul><li>有一个虚假头节点——&gt;泛化头节点</li></ul></li></ul><p>注意：删除元素的时候下一个元素已经更新，不用移动</p><h2 id="2-翻转链表"><a href="#2-翻转链表" class="headerlink" title="2. 翻转链表"></a>2. 翻转链表</h2><blockquote><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4></blockquote><ul><li>pre + cur</li><li>递归：pre + cur</li></ul><h2 id="3-两两交换链表中的节点"><a href="#3-两两交换链表中的节点" class="headerlink" title="3. 两两交换链表中的节点"></a>3. 两两交换链表中的节点</h2><blockquote><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4></blockquote><ul><li>虚头节点<ul><li>三个节点，第一个Cur节点用于操控后两个节点 first &amp; second 的交换</li><li>之后 Cur 节点跳到 first 节点的位置继续操控后两个</li></ul></li></ul><h2 id="4-删除链表的倒数第N个节点"><a href="#4-删除链表的倒数第N个节点" class="headerlink" title="4. 删除链表的倒数第N个节点"></a>4. 删除链表的倒数第N个节点</h2><blockquote><h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4></blockquote><ul><li>虚头节点 + 双指针<ul><li>虚头节点是为了 删除头节点 的情况</li></ul></li><li>当 rhs 移动到末尾的时候，lhs 和 rhs需要移动 N 步才能重合</li><li>所以一开始让 rhs移动 N 次</li></ul><h2 id="5-链表相交"><a href="#5-链表相交" class="headerlink" title="5. 链表相交"></a>5. 链表相交</h2><blockquote><h4 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></h4></blockquote><ul><li>让两条链表同长<ul><li>默认让 headA 为长的，lenA跟着同步</li></ul></li><li>然后同步往后移动，对比指针指的地址值来判断相交点</li></ul><h2 id="6-环形链表II"><a href="#6-环形链表II" class="headerlink" title="6. 环形链表II"></a>6. 环形链表II</h2><blockquote><h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4></blockquote><ul><li><code>while</code>：保证rhs可以移动两步，即<code>rhs-&gt;next != nullptr</code>，以及rhs每次移动后不为空</li><li>双指针，lhs每次移动一步，rhs每次移动两步，直到二者重合</li><li>然后两个指针再从头节点和相交点同时移动，每次移动一步，最后相同点即为相交点</li></ul><h1 id="哈希表-7"><a href="#哈希表-7" class="headerlink" title="哈希表-7"></a>哈希表-7</h1><h2 id="1-有效的字母异位词"><a href="#1-有效的字母异位词" class="headerlink" title="1. 有效的字母异位词"></a>1. 有效的字母异位词</h2><blockquote><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h4></blockquote><ul><li><p>判断 t 和 s 的长度是否相等</p></li><li><p>用 <code>int hash[26];</code>效率高一点</p></li></ul><h2 id="2-两个数组的交集"><a href="#2-两个数组的交集" class="headerlink" title="2. 两个数组的交集"></a>2. 两个数组的交集</h2><blockquote><h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h4></blockquote><ul><li>用unordered_set避免重复</li><li>找到相同元素时候<strong>要删除</strong>，避免二次插入</li></ul><h2 id="3-快乐数"><a href="#3-快乐数" class="headerlink" title="3. 快乐数"></a>3. 快乐数</h2><blockquote><h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h4></blockquote><ul><li>无限循环<ul><li>运算结果为 1 <code>return true</code></li><li>运算结果重复（用 <code>unordered_set</code>记录）<code>return false</code></li></ul></li></ul><h2 id="4-两数之和"><a href="#4-两数之和" class="headerlink" title="4. 两数之和"></a>4. 两数之和</h2><blockquote><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h4></blockquote><ul><li><code>unordered_map——&gt;key：nums[i]，value：i</code></li><li><strong>边插边找</strong>，先找再插——&gt;可以<strong>规避找到自己</strong></li></ul><h2 id="5-四数相加Ⅱ"><a href="#5-四数相加Ⅱ" class="headerlink" title="5. 四数相加Ⅱ"></a>5. 四数相加Ⅱ</h2><blockquote><h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h4></blockquote><ul><li>分两组</li><li>用<code>unordered_map</code>——&gt; <code>key</code>：第一组的组合之和，<code>value</code>：<strong>个数</strong></li><li>在 map 找 <code>0 - 第二组组合之和</code><ul><li>res 要加上<strong>个数</strong></li></ul></li></ul><h2 id="6-三数之和"><a href="#6-三数之和" class="headerlink" title="6. 三数之和"></a>6. 三数之和</h2><blockquote><h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4></blockquote><ul><li>排序</li><li>for遍历每一个数字当作 target 值<ul><li>如果<code>nums[i] &gt; target &amp;&amp; nums[i] &gt;= 0</code>，就可以break掉</li><li><strong>将这个数字去重</strong><ul><li><code>i &gt; 0 &amp;&amp; nums[i] ==nums[i-1]</code></li></ul></li><li>然后往这个数字后面这块数字找二数之和为 target<ul><li>不断收缩左右边界</li><li><strong>找到之后注意去重</strong><ul><li>先收缩，在判断——&gt;去重</li></ul></li></ul></li></ul></li></ul><h2 id="7-四数之和"><a href="#7-四数之和" class="headerlink" title="7. 四数之和"></a>7. 四数之和</h2><blockquote><h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h4></blockquote><ul><li>在三数之和上套一层</li><li>排序</li><li><strong>for遍历</strong>每一个数字<ul><li>如果这个数字 &gt;&#x3D; 0，且这个数字大于target，就可以break掉</li><li><strong>将这个数字去重</strong><ul><li><code>i &gt; 0 &amp;&amp; nums[i] ==nums[i-1]</code></li></ul></li><li><strong>for遍历</strong>每一个数字当作 target 值<ul><li>如果这 <code>nums[i] + nums[j] &gt; target &amp;&amp; nums[j] &gt;= 0</code>，就可以break掉</li><li><strong>将这个数字去重</strong><ul><li><code>j&gt;i+1 &amp;&amp; nums[i] ==nums[i-1]</code></li></ul></li><li>然后往这个数字后面这块数字找二数之和为 target<ul><li>不断收缩左右边界</li><li><strong>找到之后注意去重</strong><ul><li>收缩边界</li><li>然后去重（注意让 left &lt; right）</li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="字符串-7"><a href="#字符串-7" class="headerlink" title="字符串-7"></a>字符串-7</h1><h2 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1. 反转字符串"></a>1. 反转字符串</h2><blockquote><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4></blockquote><ul><li>双指针 + swap()</li></ul><h2 id="2-反转字符串Ⅱ"><a href="#2-反转字符串Ⅱ" class="headerlink" title="2. 反转字符串Ⅱ"></a>2. 反转字符串Ⅱ</h2><blockquote><h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4></blockquote><ul><li>每次<code>i+=2k</code></li><li>判断 <code>if(i+k&lt;=s.size())</code><ul><li>true：反转</li><li>没有有的话就把剩余部分全反转</li></ul></li></ul><h2 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3. 替换空格"></a>3. 替换空格</h2><blockquote><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4></blockquote><ul><li>新开一个字符串</li><li>遇到空格就替换</li></ul><h2 id="4-翻转字符串里的单词"><a href="#4-翻转字符串里的单词" class="headerlink" title="4. 翻转字符串里的单词"></a>4. 翻转字符串里的单词</h2><blockquote><h4 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4></blockquote><ul><li>快慢指针使得单词紧凑<ul><li>遍历s，**&#x3D;&#x3D;不看空格&#x3D;&#x3D;**<ul><li>在if里面先为单词加空格，再追加单词</li></ul></li></ul></li><li>&#x3D;&#x3D;<strong>裁剪</strong>&#x3D;&#x3D;尾部的空格</li><li>整体反转</li><li>然后用**&#x3D;&#x3D;双指针&#x3D;&#x3D;**不停反转每个单词——需要自己写一个reverse，不用迭代器的版本<ul><li>rhs遇到空格就可以开始反转</li><li>记得每次让lhs移动</li></ul></li></ul><h2 id="5-剑指Offer58-II-左旋转字符串"><a href="#5-剑指Offer58-II-左旋转字符串" class="headerlink" title="5. 剑指Offer58-II.左旋转字符串"></a>5. 剑指Offer58-II.左旋转字符串</h2><blockquote><h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4></blockquote><ul><li>三次reverse()</li></ul><h2 id="6-实现-strStr-——-kmp-背就好了"><a href="#6-实现-strStr-——-kmp-背就好了" class="headerlink" title="6. 实现 strStr()——&#x3D;&#x3D;kmp&#x3D;&#x3D;背就好了"></a>6. 实现 strStr()——&#x3D;&#x3D;kmp&#x3D;&#x3D;背就好了</h2><blockquote><h4 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h4></blockquote><ul><li>get next<ul><li>int j &#x3D; -1 + next[0] &#x3D; j&#x2F;&#x2F;注意j &#x3D;&#x3D; -1</li><li>遍历<ul><li>j &gt;&#x3D; 0 &amp;&amp; 不相等的时候不断回溯</li><li><strong>&#x3D;&#x3D;s[j+1]&#x3D;&#x3D;</strong> &amp;&amp; s[i]相等的时候就让前缀尾部++</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> next[], string &amp;needle)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; needle.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k &gt;= <span class="number">0</span> &amp;&amp; needle[k + <span class="number">1</span>] != needle[i])&#123;<span class="comment">//不相等的时候</span></span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(needle[k + <span class="number">1</span>] == needle[i])&#123;<span class="comment">//相等的时候</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, needle);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[k + <span class="number">1</span>])&#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i] == needle[k + <span class="number">1</span>])&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k == needle.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i - needle.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-重复的子字符串"><a href="#7-重复的子字符串" class="headerlink" title="7. 重复的子字符串"></a>7. 重复的子字符串</h2><blockquote><h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h4></blockquote><ul><li>t &#x3D; s + s</li><li>掐头去尾</li><li>然后在 t 中找 s，找到即为true，（<code>t.find(s) != std::string::npos</code>）</li></ul><h1 id="双指针法-10"><a href="#双指针法-10" class="headerlink" title="双指针法-10"></a>双指针法-10</h1><ul><li>与上述重复</li></ul><h1 id="栈与队列-7"><a href="#栈与队列-7" class="headerlink" title="栈与队列-7"></a>栈与队列-7</h1><h2 id="1-用栈实现队列"><a href="#1-用栈实现队列" class="headerlink" title="1. 用栈实现队列"></a>1. 用栈实现队列</h2><blockquote><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4></blockquote><ul><li>两个栈</li><li>入队列用一个栈</li><li>出队列用另一个栈<ul><li>栈为空的时候把前个栈的元素拿过来</li></ul></li></ul><h2 id="2-用队列实现栈"><a href="#2-用队列实现栈" class="headerlink" title="2. 用队列实现栈"></a>2. 用队列实现栈</h2><blockquote><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4></blockquote><ul><li>两个队列</li><li>一个是备份</li></ul><h2 id="3-有效的括号"><a href="#3-有效的括号" class="headerlink" title="3. 有效的括号"></a>3. 有效的括号</h2><blockquote><h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h4></blockquote><ul><li>如果size不是**&#x3D;&#x3D;偶数&#x3D;&#x3D;** 返回false</li><li>如果遇到 [ 就将 ] 入栈</li><li>如果遇到 ] 就只用和栈顶元素比较就行<ul><li>如果st为空，或不相等，返回false</li><li>否则st.pop()</li></ul></li><li>最后看st否为空</li></ul><h2 id="4-删除字符串中的所有相邻重复项"><a href="#4-删除字符串中的所有相邻重复项" class="headerlink" title="4. 删除字符串中的所有相邻重复项"></a>4. 删除字符串中的所有相邻重复项</h2><blockquote><h4 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h4></blockquote><ul><li>和栈顶元素比较，如果相等就st.pop()</li><li>不相等就push</li><li>最后在reverse一下</li></ul><h2 id="5-逆波兰表达式求值"><a href="#5-逆波兰表达式求值" class="headerlink" title="5. 逆波兰表达式求值"></a>5. 逆波兰表达式求值</h2><blockquote><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h4></blockquote><ul><li>遇到数字压栈</li><li>遇到字符就去数字运算</li></ul><h2 id="6-滑动窗口最大值"><a href="#6-滑动窗口最大值" class="headerlink" title="6. 滑动窗口最大值"></a>6. 滑动窗口最大值</h2><blockquote><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4></blockquote><ul><li>用**&#x3D;&#x3D;自己的双端队列&#x3D;&#x3D;**，队首一直保持滑动窗口的最大值</li><li>先push k个元素进去，得到第一个窗口的最大值</li><li>滑动窗口每移动一次就输出一次<strong>队首</strong>就行——&gt;<code>front()</code></li><li>当滑动窗口移动而要<strong>加入</strong>元素时，让其前方的元素都出队——&gt;<code>push()</code></li><li>当滑动窗口移动而要<strong>删除</strong>的元素是队首首才会让队首出队——&gt;<code>pop()</code></li></ul><h2 id="7-前-K-个高频元素"><a href="#7-前-K-个高频元素" class="headerlink" title="7. 前 K 个高频元素"></a>7. 前 K 个高频元素</h2><blockquote><h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h4></blockquote><ul><li>用map来记录频次</li><li>遍历map<ul><li>用一个小根堆（有优先级的队列：priority_queue），</li><li>第一个为pair，<code>first：元素，second：频次</code>，第二个指定容器，第三个自定义比较规则</li><li>用myCompare <strong>&#x3D;&#x3D;类函数&#x3D;&#x3D;</strong> 实现：用second来排序  <code>lhs.second &gt; rhs.second</code> ——&gt; 小根堆</li><li>让大根堆的元素保持k个</li></ul></li><li>最后输出大根堆的所有元素</li></ul><h1 id="二叉树-27"><a href="#二叉树-27" class="headerlink" title="二叉树-27"></a>二叉树-27</h1><h2 id="1-二叉树的递归遍历"><a href="#1-二叉树的递归遍历" class="headerlink" title="1. 二叉树的递归遍历"></a>1. 二叉树的递归遍历</h2><blockquote></blockquote><ul><li>简单</li></ul><h2 id="2-二叉树的迭代遍历"><a href="#2-二叉树的迭代遍历" class="headerlink" title="2. 二叉树的迭代遍历"></a>2. 二叉树的迭代遍历</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><blockquote><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4></blockquote><ul><li>根节点先入栈</li><li>然后while(!st.empty())<ul><li>出栈，访问元素</li><li>然后先将右孩子入栈，然后再将左孩子入栈</li></ul></li></ul><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><blockquote><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4></blockquote><ul><li>cur &#x3D; root</li><li>while(cur !&#x3D; nullptr &amp;&amp; !st.empty())<ul><li>if：一直让左孩子入栈，直到左孩子为空，</li><li>else：此时出栈，访问元素，再让右孩子入栈</li></ul></li></ul><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><blockquote><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4></blockquote><ul><li>和前序遍历的顺序相反即可</li><li>根节点入栈</li><li>然后while(!st.empty())<ul><li>出栈，将元素放入vector</li><li>先将左孩子入栈，然后再将右孩子入栈</li></ul></li><li>reverse vector</li></ul><h2 id="3-二叉树层序遍历"><a href="#3-二叉树层序遍历" class="headerlink" title="3. 二叉树层序遍历"></a>3. 二叉树层序遍历</h2><blockquote><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4></blockquote><ul><li>简单</li></ul><h2 id="4-翻转二叉树"><a href="#4-翻转二叉树" class="headerlink" title="4. 翻转二叉树"></a>4. 翻转二叉树</h2><blockquote><h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h4></blockquote><ul><li>前序遍历 + swap</li></ul><h2 id="5-对称二叉树"><a href="#5-对称二叉树" class="headerlink" title="5. 对称二叉树"></a>5. 对称二叉树</h2><blockquote><h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4></blockquote><ul><li>前序遍历 + 比较是否相等</li><li>都为 nullptr</li><li>nullptr 和 非nullptr</li><li>对比val</li><li>有返回值类型：注意接收</li></ul><h2 id="6-二叉树的最大深度"><a href="#6-二叉树的最大深度" class="headerlink" title="6. 二叉树的最大深度"></a>6. 二叉树的最大深度</h2><blockquote><h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4></blockquote><ul><li>递归<ul><li>root &#x3D;&#x3D; nullptr return 0;</li><li>left &#x3D; 1 + maxDepth(root-&gt;left)</li><li>right …</li><li>return max(left, right)</li></ul></li><li>迭代：层序遍历</li></ul><h2 id="7-二叉树的最小深度"><a href="#7-二叉树的最小深度" class="headerlink" title="7. 二叉树的最小深度"></a>7. 二叉树的最小深度</h2><blockquote><h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4></blockquote><ul><li>递归：<ul><li>前序遍历 + 遇到叶子节点就更新最小深度，起始<code>depth = 1</code></li></ul></li><li>迭代：层序遍历，遇到第一个叶子节点，此时就是最小深度</li></ul><h2 id="8-完全二叉树的节点个数"><a href="#8-完全二叉树的节点个数" class="headerlink" title="8. 完全二叉树的节点个数"></a>8. 完全二叉树的节点个数</h2><blockquote><h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4></blockquote><ul><li>前序遍历 + 计数</li></ul><h2 id="9-平衡二叉树"><a href="#9-平衡二叉树" class="headerlink" title="9. 平衡二叉树"></a>9. 平衡二叉树</h2><blockquote><h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4></blockquote><ul><li>后续遍历 + 每次如果左右子树的高度超过1，就返回 -1 否则返回 1 + max(left, right)</li></ul><h2 id="10-二叉树的所有路径"><a href="#10-二叉树的所有路径" class="headerlink" title="10. 二叉树的所有路径"></a>10. 二叉树的所有路径</h2><blockquote><h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4></blockquote><ul><li>前序遍历 + 到叶子节点就打印路径，然后返回 + 注意回溯</li></ul><h2 id="11-左叶子之和"><a href="#11-左叶子之和" class="headerlink" title="11. 左叶子之和"></a>11. 左叶子之和</h2><blockquote><h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4></blockquote><ul><li>前序遍历 + 计算和</li><li>注意是叶子节点</li></ul><h2 id="12-找树左下角的值"><a href="#12-找树左下角的值" class="headerlink" title="12. 找树左下角的值"></a>12. 找树左下角的值</h2><blockquote><h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4></blockquote><ul><li>递归<ul><li>左优先遍历 + 找深度最深（最左下叶子节点会先被保存） + 注意回溯（可以传递depth + 1）</li></ul></li><li>层序遍历</li></ul><h2 id="13-路径总和"><a href="#13-路径总和" class="headerlink" title="13. 路径总和"></a>13. 路径总和</h2><blockquote><h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h4></blockquote><ul><li>前序遍历 + 回溯</li></ul><h2 id="14-从中序与后序遍历序列构造二叉树"><a href="#14-从中序与后序遍历序列构造二叉树" class="headerlink" title="14. 从中序与后序遍历序列构造二叉树"></a>14. 从中序与后序遍历序列构造二叉树</h2><blockquote><h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4></blockquote><ul><li>从后往前遍历后序遍历得到中间节点</li><li>然后根据这个节点找到中序遍历中的 index</li><li>将中序遍历的数组分成两块，后续遍历的数组也分成两块</li><li>终止条件是数组只有一个，返回这个节点，数组为空，返回 nullptr</li></ul><h2 id="15-最大二叉树"><a href="#15-最大二叉树" class="headerlink" title="15. 最大二叉树"></a>15. 最大二叉树</h2><blockquote><h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h4></blockquote><ul><li>找最大值 + 分组</li></ul><h2 id="16-合并二叉树"><a href="#16-合并二叉树" class="headerlink" title="16. 合并二叉树"></a>16. 合并二叉树</h2><blockquote><h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4></blockquote><ul><li>同时遍历两棵树——修改root1即可</li><li>有一个为空，就返回另一个</li><li>两个都为空，就返回nullptr</li><li>两个都不为空，相加即可</li></ul><h2 id="17-二叉搜索树中的搜索"><a href="#17-二叉搜索树中的搜索" class="headerlink" title="17. 二叉搜索树中的搜索"></a>17. 二叉搜索树中的搜索</h2><blockquote><h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4></blockquote><ul><li>while</li><li>大的往右子树找</li><li>小的往左子树找</li><li>找到就break</li></ul><h2 id="18-验证二叉搜索树"><a href="#18-验证二叉搜索树" class="headerlink" title="18. 验证二叉搜索树"></a>18. 验证二叉搜索树</h2><blockquote><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4></blockquote><ul><li>二叉搜索树中序遍历是有序的</li><li>中序遍历 + 判断是否有序（preVal）</li><li>注意节点值大小为 long</li></ul><h2 id="19-二叉搜索树的最小绝对差"><a href="#19-二叉搜索树的最小绝对差" class="headerlink" title="19. 二叉搜索树的最小绝对差"></a>19. 二叉搜索树的最小绝对差</h2><blockquote><h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4></blockquote><ul><li>二叉搜索树中序遍历是有序的</li><li>中序遍历 + preNode</li><li>注意：<code>if(pre != nullptr)</code>才进行 res 更新<ul><li>初始化的时候pre &#x3D; NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素</li></ul></li></ul><h2 id="20-二叉搜索树中的众数"><a href="#20-二叉搜索树中的众数" class="headerlink" title="20. 二叉搜索树中的众数"></a>20. 二叉搜索树中的众数</h2><blockquote><h4 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4></blockquote><ul><li>二叉搜索树中序遍历是有序的</li><li>中序遍历 + preNode</li><li>初始化的时候pre &#x3D; NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素</li><li>注意：<code>pre = cur</code>在中间</li></ul><h2 id="21-二叉树的最近公共祖先"><a href="#21-二叉树的最近公共祖先" class="headerlink" title="21. 二叉树的最近公共祖先"></a>21. 二叉树的最近公共祖先</h2><blockquote><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4></blockquote><ul><li>遇到nullptr || p || q 就返回相应的节点</li><li>TreeNode* left &#x3D; …</li><li>TreeNode* right &#x3D; …</li><li>left 和 right 都不空，返回 root</li><li>left 和 right 谁不空返回谁</li><li>都空就返回 nullptr</li></ul><h2 id="22-二叉搜索树的最近公共祖先"><a href="#22-二叉搜索树的最近公共祖先" class="headerlink" title="22. 二叉搜索树的最近公共祖先"></a>22. 二叉搜索树的最近公共祖先</h2><blockquote><h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4></blockquote><ul><li>可以用 21 的方法</li><li>找第一个 root-&gt;val 在 q-&gt;val 和 p-&gt;val 之间即是最近公共祖先</li><li>root-&gt;val 都大于 p-&gt;val 和 q-val 就往 left</li><li>否则往 right</li></ul><h2 id="23-二叉搜索树中的插入操作"><a href="#23-二叉搜索树中的插入操作" class="headerlink" title="23. 二叉搜索树中的插入操作"></a>23. 二叉搜索树中的插入操作</h2><blockquote><h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4></blockquote><ul><li>注意空root的时候的处理</li><li>while<ul><li>一直大小规则移动 cur，直到遇到 cur-&gt;left 或 cur-&gt;right 为空</li><li>再放进去即可</li></ul></li></ul><h2 id="24-删除二叉搜索树中的节点"><a href="#24-删除二叉搜索树中的节点" class="headerlink" title="24. 删除二叉搜索树中的节点"></a>24. 删除二叉搜索树中的节点</h2><blockquote><h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4></blockquote><ul><li>前序遍历</li><li>root-&gt;val &#x3D;&#x3D; key<ul><li>如果没有左右孩子节点就直接删除</li><li>如果由左孩子没有右孩子，让左孩子接替</li><li>相反，则 …</li><li>如果有左右孩子，统一让右孩子成为root，while一直到右孩子的最左，接上左孩子</li></ul></li><li>root-&gt;val &lt; key ：root-&gt;left &#x3D; …</li><li>root-&gt;val &gt; key ：root-&gt;right &#x3D; …</li></ul><h2 id="25-修剪二叉搜索树"><a href="#25-修剪二叉搜索树" class="headerlink" title="25. 修剪二叉搜索树"></a>25. 修剪二叉搜索树</h2><blockquote><h4 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h4></blockquote><img src="代码随想录刷题总结.assets/image-20230602233228206.png" alt="image-20230602233228206" style="zoom:25%;" /><ul><li>中序遍历有序</li><li>如果root-&gt;val &lt; low，就进入左边，并返回右子树符合条件的头结点</li><li>如果root-&gt;val &gt; high，就进入右边，并返回左子树<strong>符合条件的头结点</strong></li><li>然后再让 root-&gt;left &#x3D; ..</li><li>root-&gt;right &#x3D; …</li><li>return root;</li></ul><h2 id="26-将有序数组转换为二叉搜索树"><a href="#26-将有序数组转换为二叉搜索树" class="headerlink" title="26. 将有序数组转换为二叉搜索树"></a>26. 将有序数组转换为二叉搜索树</h2><blockquote><h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4></blockquote><ul><li>递归<ul><li>如果区间大小为0 return nullptr</li><li>找mid，构建节点root</li><li>如果区间大小为1 return root</li><li>根据 midIndex 划大小区间</li><li>root-&gt;left &#x3D;  …(小区间)</li><li>root-&gt;right &#x3D; …(大区间)</li></ul></li></ul><h2 id="27-把二叉搜索树转换为累加树"><a href="#27-把二叉搜索树转换为累加树" class="headerlink" title="27. 把二叉搜索树转换为累加树"></a>27. 把二叉搜索树转换为累加树</h2><blockquote><h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4></blockquote><ul><li>pre &#x3D; 0</li><li>和中序遍历相反<ul><li>先 root-&gt;right，再 root-&gt;left</li><li>中间：用pre节点来处理累加</li></ul></li></ul><h1 id="回溯算法-15"><a href="#回溯算法-15" class="headerlink" title="回溯算法-15"></a>回溯算法-15</h1><h2 id="1-组合"><a href="#1-组合" class="headerlink" title="1. 组合"></a>1. 组合</h2><blockquote><h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4></blockquote><ul><li>回溯</li><li>剪枝：<code>i &lt;= (n - (k - path.size()) + 1)</code>：i的起始点超过(n - (k - path.size()) + 1)就可以剪枝了</li></ul><h2 id="2-组合总和-III"><a href="#2-组合总和-III" class="headerlink" title="2. 组合总和 III"></a>2. 组合总和 III</h2><blockquote><h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h4></blockquote><ul><li>回溯</li><li>剪枝：<code>i &lt;= (n - (k - path.size()) + 1)</code>：i的起始点超过(n - (k - path.size()) + 1)就可以剪枝了</li><li>剪枝：sum &gt; target 就 return</li></ul><h2 id="3-电话号码组合"><a href="#3-电话号码组合" class="headerlink" title="3. 电话号码组合"></a>3. 电话号码组合</h2><blockquote><h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4></blockquote><ul><li><p>map映射——&gt; 每层选取一次</p><ul><li>每次递归让index++：获取每层</li></ul></li><li><p>回溯</p></li></ul><h2 id="4-组合总和"><a href="#4-组合总和" class="headerlink" title="4. 组合总和"></a>4. 组合总和</h2><blockquote><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4></blockquote><ul><li>题目：不含重复数字</li><li>回溯 + sort</li><li>剪枝：<code>sum + candidates[i] &lt;= target</code> 放在for循环里</li><li>前面的数不可再次选择，不然就只是换了个顺序,&#x3D;&#x3D;传递 i 使得下一层还可使用&#x3D;&#x3D;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++)&#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, i);    <span class="comment">//前面的数不可再次选择，不然就只是换了个顺序</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-组合总和-II"><a href="#5-组合总和-II" class="headerlink" title="5. 组合总和 II"></a>5. 组合总和 II</h2><blockquote><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h4></blockquote><ul><li>排序 + 回溯</li><li>剪枝：<code>sum + candidates[i] &lt;= target</code> 放在for循环里</li><li><code>if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - 1]) continue;</code><ul><li>同层不可重复使用</li><li>&#x3D;&#x3D;传递 i + 1 使得下一层不可使用&#x3D;&#x3D;</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, i + <span class="number">1</span>);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-分割回文串"><a href="#6-分割回文串" class="headerlink" title="6. 分割回文串"></a>6. 分割回文串</h2><blockquote><h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h4></blockquote><ul><li><p>回溯</p></li><li><p>但前行是回文串才深入</p></li><li><p>判断是否为字串可以用动态规划先计算出来——&gt;动态规划</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex == s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(s, startIndex, i))&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>));</span><br><span class="line">                <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[begin] != s[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            begin++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-复原IP地址"><a href="#7-复原IP地址" class="headerlink" title="7. 复原IP地址"></a>7. 复原IP地址</h2><blockquote><h4 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h4></blockquote><ul><li>一开始：<code>if (s.size() &lt; 4 || s.size() &gt; 12) return result; // 算是剪枝了</code></li><li>每层先判断合不合法，合法深入，不合法直接退出循环</li></ul><h2 id="8-子集问题"><a href="#8-子集问题" class="headerlink" title="8. 子集问题"></a>8. 子集问题</h2><blockquote><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4></blockquote><ul><li>result.push_back(path); &#x2F;&#x2F; 收集子集，要放在终止添加的上面，否则会漏掉 空集</li><li>回溯</li><li>不用加终止条件，每次都会到for结束时会终止</li></ul><h2 id="9-子集问题-II"><a href="#9-子集问题-II" class="headerlink" title="9. 子集问题 II"></a>9. 子集问题 II</h2><blockquote><h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h4></blockquote><ul><li>排序 + 回溯</li><li>result.push_back(path); &#x2F;&#x2F; 收集子集，要放在终止添加的上面，否则会漏掉 空集</li><li><code>if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - 1]) continue</code><ul><li>让同个位置不使用一样的</li></ul></li><li>不用加终止条件，每次都会到for结束时会终止</li></ul><h2 id="10-递增子序列"><a href="#10-递增子序列" class="headerlink" title="10. 递增子序列"></a>10. 递增子序列</h2><blockquote><h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列</a></h4></blockquote><ul><li>回溯</li><li>int used[201] &#x3D; {0}; &#x2F;&#x2F; 使用数组代替hash来进行去重操作，<strong>题目说数值范围[-100, 100]</strong></li><li>有序：<ul><li><code>if (!path.empty() &amp;&amp; nums[i] &lt; path.size() || used[nums[i] + 100] == 1) continue;</code></li><li>加入 path 并 res.push_back</li></ul></li></ul><h2 id="11-全排列"><a href="#11-全排列" class="headerlink" title="11. 全排列"></a>11. 全排列</h2><blockquote><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h4></blockquote><ul><li>每一层都是nums[ ]，用一个used来记录是否使用</li><li>每层都从0开始出发，之前树枝使用过就跳过</li></ul><h2 id="12-全排列-II"><a href="#12-全排列-II" class="headerlink" title="12.全排列 II"></a>12.全排列 II</h2><blockquote><h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h4></blockquote><ul><li>11题基础上</li><li><code>sort(nums.begin(), nums.end()); // 排序</code></li><li>如果同一树层nums[i - 1]使用过则直接跳过<ul><li><code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false)  continue;</code><ul><li>used[i-1] &#x3D; true代表同一树枝使用过</li><li>used[i-1] &#x3D; false代表同一树层使用过</li></ul></li></ul></li></ul><h2 id="13-重新安排行程"><a href="#13-重新安排行程" class="headerlink" title="&#x3D;&#x3D;13. 重新安排行程&#x3D;&#x3D;"></a>&#x3D;&#x3D;13. 重新安排行程&#x3D;&#x3D;</h2><blockquote><h4 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332. 重新安排行程"></a><a href="https://leetcode.cn/problems/reconstruct-itinerary/">332. 重新安排行程</a></h4></blockquote><ul><li>每次有不同选择 + 有层级关系：使用回溯<ul><li>每次选择一个，然后进入下一层选择</li></ul></li><li>用map表：例如&lt;JFK, &lt;ATL, ticket&gt;&gt;：<code>unordered_map&lt;string, map&lt;string, int&gt;&gt;</code><ul><li>JFK : ATL, SFO</li><li>SFO : ATL</li><li>ATL : JFK, SFO</li></ul></li><li>每层记得记录去过的地方：ticket–;</li></ul><h2 id="14-n皇后"><a href="#14-n皇后" class="headerlink" title="14. n皇后"></a>14. n皇后</h2><blockquote><h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h4></blockquote><ul><li>回溯</li><li><code>vector&lt;string&gt; chessboard (n, ‘.’);</code></li><li>可以放就放，然后进入下一层</li></ul><h2 id="15-解数独"><a href="#15-解数独" class="headerlink" title="15. 解数独"></a>15. 解数独</h2><blockquote><h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></h4></blockquote><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020111720451790-20230310131822254.png" alt="37.解数独" style="zoom: 33%;" /><ul><li>每层从零开始遍历这个二维数组</li><li>每次放下一个数字，就进入下一层，直接传递 board 即可</li></ul><h1 id="贪心-17"><a href="#贪心-17" class="headerlink" title="贪心-17"></a>贪心-17</h1><blockquote><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p><strong>不好意思了，贪心没有套路，说白了就是常识性推导加上举反例</strong>。</p></blockquote><h2 id="1-分发饼干"><a href="#1-分发饼干" class="headerlink" title="1. 分发饼干"></a>1. 分发饼干</h2><blockquote><h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h4></blockquote><ul><li>目的都是为了让饼干充分利用<ul><li>大饼干给大胃口</li><li>或者小饼干给小胃口</li></ul></li></ul><h2 id="2-摆动序列"><a href="#2-摆动序列" class="headerlink" title="2. 摆动序列"></a>2. 摆动序列</h2><blockquote><h4 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h4></blockquote><h3 id="1-贪心"><a href="#1-贪心" class="headerlink" title="1. 贪心"></a>1. 贪心</h3><ul><li>情况一：上下坡中有平坡<ul><li>pre &#x3D; 0 &amp;&amp; cur&gt;0   ||   pre &#x3D; 0 &amp;&amp; cur&lt;0</li><li>只要最后一截<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230106172613.png" alt="img" style="zoom: 25%;" /></li></ul></li><li>情况二：数组首尾两端<ul><li>假设 [2, 5]，假设前面加个2：[2, 2, 5]，此时preDiff &#x3D; 0;</li><li>默认右边有峰：res &#x3D; 1</li><li><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174357612.png" alt="376.摆动序列1" style="zoom: 33%;" /></li></ul></li><li>情况三：单调坡度有平坡<ul><li><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230108171505.png" alt="img" style="zoom:25%;" /></li><li>我们只需要在 这个坡度 摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。——&gt;情况1和3相似</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> preDiff = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> curDiff = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        curDiff = nums[i] - nums[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(preDiff &gt;=<span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span> || preDiff &lt;=<span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            preDiff = curDiff;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h3><p><img src="/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/1685887528750.jpg" alt="1685887528750"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> up = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> down = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>]) up = <span class="built_in">max</span>(up, down + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">                down = <span class="built_in">max</span>(down, up + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-最大子序和"><a href="#3-最大子序和" class="headerlink" title="3. 最大子序和"></a>3. 最大子序和</h2><blockquote><h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4></blockquote><ul><li>贪心<ul><li>sum &lt; 0 就 sum &#x3D; 0</li><li>sum &gt; max 就 max &#x3D; sum</li></ul></li><li>动态规划<ul><li>遇到有一个数组的问题</li><li>划分子问题</li><li>定义状态 dp</li><li>退出状态转移方程</li></ul></li></ul><h2 id="4-买卖股票的最佳时机-II"><a href="#4-买卖股票的最佳时机-II" class="headerlink" title="4. 买卖股票的最佳时机 II"></a>4. 买卖股票的最佳时机 II</h2><blockquote><h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4></blockquote><ul><li>贪心：上升就买入</li><li>动态规划：</li></ul><h2 id="5-跳跃游戏"><a href="#5-跳跃游戏" class="headerlink" title="5. 跳跃游戏"></a>5. 跳跃游戏</h2><blockquote><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h4></blockquote><ul><li>划范围然后遍历看看以目前范围能跳的地方跳能不能跳更远</li><li>cover</li></ul><h2 id="6-跳跃游戏-II"><a href="#6-跳跃游戏-II" class="headerlink" title="6. 跳跃游戏 II"></a>6. 跳跃游戏 II</h2><blockquote><h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h4></blockquote><ul><li>cover</li><li>将每次能跳的范围选出来<ul><li>i &#x3D;&#x3D; cover时，选择maxStep来跳</li></ul></li></ul><h2 id="7-K次取反后最大化的数组和"><a href="#7-K次取反后最大化的数组和" class="headerlink" title="7. K次取反后最大化的数组和"></a>7. K次取反后最大化的数组和</h2><blockquote><h4 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h4></blockquote><ul><li>用绝对值从大到小排序：<code>static com(int a, int b)&#123; return abs(a) &gt; abs(b); &#125;</code></li><li>遍历用k–让负数变正</li><li>还剩k % 2 &#x3D;&#x3D; 1 让最后一位反过来即可</li></ul><h2 id="8-加油站"><a href="#8-加油站" class="headerlink" title="8. 加油站"></a>8. 加油站</h2><blockquote><h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h4></blockquote><ul><li>totalSum &gt; 0 一定可以有起始点</li><li>totalSum &lt; 0 没有起始点</li><li>一旦curSum &lt; 0<ul><li>在 i 之前的起始点都不可以</li><li>所以让start &#x3D; i + 1，curSum &#x3D; 0</li></ul></li></ul><h2 id="9-分发糖果"><a href="#9-分发糖果" class="headerlink" title="9. 分发糖果"></a>9. 分发糖果</h2><blockquote><h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h4></blockquote><ul><li>从前往后遍历一遍</li><li>从后往前遍历一遍<ul><li>选择 <code>max(candys[i], candys[i] + 1)</code>：保证candy大于右边又大于左边的情况</li></ul></li></ul><h2 id="10-柠檬水找零"><a href="#10-柠檬水找零" class="headerlink" title="10. 柠檬水找零"></a>10. 柠檬水找零</h2><blockquote><h4 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h4></blockquote><ul><li>简单：用five，ten计数就好</li></ul><h2 id="11-根据身高重建队列"><a href="#11-根据身高重建队列" class="headerlink" title="11. 根据身高重建队列"></a>11. 根据身高重建队列</h2><blockquote><h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4></blockquote><ul><li>先按照身高排列从大到小：相同身高用第二个参数从小到大排序</li><li>然后遍历，根据第二个参数插入相应位置（可以使用list或者vector）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">myCmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), myCmp);</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : people)&#123;</span><br><span class="line">            <span class="type">int</span> position = p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> it = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(position--)&#123;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">insert</span>(it, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="12-用最少数量的箭引爆气球"><a href="#12-用最少数量的箭引爆气球" class="headerlink" title="12. 用最少数量的箭引爆气球"></a>12. 用最少数量的箭引爆气球</h2><blockquote><h4 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h4></blockquote><ul><li>排序</li><li>不断更新交集</li><li>如果后一个区间的右边界，大于前面的交集的<strong>右边界end</strong>，使用一根箭，更新新的右边界</li><li>没有交集就让end跳到下一块且res++</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">myCmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), myCmp);</span><br><span class="line">        <span class="type">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; end)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                end = <span class="built_in">min</span>(points[i][<span class="number">1</span>], end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;<span class="comment">//注意把最后一个区间射掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="13-无重叠区间"><a href="#13-无重叠区间" class="headerlink" title="13. 无重叠区间"></a>13. 无重叠区间</h2><blockquote><h4 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h4></blockquote><ul><li>排序</li><li>遇到交集就更新右边界end，模拟删除交集中右边界较大者</li><li>没有交集就让end跳到下一块</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">myCmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遇到交集就拿掉</span></span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), myCmp);</span><br><span class="line">        <span class="type">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; end)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                end = <span class="built_in">min</span>(end, intervals[i][<span class="number">1</span>]);    <span class="comment">//更新右边界，取较小者，删除的是较大值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> end = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="14-划分字母区间"><a href="#14-划分字母区间" class="headerlink" title="14. 划分字母区间"></a>14. 划分字母区间</h2><blockquote><h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></h4></blockquote><ul><li>把每个字母想成一个个区间，只要有交集不断更新右边界，没有交集的话，前面就划分了一个区间</li><li>遍历一遍，用 <strong>hash 记录</strong>每个字母的最远距离</li><li>再遍历一遍<ul><li>不断更新最远距离，当遍历的 <strong>i &#x3D;&#x3D; right 时 找到一个区间</strong></li><li>让 left 进入下一个区间</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            hash[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;       <span class="comment">//记录每个字母的最远下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            right = <span class="built_in">max</span>(right, hash[s[i] - <span class="string">&#x27;a&#x27;</span>]);    <span class="comment">//获取最远下标</span></span><br><span class="line">            <span class="keyword">if</span>(i == right)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15-合并区间"><a href="#15-合并区间" class="headerlink" title="15. 合并区间"></a>15. 合并区间</h2><blockquote><h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h4></blockquote><ul><li>简单：正常思维就行</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">myCmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), myCmp);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= right)&#123;</span><br><span class="line">                right = <span class="built_in">max</span>(right, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;left, right&#125;);     <span class="comment">//把最后一个区间放进去</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="16-单调递增的数字"><a href="#16-单调递增的数字" class="headerlink" title="16. 单调递增的数字"></a>16. 单调递增的数字</h2><blockquote><h4 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a><a href="https://leetcode.cn/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h4></blockquote><ul><li>重后往前遍历，如果遇到前一个后一个大的时候就让flag &#x3D; i + 1</li><li>之后再把 flag 以及其之后的全部变为 9 <ul><li>因为flag处需要用9：最大</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">        string num = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="type">int</span> flag = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = num.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] &gt; num[i + <span class="number">1</span>])&#123;</span><br><span class="line">                num[i]--;</span><br><span class="line">                flag = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = flag; i &lt; num.<span class="built_in">size</span>(); i++)</span><br><span class="line">            num[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17-监控二叉树"><a href="#17-监控二叉树" class="headerlink" title="17. 监控二叉树"></a>17. 监控二叉树</h2><blockquote><h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a><a href="https://leetcode.cn/problems/binary-tree-cameras/">968. 监控二叉树</a></h4></blockquote><ul><li>后序遍历，向上传递</li><li>节点状态<ul><li>0：无覆盖</li><li>1：有摄像头</li><li>2：有覆盖</li></ul></li><li><code>if(traversal(root) == 0) res++</code><ul><li>头节点左右都被覆盖的情况</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 0：无覆盖</span></span><br><span class="line">    <span class="comment">// 1：有摄像头</span></span><br><span class="line">    <span class="comment">// 2：有覆盖</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">2</span>;   <span class="comment">// 让nullptr为2，就不用在叶子节点放摄像头</span></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">traversaltraversal</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">        <span class="comment">// 后序遍历，向上传递</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;  <span class="comment">//只要左右节点有一个无覆盖就放摄像头</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">//一定有一个有摄像头，且另一个可以覆盖/有摄像头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traversal</span>(root) == <span class="number">0</span>)&#123;   <span class="comment">// 头节点左右都被覆盖的情况</span></span><br><span class="line">            res++;  <span class="comment">//头节点放一个摄像头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划-38"><a href="#动态规划-38" class="headerlink" title="动态规划-38"></a>动态规划-38</h1><p><img src="/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20230606215201954.png" alt="image-20230606215201954"></p><h2 id="1-斐波那契数"><a href="#1-斐波那契数" class="headerlink" title="1. 斐波那契数"></a>1. 斐波那契数</h2><blockquote><h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h4></blockquote><ul><li>递归</li><li>动态规划</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fibFunc</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fibFunc</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">1</span>] + dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>] - dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-爬楼梯（还是fib）"><a href="#2-爬楼梯（还是fib）" class="headerlink" title="2. 爬楼梯（还是fib）"></a>2. 爬楼梯（还是fib）</h2><blockquote><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4></blockquote><ul><li>递归</li><li>动态规划</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        n = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>] - dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-使用最小花费爬楼梯"><a href="#3-使用最小花费爬楼梯" class="headerlink" title="3. 使用最小花费爬楼梯"></a>3. 使用最小花费爬楼梯</h2><blockquote><h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h4></blockquote><ul><li>动态规划</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">min</span>(dp[<span class="number">0</span>] + cost[i - <span class="number">2</span>], dp[<span class="number">1</span>] + cost[i - <span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-不同路径"><a href="#4-不同路径" class="headerlink" title="4. 不同路径"></a>4. 不同路径</h2><blockquote><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h4></blockquote><ul><li>动态规划</li><li>map &#x3D;》优化成一排：写代码的时候联想 map 即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>] + dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-不同路径-II"><a href="#5-不同路径-II" class="headerlink" title="5. 不同路径 II"></a>5. 不同路径 II</h2><blockquote><h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h4></blockquote><ul><li>动态规划（优化）<ul><li>map &#x3D;》优化成一排：写代码的时候联想 map 即可</li><li>因为第一列没办法判断，所以从每层都从第一列开始</li><li>dp[0] 只有在此位置上有障碍时更新</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(obstacleGrid[<span class="number">0</span>].size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dp.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; obstacleGrid.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] != <span class="number">1</span> &amp;&amp; j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-整数拆分"><a href="#6-整数拆分" class="headerlink" title="6. 整数拆分"></a>6. 整数拆分</h2><blockquote><h4 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h4></blockquote><ul><li>比较拆分后的乘积，或是拆分数的本身小于其再拆分（即其dp保存的）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>((i - j) * j, dp[i - j] * j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-不同的二叉搜索树"><a href="#7-不同的二叉搜索树" class="headerlink" title="7. 不同的二叉搜索树"></a>7. 不同的二叉搜索树</h2><blockquote><h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h4></blockquote><ul><li>元素1为头结点搜索树的数量 &#x3D; 右子树有<strong>2个元素</strong>的搜索树数量 * 左子树有<strong>0个元素</strong>的搜索树数量</li><li>元素2为头结点搜索树的数量 &#x3D; 右子树有<strong>1个元素</strong>的搜索树数量 * 左子树有<strong>1个元素</strong>的搜索树数量</li><li>元素3为头结点搜索树的数量 &#x3D; 右子树有<strong>0个元素</strong>的搜索树数量 * 左子树有<strong>2个元素</strong>的搜索树数量</li></ul><p><img src="/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/20210107093226241.png" alt="96.不同的二叉搜索树2"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i - <span class="number">1</span> - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="————背包————"><a href="#————背包————" class="headerlink" title="————背包————"></a>————背包————</h2><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407-20230310132423205.png" alt="416.分割等和子集1"></p><ul><li>用<strong>一维 dp</strong> ：</li><li>不在意遍历顺序：<code>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</code><ul><li>一组数字组合成一个数</li></ul></li><li>在意遍历顺序：<code>dp[j] += dp[j - coins[i]];</code><ul><li>求有多少&#x3D;组合&#x3D;<strong>种数</strong><ul><li>（1，2）与（2，1）算一组</li><li><ul><li>+ 用01背包(只能用一次，内嵌 for **&#x3D;&#x3D;从后往前&#x3D;&#x3D;**遍历) 或暴力回溯</li><li>+ 用完全背包(重复用，内嵌 for **&#x3D;&#x3D;从前往后&#x3D;&#x3D;**遍历) 或暴力回溯</li><li>先物品，后背包</li></ul></li></ul></li><li>求有多少排列<strong>种数</strong><ul><li>（1，2）与（2，1）算两组</li><li>+ dp[j] +&#x3D; dp[j - coins[i]];<ul><li>+ 用完全背包(重复用，内嵌 for 从前往后遍历) 或暴力回溯</li><li>先背包，后物品</li></ul></li></ul></li></ul></li></ul><h2 id="———01-背包———"><a href="#———01-背包———" class="headerlink" title="———01 背包———"></a>———01 背包———</h2><h2 id="8-分割等和子集"><a href="#8-分割等和子集" class="headerlink" title="8. 分割等和子集"></a>8. 分割等和子集</h2><blockquote><h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h4></blockquote><ul><li>背包容量为 sum&#x2F;2</li><li>nums 即是物品，也是价值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sum / <span class="number">2</span> + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = sum / <span class="number">2</span>; j &gt;=<span class="number">0</span> ; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - nums[i] &gt;= <span class="number">0</span>) dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum / <span class="number">2</span>] == sum / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-最后一块石头的重量II"><a href="#9-最后一块石头的重量II" class="headerlink" title="9. 最后一块石头的重量II"></a>9. 最后一块石头的重量II</h2><blockquote><h4 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h4></blockquote><ul><li>石头为物品也为价值，背包容量大小是总重量的一半</li><li>最后得到最接近总重量一半的石头总和，再运算一下就好</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++) sum += stones[i];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sum / <span class="number">2</span> + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = sum / <span class="number">2</span>; j &gt;= stones[i]; j--)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - dp[sum / <span class="number">2</span>] - dp[sum / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-目标和——组合种数"><a href="#10-目标和——组合种数" class="headerlink" title="10. 目标和——组合种数"></a>10. 目标和——组合种数</h2><blockquote><h4 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h4></blockquote><ul><li>组合数<code>dp[j] += dp[j - nums[i]];</code></li><li>dp维护的是种数</li><li>注意：dp[0] &#x3D; 1;  &#x2F;&#x2F; 只有当前容量的位置才会有累加</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// (sum + target) / 正数的需要组合</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((sum + target) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> bagSize = (sum + target) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagSize + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 只有当前容量的位置才会有累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = bagSize; j &gt;= nums[i]; j--)&#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11-一和零——二维的背包"><a href="#11-一和零——二维的背包" class="headerlink" title="11. 一和零——二维的背包"></a>11. 一和零——二维的背包</h2><blockquote><h4 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a></h4></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二维dp，二维背包</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (string str : strs)&#123;        <span class="comment">//遍历物品</span></span><br><span class="line">            <span class="type">int</span> zeroNum = <span class="number">0</span>, oneNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : str)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) zeroNum++;</span><br><span class="line">                <span class="keyword">else</span> oneNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= zeroNum; i--)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= oneNum; j--)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="———完全背包———"><a href="#———完全背包———" class="headerlink" title="———完全背包———"></a>———完全背包———</h2><ul><li><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210126104529605.jpg" alt="动态规划-完全背包1"></li></ul><h2 id="12-零钱兑换II——组合种数-完全背包"><a href="#12-零钱兑换II——组合种数-完全背包" class="headerlink" title="12. 零钱兑换II——组合种数+完全背包"></a>12. 零钱兑换II——组合种数+完全背包</h2><blockquote><h4 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h4></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++)&#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210120181331461.jpg" alt="518.零钱兑换II"></p><h2 id="13-组合总和-Ⅳ——-排列-种数"><a href="#13-组合总和-Ⅳ——-排列-种数" class="headerlink" title="13. 组合总和 Ⅳ——&#x3D;&#x3D;排列&#x3D;&#x3D;种数"></a>13. 组合总和 Ⅳ——&#x3D;&#x3D;排列&#x3D;&#x3D;种数</h2><blockquote><h4 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h4></blockquote><ul><li>可以用回溯算法中<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a>的方法</li><li>如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！</li><li>所以本题遍历顺序最终遍历顺序：<strong>target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历</strong>。</li><li>C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] &lt; INT_MAX - dp[i - num]。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= target; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> (i - nums[j] &gt;= <span class="number">0</span> &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) &#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="14-爬楼梯（进阶版）"><a href="#14-爬楼梯（进阶版）" class="headerlink" title="14. 爬楼梯（进阶版）"></a>14. 爬楼梯（进阶版）</h2><blockquote><h4 id="70-爬楼梯-1"><a href="#70-爬楼梯-1" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4></blockquote><ul><li>排列 + 完全背包</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - j &gt;= <span class="number">0</span>) dp[i] += dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15-零钱兑换"><a href="#15-零钱兑换" class="headerlink" title="15. 零钱兑换"></a>15. 零钱兑换</h2><blockquote><h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h4></blockquote><ul><li>完全背包</li><li>递推公式为 <code>dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</code><ul><li>不断更新dp[j]，取最小</li><li>初始化为 INT_MAX，dp[0] &#x3D; 0，不让INT_MAX + 1</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j - coins[i]] != INT_MAX)&#123;    <span class="comment">//跳过初始值，以防让INT_MAX + 1</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="16-完全平方数"><a href="#16-完全平方数" class="headerlink" title="16. 完全平方数"></a>16. 完全平方数</h2><blockquote><h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h4></blockquote><ul><li>完全背包 + min</li><li>不用判断 INT_MAX ，因为第一层 dp 的 INT_MAX 一定会被初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j++)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j - i * i] + <span class="number">1</span>, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17-单词拆分"><a href="#17-单词拆分" class="headerlink" title="17. 单词拆分"></a>17. 单词拆分</h2><blockquote><h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h4></blockquote><ul><li>unordered_set + 回溯 + 记忆</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string &amp;s, unordered_set&lt;string&gt; &amp;myset, vector&lt;<span class="type">bool</span>&gt; &amp;memory, <span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt;= s.<span class="built_in">size</span>())  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果memory[startIndex]不是初始值了，直接使用memory[startIndex]的结果</span></span><br><span class="line">        <span class="keyword">if</span> (!memory[startIndex]) <span class="keyword">return</span> memory[startIndex];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            string word = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(myset.<span class="built_in">find</span>(word) != myset.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">backtracking</span>(s, myset, memory, i + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memory[startIndex] = <span class="literal">false</span>; <span class="comment">// 记录以startIndex开始的子串是不可以被拆分的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">memory</span><span class="params">(s.size(), <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">myset</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">backtracking</span>(s, myset, memory, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>动态规划</li><li>有顺序——&gt;排列，先背包，再物品</li><li>推出状态转移</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 初始条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">                <span class="keyword">if</span>(wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; dp[j])&#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/IMG_20230608_221113.jpg" alt="IMG_20230608_221113"></p><h2 id="18-打家劫舍（链）"><a href="#18-打家劫舍（链）" class="headerlink" title="18. 打家劫舍（链）"></a>18. 打家劫舍（链）</h2><blockquote><h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h4></blockquote><ul><li>偷与不偷</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp = dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>] = temp + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19-打家劫舍-II（环）"><a href="#19-打家劫舍-II（环）" class="headerlink" title="19. 打家劫舍 II（环）"></a>19. 打家劫舍 II（环）</h2><blockquote><h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h4></blockquote><ul><li>不打劫首部，打劫尾部</li><li>不打劫尾部，打劫首部</li><li><code>if(begin == end) return nums[begin];</code>：当只有两个元素时候</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res1 = <span class="built_in">robRange</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">2</span>, nums);</span><br><span class="line">        <span class="type">int</span> res2 = <span class="built_in">robRange</span>(<span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1, res2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robRange</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[begin];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin + <span class="number">1</span>; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp = dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">1</span>] = temp + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="20-打家劫舍-III（树）"><a href="#20-打家劫舍-III（树）" class="headerlink" title="20. 打家劫舍 III（树）"></a>20. 打家劫舍 III（树）</h2><blockquote><h4 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h4></blockquote><ul><li>后续遍历 + 偷与不偷父节点，每个节点&#x3D;&#x3D;记录两个偷与不偷状态&#x3D;&#x3D;（没有第二个方法快）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况</span></span><br><span class="line">        <span class="type">int</span> val1 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 偷cur，那么就不能偷左右节点。</span></span><br><span class="line">        <span class="type">int</span> val2 = cur-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;val1, val2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>偷不偷父节点 + 记忆已经偷过的</li><li>访问了孩子的孩子，所以要多处理叶子节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;TreeNode*,<span class="type">int</span>&gt; memMap;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(memMap[root]) <span class="keyword">return</span> memMap[root];</span><br><span class="line">        <span class="comment">// 偷父节点</span></span><br><span class="line">        <span class="type">int</span> val1 = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) val1 += <span class="built_in">rob</span>(root-&gt;left-&gt;left) + <span class="built_in">rob</span>(root-&gt;left-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) val1 += <span class="built_in">rob</span>(root-&gt;right-&gt;left) + <span class="built_in">rob</span>(root-&gt;right-&gt;right);</span><br><span class="line">        <span class="comment">// 不偷父节点</span></span><br><span class="line">        <span class="type">int</span> val2 = <span class="built_in">rob</span>(root-&gt;left) + <span class="built_in">rob</span>(root-&gt;right);</span><br><span class="line">        memMap[root] = <span class="built_in">max</span>(val1, val2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="21-买卖股票的最佳时机"><a href="#21-买卖股票的最佳时机" class="headerlink" title="21. 买卖股票的最佳时机"></a>21. 买卖股票的最佳时机</h2><blockquote><h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h4></blockquote><ul><li>贪心：<ul><li>i 会一直遍历，low 会指向在当前遍历以内的最小值，用当前遍历的 prices[i] 对 low取差值，就可以获得利润<ul><li>因为 <code>i &gt;= low</code>，prices[i] 一定在low的位置上或者其右边</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = INT_MAX;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low, prices[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i] - low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>动态规划：有无股票 &#x3D;&#x3D;》<strong>最小买入，最大卖出</strong><ul><li>有股票：昨天买的，今天买的，取最小的</li><li>无股票：昨天没有股票（可能昨天卖了，也可能之前就卖了），昨天有股票今天卖了，取最大</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], <span class="number">-1</span> * prices[i]);     <span class="comment">// 最小买入，买入的时候是负数，取max</span></span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>] + prices[i]);  <span class="comment">// 最大卖出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="22-买卖股票的最佳时机II"><a href="#22-买卖股票的最佳时机II" class="headerlink" title="22. 买卖股票的最佳时机II"></a>22. 买卖股票的最佳时机II</h2><blockquote><h4 id="122-买卖股票的最佳时机-II-1"><a href="#122-买卖股票的最佳时机-II-1" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4></blockquote><ul><li>动态规划 &#x3D;&#x3D;》有无股票<ul><li>有股票：昨天就有或今天买的   &#x3D;&#x3D;》小买入</li><li>无股票：昨天就没有或今天卖出   &#x3D;&#x3D;》大卖出</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], temp + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="23-买卖股票的最佳时机III"><a href="#23-买卖股票的最佳时机III" class="headerlink" title="23. 买卖股票的最佳时机III"></a>23. 买卖股票的最佳时机III</h2><blockquote><h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h4></blockquote><ul><li>动态规划：小买入，大卖出<ul><li>四个状态：第一次有股票，第一次无股票，第二次有股票，第二次无股票</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], -prices[i]);         <span class="comment">// 小买入</span></span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>] + prices[i]);  <span class="comment">// 大卖出</span></span><br><span class="line">            dp[<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>] - prices[i]);  <span class="comment">// 在dp[2]基础上小买入</span></span><br><span class="line">            dp[<span class="number">3</span>] = <span class="built_in">max</span>(dp[<span class="number">3</span>], dp[<span class="number">2</span>] + prices[i]);  <span class="comment">// 大卖出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="24-买卖股票的最佳时机IV"><a href="#24-买卖股票的最佳时机IV" class="headerlink" title="24. 买卖股票的最佳时机IV"></a>24. 买卖股票的最佳时机IV</h2><blockquote><h4 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h4></blockquote><ul><li>动态规划，其实和 23 一模一样<ul><li>主要思路还是小买入，大卖出</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span> * k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) dp[i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], -prices[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="number">1</span>] - prices[i]);  <span class="comment">// 小买入</span></span><br><span class="line">                <span class="keyword">else</span> dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="number">1</span>] + prices[i]);             <span class="comment">// 大卖出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span> * k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="25-最佳买卖股票时机含冷冻期"><a href="#25-最佳买卖股票时机含冷冻期" class="headerlink" title="25. 最佳买卖股票时机含冷冻期"></a>25. 最佳买卖股票时机含冷冻期</h2><blockquote><h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h4></blockquote><ul><li>四个状态：</li><li>0：有股票：之前有，昨天冷冻期买入，无股票买入</li><li>无股票<ul><li>1：之前无</li><li>2：今天买入&#x3D;&#x3D;》导致下一天冷冻期</li></ul></li><li>3：冷冻期间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">4</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp1 = dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">3</span>]) - prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">3</span>]);</span><br><span class="line">            <span class="type">int</span> tmp2 = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = tmp1 + prices[i];</span><br><span class="line">            dp[<span class="number">3</span>] = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>], <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="26-买卖股票的最佳时机含手续费"><a href="#26-买卖股票的最佳时机含手续费" class="headerlink" title="26. 买卖股票的最佳时机含手续费"></a>26. 买卖股票的最佳时机含手续费</h2><blockquote><h4 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h4></blockquote><ul><li>与 22. 买卖股票的最佳时机II 一模一样</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = -(fee + prices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>] - prices[i] - fee); <span class="comment">// 小买入</span></span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>] + prices[i]);       <span class="comment">// 大卖出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="27-最长上升子序列"><a href="#27-最长上升子序列" class="headerlink" title="27. 最长上升子序列"></a>27. 最长上升子序列</h2><blockquote><h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h4></blockquote><ul><li>以 dp[i] 为递增序列最后一个元素的最长序列</li><li>每次得到dp[i]后，判断 res &lt; dp[i] 然后更新res</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; res) res = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="28-最长连续递增序列"><a href="#28-最长连续递增序列" class="headerlink" title="28. 最长连续递增序列"></a>28. 最长连续递增序列</h2><blockquote><h4 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h4></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> dp = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>]) dp++;</span><br><span class="line">            <span class="keyword">else</span> dp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; dp) res = dp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="29-最长重复子串"><a href="#29-最长重复子串" class="headerlink" title="29. 最长重复子串"></a>29. 最长重复子串</h2><blockquote><h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h4></blockquote><ul><li>map表，相等时传递，同步更新res</li><li>因为是使用了滚动数组，需要内层循环从右到左<ul><li>以防在从左到右的遍历中被覆盖：还有是不需要水平之前的数据进行递推</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = nums2.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) dp[j + <span class="number">1</span>] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[j + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (res &lt; dp[j + <span class="number">1</span>]) res = dp[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="30-最长公共子序列"><a href="#30-最长公共子序列" class="headerlink" title="30. 最长公共子序列"></a>30. 最长公共子序列</h2><blockquote><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h4></blockquote><ul><li>相等左上传递</li><li>不相等 max(up, left)<ul><li>用于横向和纵向传递最大值</li></ul></li><li>因为内层循环只能从左到右遍历，为了实现一维（滚动）数组<ul><li>用一个 <strong>pre</strong> 记录**&#x3D;&#x3D;左上的值&#x3D;&#x3D;**以防在从左到右的遍历中被覆盖</li><li>注意用 cur 让 pre 能够滑动</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(text2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> pre = dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; text2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="type">int</span> cur = dp[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (text1[i] == text2[j]) dp[j + <span class="number">1</span>] = pre + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[j + <span class="number">1</span>], dp[j]);<span class="comment">// 两个方向都可以删减</span></span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210204115139616.jpg" alt="1143.最长公共子序列" style="zoom:50%;" /><h2 id="31-不相交的线"><a href="#31-不相交的线" class="headerlink" title="31. 不相交的线"></a>31. 不相交的线</h2><blockquote><h4 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a><a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></h4></blockquote><ul><li>和最长公共子序列一模一样</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> pre = dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="type">int</span> cur = dp[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) dp[j + <span class="number">1</span>] = pre + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[j + <span class="number">1</span>], dp[j]);</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="32-最大子序和"><a href="#32-最大子序和" class="headerlink" title="32. 最大子序和"></a>32. 最大子序和</h2><blockquote><h4 id="53-最大子数组和-1"><a href="#53-最大子数组和-1" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4></blockquote><ul><li>此处贪心 &#x3D;&#x3D; 一个状态转移dp</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">//dp += nums[i];</span></span><br><span class="line">            <span class="comment">//if (res &lt; dp) res = dp;</span></span><br><span class="line">            <span class="comment">//if (dp &lt; 0) dp = 0;</span></span><br><span class="line">            dp = <span class="built_in">max</span>(dp + it, it);</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="33-判断子序列"><a href="#33-判断子序列" class="headerlink" title="33. 判断子序列"></a>33. 判断子序列</h2><blockquote><h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h4></blockquote><ul><li>和最长公共子序列和不相交的线一样 + 判断长度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(t.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> pre = dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="type">int</span> cur = dp[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) dp[j + <span class="number">1</span>] = pre + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[j + <span class="number">1</span>] = dp[j];<span class="comment">// 只能删减左边</span></span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210303172354155.jpg" alt="392.判断子序列1" style="zoom:50%;" /><h2 id="34-不同的子序列"><a href="#34-不同的子序列" class="headerlink" title="34. 不同的子序列"></a>34. 不同的子序列</h2><blockquote><h4 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h4></blockquote><ul><li><code>dp[i][j]</code> 代表以&#x3D;&#x3D;i -1 结尾的 s 内有多少个和 j - 1 结尾的 t&#x3D;&#x3D;</li><li><code>s[i] == t[j] : dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code> 实际用滚动数组实现：想象成二维数组就好了</li><li><code>s[i] != t[j] : dp[i][j] = dp[i - 1][j]</code></li><li>初始化：dp[0] &#x3D; 1，注意数据类型大小<code>uint64_t</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">uint64_t</span>&gt; <span class="title">dp</span><span class="params">(t.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> pre = dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="type">uint64_t</span> cur = dp[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) dp[j + <span class="number">1</span>] = pre + dp[j + <span class="number">1</span>];</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="35-两个字符串的删除操作"><a href="#35-两个字符串的删除操作" class="headerlink" title="35. 两个字符串的删除操作"></a>35. 两个字符串的删除操作</h2><blockquote><h4 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h4></blockquote><ul><li><code>dp[i][j]</code>代表以 i 结尾的 word1 和 word2 要减多少次相等</li><li><code>word1[i] == word2[j] : dp[i][j] = dp[i - 1][j - 1]</code></li><li><code>word1[i] != word2[j] : dp[i][j] = min(dp[i - 1][j], dp[i][j - 1])</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(word2.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dp.<span class="built_in">size</span>(); i++) dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word1.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="type">int</span> pre = dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="type">int</span> cur = dp[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (word1[i] == word2[j]) dp[j + <span class="number">1</span>] = pre;</span><br><span class="line">                <span class="keyword">else</span> dp[j + <span class="number">1</span>] = <span class="built_in">min</span>(dp[j + <span class="number">1</span>], dp[j]) + <span class="number">1</span>;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="36-编辑距离"><a href="#36-编辑距离" class="headerlink" title="36. 编辑距离"></a>36. 编辑距离</h2><blockquote><h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h4></blockquote><ul><li>不相等 三个min</li><li>相等 左上角传递</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(word2.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dp.<span class="built_in">size</span>(); i++) dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> pre = dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="type">int</span> cur = dp[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (word1[i] == word2[j]) dp[j + <span class="number">1</span>] = pre;</span><br><span class="line">                <span class="keyword">else</span> dp[j + <span class="number">1</span>] = <span class="built_in">min</span>(pre, <span class="built_in">min</span>(dp[j + <span class="number">1</span>], dp[j])) + <span class="number">1</span>;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="37-回文子串"><a href="#37-回文子串" class="headerlink" title="37. 回文子串"></a>37. 回文子串</h2><blockquote><h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h4></blockquote><ul><li>中心扩散</li><li>处理1 个 和 两个相等的扩散</li><li><code>dp[i][j] </code>代表 (i, j) 是否为回文串</li><li><code>dp[i + 1][j - 1] == true ==&gt; dp[i][j] </code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>双指针更快<ul><li>遍历 以 i 和 i 为中心，以 i 和 i + 1为中心</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">extend</span>(s, i, i, res);</span><br><span class="line">            <span class="built_in">extend</span>(s, i, i + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> lhs, <span class="type">int</span> rhs, <span class="type">int</span> &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (lhs &gt;= <span class="number">0</span> &amp;&amp; rhs &lt; s.<span class="built_in">size</span>() &amp;&amp; s[rhs] == s[lhs]) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            lhs--;</span><br><span class="line">            rhs++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="38-最长回文子序列"><a href="#38-最长回文子序列" class="headerlink" title="38. 最长回文子序列"></a>38. 最长回文子序列</h2><blockquote><h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h4></blockquote><ul><li>中间扩散，dp[i][j] 记录的是(i, j)的最长回文子序列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="单调栈-5"><a href="#单调栈-5" class="headerlink" title="单调栈-5"></a>单调栈-5</h1><h2 id="1-每日温度"><a href="#1-每日温度" class="headerlink" title="1. 每日温度"></a>1. 每日温度</h2><blockquote><h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h4></blockquote><ul><li>用 stack</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(temperatures.size())</span></span>;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; temperatures.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temperatures[i] &lt;= temperatures[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    res[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-下一个更大元素-I"><a href="#2-下一个更大元素-I" class="headerlink" title="2. 下一个更大元素 I"></a>2. 下一个更大元素 I</h2><blockquote><h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4></blockquote><ul><li>建立索引</li><li>对 nums2 进行 stack 的操作时，一旦需要<code>st.pop()</code>，那么就可以判断要 pop 对应的元素是否出现在nums1直接操作 res</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; myMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            myMap[nums1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums1.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (myMap.<span class="built_in">find</span>(nums2[st.<span class="built_in">top</span>()]) != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="type">int</span> index = myMap[nums2[st.<span class="built_in">top</span>()]];</span><br><span class="line">                    res[index] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-下一个更大元素II"><a href="#3-下一个更大元素II" class="headerlink" title="3. 下一个更大元素II"></a>3. 下一个更大元素II</h2><blockquote><h4 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h4></blockquote><ul><li>用两个nums + stack</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="built_in">size</span>()] &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                res[st.<span class="built_in">top</span>()] = nums[i % nums.<span class="built_in">size</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-接雨水"><a href="#4-接雨水" class="headerlink" title="4. 接雨水"></a>4. 接雨水</h2><blockquote><h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h4></blockquote><ul><li>双指针法<ul><li>找自己左边&#x2F;右边最大的元素（可能小于自己）</li></ul></li><li><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210223092732301.png" alt="42.接雨水3" style="zoom:50%;" /></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxleft</span><span class="params">(height.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxRight</span><span class="params">(height.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> size = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            maxleft[i] = <span class="built_in">max</span>(height[i - <span class="number">1</span>], maxleft[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxRight[i] = <span class="built_in">max</span>(height[i + <span class="number">1</span>], maxRight[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="built_in">min</span>(maxRight[i], maxleft[i]) - height[i];</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) res += count;<span class="comment">// min(maxRight[i], maxleft[i])（可能小于自己）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>单调栈法<ul><li>栈为单调递减的</li></ul></li></ul><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210223092629946.png" alt="42.接雨水2" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; height.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> mid = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="type">int</span> w = i - st.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> h = <span class="built_in">min</span>(height[st.<span class="built_in">top</span>()], height[i]) - height[mid];</span><br><span class="line">                    res += h * w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-柱状图中最大的矩形"><a href="#5-柱状图中最大的矩形" class="headerlink" title="5. 柱状图中最大的矩形"></a>5. 柱状图中最大的矩形</h2><blockquote><h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h4></blockquote><ul><li>双指针法<ul><li>找左边&#x2F;右边第一个小于自己的元素</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先记录每个位置的左边第一个 &lt; 自己的高度</span></span><br><span class="line">        <span class="comment">// 记录每个位置的右边第一个 &lt; 自己的高度</span></span><br><span class="line">        <span class="type">int</span> size = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">firstLeftMin</span><span class="params">(size)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">firstRightMin</span><span class="params">(size)</span></span>;</span><br><span class="line">        firstLeftMin[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        firstRightMin[size - <span class="number">1</span>] = size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; heights[j] &gt;= heights[i]) j = firstLeftMin[j];</span><br><span class="line">            firstLeftMin[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; size &amp;&amp; heights[j] &gt;= heights[i]) j = firstRightMin[j];</span><br><span class="line">            firstRightMin[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> area = heights[i] * (firstRightMin[i] - firstLeftMin[i] - <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(area, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>栈<ul><li>当遇到<code>height[i] &gt; height[st.top()]</code>此时这个<code>height[i]</code>就是<code>height[st.top()]</code>的最右第一个小</li><li>栈为单调递增的</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">// 数组头部加入元素0，确保第一个元素被处理</span></span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 数组尾部加入元素0，确保全部单调递增被处理</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; heights.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (heights[i] &lt; heights[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> mid = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> w = i - st.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> h = heights[mid];</span><br><span class="line">                result = <span class="built_in">max</span>(result, w * h);</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++面经整理集</title>
      <link href="/2023/07/25/C++%E9%9D%A2%E7%BB%8F/"/>
      <url>/2023/07/25/C++%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-语言基础-C-C-over"><a href="#1-语言基础-C-C-over" class="headerlink" title="1. 语言基础 (C&#x2F;C++)&#x3D;&#x3D;over&#x3D;&#x3D;"></a>1. 语言基础 (C&#x2F;C++)&#x3D;&#x3D;over&#x3D;&#x3D;</h1><h2 id="（0）-指针和引用的区别"><a href="#（0）-指针和引用的区别" class="headerlink" title="（0） 指针和引用的区别"></a>（0） 指针和引用的区别</h2><ul><li>指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作</li><li>指针可以有多级，返回函数内部指向在堆区开辟内存的指针的地址，用于后续手动清理，引用只有一级</li><li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改</li><li>指针的大小一般是4个字节，64位操作系统是<strong>8个字节</strong>，引用的大小取决于被引用对象的大小</li><li>指针变量定义时不必初始化；引用定义时必须初始化，不然会报错，指针可以为空，引用不可以。</li></ul><h2 id="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"><a href="#（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？" class="headerlink" title="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"></a>（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</h2><ul><li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li><li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li></ul><h2 id="（2）-堆和栈有什么区别"><a href="#（2）-堆和栈有什么区别" class="headerlink" title="（2） 堆和栈有什么区别"></a>（2） 堆和栈有什么区别</h2><ul><li>从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。</li><li>堆空间因为会有频繁的分配释放操作，会产生**&#x3D;&#x3D;内存碎片&#x3D;&#x3D;**</li><li>堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小</li><li>栈的效率——&gt;(3)</li></ul><h2 id="（3）堆快一点还是栈快一点？（字节提前批一面）"><a href="#（3）堆快一点还是栈快一点？（字节提前批一面）" class="headerlink" title="（3）堆快一点还是栈快一点？（字节提前批一面）"></a>（3）堆快一点还是栈快一点？（字节提前批一面）</h2><ul><li>栈快一点。因为<strong>操作系统</strong>会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈有<strong>专门的指令</strong>执行，所以栈的效率比较高也比较快。</li><li>而堆的操作是<strong>由C&#x2F;C++函数库</strong>提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</li></ul><h2 id="（4）-new和delete是如何实现的，new-与-malloc的异同处"><a href="#（4）-new和delete是如何实现的，new-与-malloc的异同处" class="headerlink" title="（4） new和delete是如何实现的，new 与 malloc的异同处"></a>（4） new和delete是如何实现的，new 与 malloc的异同处</h2><p>在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。</p><ul><li><strong>分配内存的位置</strong>：malloc是从堆上动态分配内存，new是从自由存储区为对象动态分配内存。自由存储区的位置取决于operator new的实现。<strong>自由存储区</strong>不仅可以为堆，还可以是<strong>静态存储区</strong>，这都看operator new在哪里为对象分配内存。</li><li><strong>分配内存的大小的计算</strong>：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</li><li><strong>内存分配失败返回值</strong>：malloc内存分配失败后返回<strong>NULL</strong>。new分配内存失败则会抛异常（bac_alloc）。</li><li><strong>内存分配失败返回值</strong>：malloc内存分配失败后返回<strong>NULL</strong>。new分配内存失败则会抛异常（bac_alloc）。</li><li><strong>内存分配成功返回值</strong>：malloc内存分配成功后返回void*，然后再强制类型转换为需要的类型；new操作符分配内存成功后返回与对象类型相匹配的指针类型；因此new是符合<strong>类型安全的操作符</strong>。</li><li><strong>是否可以被重载</strong>：opeartor new &#x2F;operator delete可以被重载。而malloc&#x2F;free则不能重载。</li></ul><h2 id="（5）既然有了malloc-free，C-中为什么还需要new-delete呢？"><a href="#（5）既然有了malloc-free，C-中为什么还需要new-delete呢？" class="headerlink" title="（5）既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？"></a>（5）既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？</h2><p><a href="https://blog.csdn.net/leikun153/article/details/80612130">https://blog.csdn.net/leikun153/article/details/80612130</a></p><ul><li>malloc&#x2F;free和new&#x2F;delete都是用来申请内存和回收内存的。</li><li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc&#x2F;free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc&#x2F;free。</li></ul><h2 id="（6）-C和C-的区别"><a href="#（6）-C和C-的区别" class="headerlink" title="（6） C和C++的区别"></a>（6） C和C++的区别</h2><p>包括但不限于：</p><ul><li>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码<strong>模块化</strong>。继承通过子类继承父类的<strong>方法和属性</strong>，实现了<strong>代码复用</strong>。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了<strong>接口复用</strong>。</li><li>C和C++内存管理的方法不一样，C使用malloc&#x2F;free，C++除此之外还用new&#x2F;delete</li><li>C++中还有函数重载和引用等概念，C中没有</li></ul><h2 id="（7）delete和delete-的区别"><a href="#（7）delete和delete-的区别" class="headerlink" title="（7）delete和delete[]的区别"></a>（7）delete和delete[]的区别</h2><ul><li><p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数</p></li><li><p>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p></li></ul><h2 id="（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"><a href="#（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）" class="headerlink" title="（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"></a>（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h2><p>包括但不限于：</p><ul><li>C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。</li><li>C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法</li><li>JAVA和C++都有构造函数，但是C++有析构函数但是Java没有</li><li>C++有指针，Java没有指针，只有引用</li></ul><h2 id="（9）C-和python的区别"><a href="#（9）C-和python的区别" class="headerlink" title="（9）C++和python的区别"></a>（9）C++和python的区别</h2><p>包括但不限于：</p><ol><li>python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li><li>python使用缩进来区分不同的代码块，C++使用花括号来区分</li><li>C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li><li>python的库函数比C++的多，调用起来很方便</li></ol><h2 id="（10）-struct和class的区别"><a href="#（10）-struct和class的区别" class="headerlink" title="（10） struct和class的区别"></a>（10） struct和class的区别</h2><ul><li>使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的</li><li>struct的继承默认是public继承，而class的继承默认是private继承</li><li>class可以用作模板，而struct不能</li></ul><h2 id="（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）"><a href="#（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）" class="headerlink" title="（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）"></a>（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）</h2><p>  联系：它们都是定义常量的一种方法。</p><p>  区别：</p><ul><li>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。</li><li>define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</li><li>define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。</li><li>const可以定义函数而define不可以。</li></ul><h2 id="（12）-在C-中const的用法（定义，用途）"><a href="#（12）-在C-中const的用法（定义，用途）" class="headerlink" title="（12） 在C++中const的用法（定义，用途）"></a>（12） 在C++中const的用法（定义，用途）</h2><ul><li>const修饰类的成员变量时，表示常量不能被修改</li><li>const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</li></ul><h2 id="（13）-C-中的static用法和意义"><a href="#（13）-C-中的static用法和意义" class="headerlink" title="（13） C++中的static用法和意义"></a>（13） C++中的static用法和意义</h2><p>static的意思是静态的，可以用来修饰变量，函数和类成员。</p><ul><li><p>变量：被static修饰的变量就是<strong>静态变量</strong>，它会在程序运行过程中一直存在，static修饰的变量一般有两种，局部的和全局的，如果局部的静态变量和全局的静态变量同名的话，这个局部的变量会覆盖全局的，然后局部变量作用域一般是在某个函数体内，如果这个函数被重复调用多次，这个局部的变量只会声明定义一次</p></li><li><p>函数：被static修饰的函数就是<strong>静态函数</strong>，静态函数只能在本文件中使用，<strong>不能被其他文件调用</strong>，也不会和其他文件中的同名函数冲突。</p></li><li><p>类：</p><ul><li><p>而在类中，被static修饰的成员变量是<strong>类静态成员</strong>，这个静态成员会被类的多个对象共用，如果static修饰的变量不是const类型的话，需要<strong>在类外定义</strong>。</p></li><li><p>被static修饰的成员函数也<strong>属于静态成员</strong>，<strong>不是属于某个对象</strong>的，访问这个静态函数不是通过对象名，而是通过<strong>引用类名来访问</strong>。不具有this指针</p></li></ul></li><li><p>初始化顺序：需要注意static在不同编译单元的<strong>初始化顺序</strong>没有明确的定义，可以通过local-static可以有一个明确的初始化顺序</p></li></ul><h2 id="（14）-计算下面几个类的大小："><a href="#（14）-计算下面几个类的大小：" class="headerlink" title="（14） 计算下面几个类的大小："></a>（14） 计算下面几个类的大小：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>空类的大小是1， 在C++中空类会占一个字节，这是<strong>为了让对象的实例能够相互区别</strong>。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的<strong>空白基类最优化</strong>。</p><p>空类的实例大小就是类的大小，所以sizeof(a)&#x3D;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  A a; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; <span class="type">int</span> b; &#125;;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p><h2 id="（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h2><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p><ul><li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li><li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li><li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li></ul><h2 id="（16）-STL源码中的hash表的实现"><a href="#（16）-STL源码中的hash表的实现" class="headerlink" title="（16） STL源码中的hash表的实现"></a>（16） STL源码中的hash表的实现</h2><p>STL中的hash表就unordered_map，它记录的<strong>键</strong>是<strong>元素的哈希值</strong>，通过对比元素的哈希值<strong>来确定元素的值</strong>。采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过8时，就自动转为红黑树进行组织。</p><h2 id="（17）解决哈希冲突的方式？"><a href="#（17）解决哈希冲突的方式？" class="headerlink" title="（17）解决哈希冲突的方式？"></a>（17）解决哈希冲突的方式？</h2><ol><li>线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。</li><li>二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找1^2,2^2,3^2,4^2…..i^2个位置。</li><li>双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。</li><li>开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，STL的hashtable就是采用这种实现方式。</li><li>建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。</li></ol><h2 id="（18）-STL中unordered-map和map的区别"><a href="#（18）-STL中unordered-map和map的区别" class="headerlink" title="（18） STL中unordered_map和map的区别"></a>（18） STL中unordered_map和map的区别</h2><ul><li>unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现&#x3D;&#x3D;操作符。</li><li>map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。</li></ul><h2 id="（19）-STL中vector的实现"><a href="#（19）-STL中vector的实现" class="headerlink" title="（19） STL中vector的实现"></a>（19） STL中vector的实现</h2><p>STL中的vector是<strong>封装了动态数组的顺序容器</strong>。<strong>不过与动态数组不同的是</strong>，vector在容量不够的时候会自动扩大容器的大小。具体策略是更大内存，一般是原来的两倍，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针，还可以通过将原来容器元素<strong>移动</strong>到新容器中，提高性能。这样子的话可以减少频繁插入元素时扩大容器的时间</p><h2 id="（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h2><p>如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分<strong>耗时和耗内存</strong>的，可以通过将原来容器元素移动到新容器中，提高性能。频繁调用push_back()会使得程序<strong>花费很多时间在vector扩容上</strong>，会变得很慢。这种情况可以考虑使用list。</p><h2 id="（21）C-中vector和list的区别"><a href="#（21）C-中vector和list的区别" class="headerlink" title="（21）C++中vector和list的区别"></a>（21）C++中vector和list的区别</h2><ul><li><p>vector和数组类似，拥有一段<strong>连续的内存空间</strong>，所以支持<strong>随机访问</strong>，然后它的插入和删除元素可能会<strong>导致大量元素的移动</strong>，造成大量拷贝，比较消耗内存。它还有<strong>自动扩容的机制</strong>，就是在容量不够的时候会分配一个内存容量更大的容器，然后将原来容器中的元素拷贝过去，这个过程比较消耗性能，可以通过将原来容器元素移动到新容器中，提高性能</p></li><li><p>list是由<strong>双向链表</strong>实现的，因此内存空间是<strong>不连续</strong>的，list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能<strong>高效地进行插入和删除</strong>。</p></li><li><p>迭代器</p><ul><li><p>vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+&#x3D;”，“&lt;”等操作符。list::iterator则不支持</p></li><li><p>vector::iterator和list::iterator都重载了“++”运算符。<strong>可用于遍历</strong></p></li></ul></li></ul><p>总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</p><p>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</p><h2 id="（22）-C-中的重载和重写的区别："><a href="#（22）-C-中的重载和重写的区别：" class="headerlink" title="（22） C++中的重载和重写的区别："></a>（22） C++中的重载和重写的区别：</h2><ul><li>重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，<strong>但返回值不可以作为区分不同重载函数的标志</strong>。</li><li>重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。</li></ul><p>详见：<a href="https://blog.csdn.net/weixin_30379911/article/details/99497160">https://blog.csdn.net/weixin_30379911/article/details/99497160</a></p><h2 id="（23）-C-内存管理（热门问题）"><a href="#（23）-C-内存管理（热门问题）" class="headerlink" title="（23） C ++内存管理（热门问题）"></a>（23） C ++内存管理（热门问题）</h2><p><a href="https://blog.csdn.net/qq_43152052/article/details/98889139">https://blog.csdn.net/qq_43152052/article/details/98889139</a></p><p>在C++中，内存分成5个区，他们分别是堆、栈、全局&#x2F;静态存储区和常量存储区和代码区。</p><ul><li><p><strong>栈</strong>：由**&#x3D;&#x3D;编译器&#x3D;&#x3D;**自动分配释放，存放为函数运行的局部变量，函数参数，返回数据，返回地址等。</p><ul><li>操作系统会在<strong>底层</strong>对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈有专门的指令<strong>执行</strong>，但是分配的<strong>内存容量有限</strong>，超过容量就会导致栈溢出。</li><li>地址空间是向下增长的，越来越小</li></ul></li><li><p><strong>堆</strong>：一般由**&#x3D;&#x3D;程序员&#x3D;&#x3D;**分配释放，若程序员不释放，程序结束时可能由OS回收；分配方式类似于链表</p><ul><li>在操作系统中有一个<strong>记录空闲内存地址的链表</strong>。它记录了有哪些还未使用的内存空间。当系统收到程序的申请时，会遍历该链表，寻找<strong>第一个空间大于所申请空间的堆结点</strong>，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</li><li>地址空间是向上增长的，越来越大</li></ul></li><li><p><strong>全局&#x2F;静态存储区</strong>：内存在程序**&#x3D;&#x3D;编译的时候&#x3D;&#x3D;<strong>就已经分配好，这块内存在程序的</strong>整个运行期间**都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。</p></li><li><p><strong>常量</strong>存储区：里面存放的是<strong>常量字符串</strong>，不允许修改，无<strong>法访问常量的地址的。</strong></p></li><li><p><strong>代码区</strong>：存放程序的二进制代码</p></li></ul><p>关于这个有很多种说法，有的会增加一个自由存储区，存放new分配得到的内存，与堆相似。</p><img src="面经整理发布版.assets/1629687632@2dda0b7df0c9fdaecae07f062e25145a.png" alt="img" style="zoom:50%;" /><h2 id="（24）-介绍面向对象的三大特性，并且举例说明每一个。"><a href="#（24）-介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="（24） 介绍面向对象的三大特性，并且举例说明每一个。"></a>（24） 介绍面向对象的三大特性，并且举例说明每一个。</h2><p>面向对象的三大特性是：封装，继承和多态。</p><ul><li>封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；</li><li>继承使得子类可以复用父类的成员和方法，实现了代码重用；</li><li>多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。<ul><li>C++多态包括编译时多态和运行时多态，编译时多态体现在<strong>函数重载和模板上</strong>，运行时多态体现在<strong>虚函数</strong>上。</li></ul></li></ul><h2 id="（25）-多态的实现（和下个问题一起回答）"><a href="#（25）-多态的实现（和下个问题一起回答）" class="headerlink" title="（25） 多态的实现（和下个问题一起回答）"></a>（25） 多态的实现（和下个问题一起回答）</h2><p>C++ 多态包括编译时多态和运行时多态，编译时多态体现在<strong>函数重载和模板上</strong>，运行时多态体现在<strong>虚函数</strong>上。</p><ul><li>虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.</li></ul><h2 id="（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h2><ul><li><p>C++多态通过虚函数来实现，这个是运行时多态，编译时多态的话通过函数重载和模板来实现。</p></li><li><p><strong>是什么：</strong></p><ul><li>虚函数表是每个类中存放<strong>虚函数地址的&#x3D;&#x3D;指针数组&#x3D;&#x3D;<strong>，类的实例在</strong>调用虚函数时</strong>会<strong>在虚函数表中寻找函数地址进行调用</strong></li></ul></li><li><p><strong>编译期阶段</strong>：</p><ul><li>虚函数表是在编译阶段构建好的，而且编译器会为类生成一个<strong>指向虚函数表的指针</strong></li></ul><p><code>*__vptr</code></p></li><li><p><strong>注意点：</strong></p><ul><li>一个类的所有实例都共享&#x3D;&#x3D;<strong>同一张</strong>&#x3D;&#x3D;虚函数表</li><li><strong>子类</strong><ul><li>如果一个类继承了有虚函数的基类，这个子类也会有虚函数表和指向虚表的指针</li><li>如果子类重写了父类的虚函数，则子类的虚函数表会指向子类实现的&#x3D;&#x3D;函数地址&#x3D;&#x3D;，否则指向父类的函数地址。</li></ul></li></ul></li></ul><p>详见：<a href="https://blog.csdn.net/lihao21/article/details/50688337">C++虚函数表剖析</a></p><ul><li><p>如果多重继承和多继承的话，子类的虚函数表长什么样子？<br><strong>多重继承</strong>的情况下**&#x3D;&#x3D;越是祖先&#x3D;&#x3D;<strong>的父类的虚函数更靠前，</strong>多继承<strong>的情况下越是</strong>&#x3D;&#x3D;靠近子类名称&#x3D;&#x3D;**的类的虚函数在虚函数表中更靠前。详见：<a href="https://blog.csdn.net/qq_36359022/article/details/81870219">https://blog.csdn.net/qq_36359022/article/details/81870219</a></p></li><li><p>我们把经过虚表调用虚函数的过程称为<strong>动态绑定</strong></p><ul><li>调用虚函数、通过指针调用函数</li></ul></li><li><p>传统的函数调用我们称之为<strong>静态绑定</strong></p></li></ul><h2 id="（27）-编译器如何处理处理虚函数表"><a href="#（27）-编译器如何处理处理虚函数表" class="headerlink" title="（27） 编译器如何处理处理虚函数表"></a>（27） 编译器如何处理处理虚函数表</h2><ul><li>见（26）</li></ul><h2 id="（28）-基类的析构函数一般写成虚函数的原因"><a href="#（28）-基类的析构函数一般写成虚函数的原因" class="headerlink" title="（28） 基类的析构函数一般写成虚函数的原因"></a>（28） 基类的析构函数一般写成虚函数的原因</h2><ul><li>不是虚函数<ul><li>当<strong>析构</strong>一个<strong>指向子类的父类指针</strong>时，如果子类的析构函数不是虚函数的话，编译器就会实施静态绑定，调用父类的析构函数而不是调用子类的析构函数，这样会因为子类<strong>析构不完全</strong>而导致<strong>内存泄漏</strong></li></ul></li><li>是虚函数<ul><li>编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而<strong>正确</strong>释放子类对象的资源。</li></ul></li></ul><h2 id="（29）-构造函数为什么一般不定义为虚函数"><a href="#（29）-构造函数为什么一般不定义为虚函数" class="headerlink" title="（29） 构造函数为什么一般不定义为虚函数"></a>（29） 构造函数为什么一般不定义为虚函数</h2><ul><li><strong>因为子类在构造的时候，是先构造父类，再构造子类</strong>，如果父类的构造函数是虚函数的话，子类要调用这个函数就要通过虚函数表来调用，然而虚函数表是在子类构造的时候才会创建出来，从而无法调用父类的构造函数</li></ul><h2 id="（30）-构造函数或者析构函数中调用虚函数会怎样"><a href="#（30）-构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="（30） 构造函数或者析构函数中调用虚函数会怎样"></a>（30） 构造函数或者析构函数中调用虚函数会怎样</h2><ul><li>首先子类在构造的时候，是先构造父类，再构造子类，如果父类在构造函数中调用虚函数的话，就需要访问子类的虚函数表，然而子类的虚函数表是在子类构造的时候才创建的，所以无法实现。</li><li>在析构的时候，是先析构子类，再析构父类，然后，子类在被析构的时候，虚函数表已经被释放掉了，然而父类的析构函数需要虚函数表来调用函数，所以无法实现</li></ul><h2 id="（31）-纯虚函数"><a href="#（31）-纯虚函数" class="headerlink" title="（31） 纯虚函数"></a>（31） 纯虚函数</h2><ul><li>是什么<ul><li>纯虚函数是**&#x3D;&#x3D;只有声明没有实现&#x3D;&#x3D;**的虚函数，需要子类重写这个纯虚函数</li></ul></li><li>注意点<ul><li>包含纯虚函数的类是抽象类，它**&#x3D;&#x3D;不能被实例化&#x3D;&#x3D;<strong>，子类只有重写了这个纯虚函数</strong>才能**生成对象</li></ul></li></ul><p>使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。</p><h2 id="（32）-静态绑定和动态绑定的介绍"><a href="#（32）-静态绑定和动态绑定的介绍" class="headerlink" title="（32） 静态绑定和动态绑定的介绍"></a>（32） 静态绑定和动态绑定的介绍</h2><p><a href="https://www.cnblogs.com/lizhenghn/p/3657717.html">C++中的静态绑定和动态绑定</a></p><ul><li><p>静态绑定就是绑定静态类型，静态类型就是对象&#x3D;&#x3D;<strong>在声明时</strong>&#x3D;&#x3D;采用的类型，在编译期既已确定</p></li><li><p>动态绑定就是绑定动态类型，通常是指一个<strong>指针或引用</strong>&#x3D;&#x3D;目前&#x3D;&#x3D;所指对象的类型，是在运行期决定的</p></li></ul><h2 id="（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h2><ul><li>一般是再拷贝指针的时候出现的深拷贝和浅拷贝</li><li>浅拷贝指的是只拷贝指针，不拷贝指针指向的内容，这样就有两个指针指向同一块内存，如果通过一个指针释放掉这块内存，然后又用另一个指针释放这块内存，就会产生错误</li><li>深拷贝就是用来解决这个问题，就是把指针和指针指向的内存都拷贝一份就可以了。</li></ul><h2 id="（34）-对象复用的了解，零拷贝的了解"><a href="#（34）-对象复用的了解，零拷贝的了解" class="headerlink" title="（34） 对象复用的了解，零拷贝的了解"></a>（34） 对象复用的了解，零拷贝的了解</h2><ul><li><p>对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是**&#x3D;&#x3D;继承和复合&#x3D;&#x3D;**模式了。</p></li><li><p>C++中 emplace_back 就是利用零拷贝的技术</p></li><li><p>Linux中零拷贝指的是完全在内核中进行的操作，从而可以避免内核缓冲区和用户缓冲区之间的数据拷贝，效率很高</p></li><li><p>我了解到的一些零拷贝的Linux的api有<strong>sendfile，splice，tee，mmap</strong></p></li><li><p>sendfile是两个文件描述符之间传递数据</p></li><li><p>splice是两个文件描述符之间移动数据</p></li><li><p>tee是两个文件描述符之间传递数据，至少有一个文件描述符是管道描述符</p></li><li><p>mmap会在内核缓冲区开辟一个共享内存，这个共享内存对用进程是可见的，进程可以直接从共享内存读取和发送数据</p><ul><li>共享内存介绍——&gt;操作系统（4）</li></ul></li></ul><blockquote><p>用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p></blockquote><h2 id="（35）-介绍C-所有的构造函数"><a href="#（35）-介绍C-所有的构造函数" class="headerlink" title="（35） 介绍C++所有的构造函数"></a>（35） 介绍C++所有的构造函数</h2><ul><li><ul><li><p>C++中的构造函数可以分为4类：</p><ul><li>默认构造函数</li><li>初始化构造函数（有参数）</li><li>拷贝构造函数</li><li>移动构造函数（move和右值引用）</li><li>委托构造函数？</li><li>转换构造函数</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>() &#123;<span class="comment">//默认构造函数，没有参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> a, <span class="type">int</span> n):<span class="built_in">age</span>(a), <span class="built_in">num</span>(n) &#123;&#125;; <span class="comment">//初始化构造函数，有参数和参数列表</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student&amp; s) &#123;<span class="comment">//拷贝构造函数，这里与编译器生成的一致</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = s.age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = s.num;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> r) &#123;   <span class="comment">//转换构造函数,形参是其他类型变量，且只有一个形参</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = r;</span><br><span class="line"><span class="keyword">this</span>-&gt;num = <span class="number">1002</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">18</span>,<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function">Student <span class="title">s3</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s4</span><span class="params">(s3)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 age:%d, num:%d\n&quot;</span>, s1.age, s1.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 age:%d, num:%d\n&quot;</span>, s2.age, s2.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s3 age:%d, num:%d\n&quot;</span>, s3.age, s3.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 age:%d, num:%d\n&quot;</span>, s4.age, s4.num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// s1 age:20, num:1000</span></span><br><span class="line"><span class="comment">// s2 age:18, num:1001</span></span><br><span class="line"><span class="comment">// s3 age:10, num:1002</span></span><br><span class="line"><span class="comment">// s2 age:10, num:1002</span></span><br></pre></td></tr></table></figure><ul><li>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</li><li>复制构造函数用于复制本类的对象</li><li>转换构造函数用于将其他类型的变量，隐式转换为本类对象</li></ul></li></ul></li></ul><h2 id="（36）-什么情况下会调用拷贝构造函数（三种情况）"><a href="#（36）-什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="（36） 什么情况下会调用拷贝构造函数（三种情况）"></a>（36） 什么情况下会调用拷贝构造函数（三种情况）</h2><ul><li><p>对象以值传递的方式传入函数参数 </p><blockquote><p>如 <code> void func(Dog dog)&#123;&#125;;</code></p></blockquote></li><li><p>对象以值传递的方式从函数返回</p><blockquote><p>如 <code> Dog func()&#123; Dog d; return d;&#125;</code></p></blockquote></li><li><p>对象需要通过另外一个对象进行初始化</p></li></ul><p>详见：<a href="https://blog.csdn.net/lwbeyond/article/details/6202256">C++拷贝构造函数详解</a></p><h2 id="（37）-结构体内存对齐方式和为什么要进行内存对齐？"><a href="#（37）-结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="（37） 结构体内存对齐方式和为什么要进行内存对齐？"></a>（37） 结构体内存对齐方式和为什么要进行内存对齐？</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/image-20230602131558223.png" alt="image-20230602131558223"></p><ul><li>主要是为了提高cpu读取的效率</li><li>由于CPU读取数据是按块读取的，可以使得CPU一次就可以将所需的数据读进来</li><li>对齐规则<ul><li>变量<strong>只能</strong>存储在其类型长度的<strong>整数倍地址</strong></li><li>结构体还需要和其拥有对象的长度最长的类型的长度的整数倍对齐</li><li>前提是pack参数比类型长度要长，否则遍历存储在pack参数的整数倍地址<ul><li>#pragram pack(show) 来看pack参数大小</li></ul></li><li>数组按照数组的类型来对齐</li><li>嵌套的struct是按照规则2取对齐参数</li></ul></li></ul><h2 id="（38）内存泄漏的定义，产生原因，如何检测与避免？"><a href="#（38）内存泄漏的定义，产生原因，如何检测与避免？" class="headerlink" title="（38）内存泄漏的定义，产生原因，如何检测与避免？"></a>（38）内存泄漏的定义，产生原因，如何检测与避免？</h2><ul><li><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为<strong>内存泄漏</strong>。</p></li><li><p>造成内存泄漏的几种原因：</p><ul><li>new和delete**&#x3D;&#x3D;没有配套&#x3D;&#x3D;**使用</li><li>用new[]为一组对象分配了内存，在释放对象数组时**&#x3D;&#x3D;没有使用delete[]&#x3D;&#x3D;**，使用了delete</li><li>没有将基类的**&#x3D;&#x3D;析构函数&#x3D;&#x3D;**定义为虚函数，当要释放一个指向子类的基类指针时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</li><li>没有正确的清楚嵌套的对象指针<ul><li>对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间</li><li>指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了</li></ul></li></ul></li><li><p>避免方法：</p><ul><li>new&#x2F;delete，malloc&#x2F;free要配套</li><li>使用智能指针</li><li>将基类的析构函数设为虚函数</li></ul></li><li><p><strong>检测工具</strong></p><ul><li>Linux下可以使用<strong>Valgrind工具</strong></li><li>Windows下可以使用<strong>CRT库</strong></li></ul></li><li><p><a href="https://blog.csdn.net/We_are_family678/article/details/79658097">C++内存泄露检查的5个方法</a></p></li></ul><h2 id="（39）-C-的智能指针有哪些"><a href="#（39）-C-的智能指针有哪些" class="headerlink" title="（39） C++的智能指针有哪些"></a>（39） C++的智能指针有哪些</h2><p>C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记<strong>释放指针指向的内存地址</strong>造成内存泄漏。</p><ul><li><p>auto_ptr</p><ul><li>是较早版本的智能指针，在进行指针拷贝和赋值的时候，会将旧指针&#x3D;&#x3D;<strong>管理权</strong>&#x3D;&#x3D;交给新指针并让旧指针置空，但是这种方式在需要访问旧指针的时候，就会出现问题，。C++11 已将其摒弃</li></ul></li><li><p>unique_ptr</p><ul><li>是auto_ptr的一个改良版，unique_ptr更安全，更灵活，不支持赋值也不能拷贝构造，支持移动构造和移动复制，为了<strong>保证一个对象同一时间只有一个智能指针</strong><ul><li>更安全：编译器会自动检测是否使用了拷贝语义</li><li>更灵活：可以进行临时对象拷贝：函数返回临时对象，还多了删除器</li><li>reset(new …)：重置空间，原来空间清理</li><li>主动释放空间：p &#x3D; nullptr（只支持nullptr赋值）</li><li>释放所有权：auto p1 &#x3D; p0.release(); delete p1; 需要手动释放空间</li><li>自定义空间删除方法：传删除器（是个类函数）可以用来关闭连接（文件描述符）：close(fd)，管理锁</li><li>有着十分接近裸指针的性能</li></ul></li></ul></li><li><p>shared_ptr</p><ul><li>可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。（内部使用计数机制进行维护）</li><li>删除器是函数指针或者 lambda 表达式</li></ul></li><li><p>weak_ptr</p><ul><li>是为了**&#x3D;&#x3D;协助 shared_ptr&#x3D;&#x3D;**而出现的。它不能访问对象，只能观测shared_ptr的引用计数，解决shared_ptr 循环引用的问题<ul><li><strong>循环引用</strong>：两个类的shared_ptr指针，互相内部有share_ptr导致对方use_count+1 &#x3D;&#x3D; 2，两个share_ptr离开作用域后use_count - 1 &#x3D;&#x3D; 1，此时都想要对方内部的share_ptr析构，但类无法析构，类内的成员也就无法析构</li><li>可以用 lock() 访问对象：如果对象存在获取一个share_ptr的引用计数不为0获取临时的share_ptr，离开其作用域后use_count-1</li><li>expired()：判断对象是否被销毁</li></ul></li></ul></li></ul><ul><li>简单实现一个<strong>线程安全</strong>shared_ptr<ul><li>模板</li><li>explicit重载构造：初始化列表 _ptr，_refCount，_mutex</li><li>拷贝构造：初始化列表 _ptr，_refCount，_mutex &amp;&amp; 线程安全 _refCount++</li><li>赋值构造：自我赋值检测 + 线程安全release + 赋值 + 线程安全 _refCount++</li><li>重载 * 和 -&gt;</li><li>返回内置指针 + 返回 _refCount</li><li>线程安全 _refCount++ + 线程安全release</li><li>T* _ptr + int* _pRefcount + mutex* _pMutex</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shared_Ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Shared_Ptr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span><span class="comment">// 重载构造函数</span></span></span><br><span class="line"><span class="function">                        :_pPtr(ptr)</span></span><br><span class="line"><span class="function">                        , _pRefCount(new int(<span class="number">1</span>))</span></span><br><span class="line"><span class="function">                        , _pMutex(new mutex) &#123;</span>&#125;</span><br><span class="line">~<span class="built_in">Shared_Ptr</span>() &#123;</span><br><span class="line"><span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Shared_Ptr</span>(<span class="type">const</span> Shared_Ptr&lt;T&gt;&amp; sp)<span class="comment">//拷贝构造函数</span></span><br><span class="line">   :_pPtr(sp._pPtr)</span><br><span class="line">               , _pRefCount(sp._pRefCount)</span><br><span class="line">               , _pMutex(sp._pMutex) &#123;</span><br><span class="line"><span class="built_in">AddRefCount</span>();</span><br><span class="line">&#125;</span><br><span class="line">Shared_Ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Shared_Ptr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line"><span class="comment">//if (this != &amp;sp)</span></span><br><span class="line"><span class="keyword">if</span> (_pPtr != sp._pPtr) &#123;<span class="comment">//检测自我赋值</span></span><br><span class="line"><span class="comment">// 释放管理的旧资源</span></span><br><span class="line"><span class="built_in">Release</span>();</span><br><span class="line"><span class="comment">// 共享管理新对象的资源，并增加引用计数</span></span><br><span class="line">_pPtr = sp._pPtr;</span><br><span class="line">_pRefCount = sp._pRefCount;</span><br><span class="line">_pMutex = sp._pMutex;</span><br><span class="line"><span class="built_in">AddRefCount</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>*() &#123;<span class="comment">// 解引用</span></span><br><span class="line"><span class="keyword">return</span> *_pPtr;</span><br><span class="line">&#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() &#123;<span class="comment">// -&gt;</span></span><br><span class="line"><span class="keyword">return</span> _pPtr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">UseCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *_pRefCount; &#125;<span class="comment">//返回引用计数</span></span><br><span class="line"><span class="function">T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _pPtr; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddRefCount</span><span class="params">()</span> </span>&#123;<span class="comment">// 线程安全 ++count</span></span><br><span class="line">_pMutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line">++(*_pRefCount);</span><br><span class="line">_pMutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;<span class="comment">// 线程安全 释放</span></span><br><span class="line"><span class="type">bool</span> deleteflag = <span class="literal">false</span>;</span><br><span class="line">_pMutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> _pRefCount;</span><br><span class="line"><span class="keyword">delete</span> _pPtr;</span><br><span class="line">deleteflag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">_pMutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">if</span> (deleteflag == <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">delete</span> _pMutex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> *_pRefCount;<span class="comment">// 全是指针</span></span><br><span class="line">T* _pPtr;</span><br><span class="line">mutex* _pMutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>简单实现一个<strong>线程安全</strong>weak_ptr（后面准备暑期实习的时候再加上）<ul><li>解决 share_ptr 循环引用问题</li><li>lock()：获取 share_ptr 指针，如果count &#x3D;&#x3D; 0 return nullptr</li></ul></li><li>简单实现一个<strong>线程安全</strong>unique_ptr（后面准备暑期实习的时候再加上）</li></ul><h2 id="（40）-调试程序的方法"><a href="#（40）-调试程序的方法" class="headerlink" title="（40） 调试程序的方法"></a>（40） 调试程序的方法</h2><ul><li>通过设置断点进行调试</li><li>打印log进行调试</li><li>打印中间结果进行调试</li></ul><h2 id="（41）-遇到coredump要怎么调试"><a href="#（41）-遇到coredump要怎么调试" class="headerlink" title="（41） 遇到coredump要怎么调试"></a>（41） 遇到coredump要怎么调试</h2><p>——&gt;Linux（18）coredump 是什么 + 产生 coredump 的原因</p><ul><li>使用gdb命令对core文件进行调试</li></ul><p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir coredumpTest</span><br><span class="line">vim coredumpTest.cpp</span><br></pre></td></tr></table></figure><p>在编辑器内键入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,i);<span class="comment">//正确的应该是&amp;i,这里使用i会导致segment fault</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ coredumpTest.cpp -g -o coredumpTest</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./coredumpTest</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/46605905">使用gdb调试coredump</a>：有时间再多了解</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [可执行文件名] [core文件名]</span><br></pre></td></tr></table></figure><h2 id="（42）-inline关键字说一下-和宏定义有什么区别"><a href="#（42）-inline关键字说一下-和宏定义有什么区别" class="headerlink" title="（42） inline关键字说一下 和宏定义有什么区别"></a>（42） inline关键字说一下 和宏定义有什么区别</h2><blockquote><p>inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。inline函数被修改后程序需要重新编译。</p></blockquote><ul><li>建议：<ul><li>inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个<strong>建议</strong>，如果inline函数太复杂：带有循环或递归、switch-case语句inline会失效，编译器可以选择忽略该建议，不对该函数进行展开。</li></ul></li><li>编译：<ul><li>内联函数在<strong>编译时</strong>直接被<strong>嵌入到目标代码</strong>中去，而宏在<strong>预编译</strong>时进行一个简单的<strong>文本替换</strong>。</li><li>内联函数可以进行诸如<strong>类型安全检查</strong>、<strong>语句是否正确</strong>等编译功能，宏不具有这样的功能。</li></ul></li><li>函数<ul><li>宏不是函数，而inline是函数</li><li>宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现<strong>二义性</strong>。而内联函数不会出现二义性。</li></ul></li></ul><h2 id="（43）-模板的用法与适用场景-实现原理"><a href="#（43）-模板的用法与适用场景-实现原理" class="headerlink" title="（43） 模板的用法与适用场景 实现原理"></a>（43） 模板的用法与适用场景 实现原理</h2><ul><li><p>用template &lt;typename T&gt;关键字进行声明，接下来就可以进行模板函数和模板类的编写了</p></li><li><p>编译器会对函数模板进行<strong>两次编译</strong>：在声明的地方对&#x3D;&#x3D;模板代码&#x3D;&#x3D;本身进行编译，这次编译<strong>只会进行一个语法检查</strong>，并不会生成具体的代码。在创建实例的时候对代码进行参数替换后再进行编译，生成<strong>具体的函数代码</strong>。</p></li></ul><h2 id="（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h2><p>成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span> (<span class="type">int</span> &amp;inputID, string &amp;inputName, FaceImage &amp;inputFace);</span><br><span class="line">    ~<span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    FaceImage face;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">A</span> (<span class="type">int</span> &amp;inputID, string &amp;inputName, FaceImage &amp;inputFace)</span><br><span class="line">       : <span class="built_in">id</span>(inputID), <span class="built_in">name</span>(inputName), <span class="built_in">face</span>(inputFace) &#123;&#125;<span class="comment">// 成员初始化列表</span></span><br></pre></td></tr></table></figure><p>因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了默认构造函数的过程，否则会调用一次默认构造函数，再调用赋值构造函数。所以使用成员初始化列表效率会高一些。</p><ul><li><p>有三种情况是<strong>必须使用成员初始化列表进行初始化</strong>的：</p><ul><li><p><strong>常量成员</strong>的初始化，因为常量成员只能初始化不能赋值</p></li><li><p><strong>引用</strong>类型</p></li><li><p>没有默认构造函数的类类型：使用初始化列表可以不用调用默认构造函数</p></li></ul></li></ul><p>详见<a href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html">C++ 初始化列表</a></p><h2 id="（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h2><ul><li><p><strong>自动类型推导auto</strong> 和 <strong>decltype</strong></p><ul><li>auto 根据<code>=</code>右边的初始值 value 推导出变量的类型；</li><li>decltype 根据 exp 表达式推导出变量的类型，跟<code>=</code>右边的 value 没有关系。</li><li>decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符。<ul><li>以下是 auto 关键字对 cv 限定符的推导规则：<ul><li>如果表达式的类型不是<a href="http://c.biancheng.net/c/80/">指针</a>或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。</li><li>如果表达式的类型是指针或者引用，auto 将保留 cv 限定符。</li></ul></li><li>decltype推到引用时就是引用，auto推导出引用对象类型</li></ul></li></ul></li><li><p><strong>lambda表达式</strong>：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：<br><code>[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型&#123;函数体&#125;</code></p></li><li><p>新的<strong>智能指针</strong> <strong>unique_ptr和shared_ptr</strong></p></li><li><p><strong>nullptr</strong></p><ul><li>函数参数进行传参的时候传入NULL可能会产生二义性问题，NULL既可以表示 <strong>(int)0</strong>，也可以表示 <em><em>(void</em>)0</em>*</li><li>nullptr的类型就是void*</li></ul></li><li><p><strong>thread类和mutex类</strong></p></li><li><p>更多详见：<a href="https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279">https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279</a></p></li></ul><h2 id="（46）C-函数调用的压栈过程"><a href="#（46）C-函数调用的压栈过程" class="headerlink" title="（46）C++函数调用的压栈过程"></a>（46）C++函数调用的压栈过程</h2><p>从代码入手，解释这个过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> var1 = param1;</span><br><span class="line"><span class="type">int</span> var2 = param2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;var1=%d,var2=%d&quot;</span>, <span class="built_in">f</span>(var1), <span class="built_in">f</span>(var2));<span class="comment">//如果将printf换为cout进行输出，输出结果则刚好相反</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// var1=1,var2=2</span></span><br></pre></td></tr></table></figure><ul><li>当函数从入口函数main函数开始执行时，编译器会将我们<strong>操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈</strong>；</li><li>当main函数开始调用func()函数时，编译器此时会将<strong>main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈</strong>；</li><li>当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</li><li>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</li></ul><p>函数的调用过程：</p><ul><li>从栈空间分配存储空间</li><li>从实参的<strong>存储空间</strong>复制值到<strong>形参栈空间</strong></li><li>进行运算</li></ul><p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p><p>数组作为参数的函数调用方式是<strong>地址传递</strong>，形参和实参都指向相同的内存空间，调用完成后，<strong>形参指针被销毁</strong>，但是所指向的内存空间依然存在，不能也不会被销毁。</p><p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。</p><h2 id="（47）-C-的四种强制转换"><a href="#（47）-C-的四种强制转换" class="headerlink" title="（47） C++的四种强制转换"></a>（47） C++的四种强制转换</h2><p>四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast</p><ul><li><p>1）static_cast ：<br>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。</p><blockquote><p>特性与要点：</p><ol><li>它没有运行时类型检查，所以是有安全隐患的。</li><li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li><li>static_cast不能转换const，volatile等属性</li></ol></blockquote></li><li><p>2）dynamic_cast：<br>用于动态类型转换。具体的说，就是在<strong>基类指针到派生类指针</strong>，或者<strong>派生类到基类指针</strong>的转换。<br>dynamic_cast能够提供<strong>运行时类型检查</strong>，只用于&#x3D;&#x3D;含有虚函数的类&#x3D;&#x3D;。<br>dynamic_cast如果不能转换<strong>返回NULL</strong>。</p></li><li><p>3）const_cast：<br>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</p></li><li><p>4）reinterpret_cast<br>几乎什么都可以转，用在任意的<strong>指针之间的转换</strong>，<strong>引用之间的转换</strong>，<strong>指针和足够大的int型之间</strong>的转换，整数到指针的转换等。但是不够安全。</p></li></ul><h2 id="（48）string的底层实现"><a href="#（48）string的底层实现" class="headerlink" title="（48）string的底层实现"></a>（48）string的底层实现</h2><p>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</p><p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p><h2 id="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"><a href="#（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的" class="headerlink" title="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"></a>（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</h2><h3 id="（1）预编译"><a href="#（1）预编译" class="headerlink" title="（1）预编译"></a>（1）预编译</h3><p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：</p><ol><li>删除所有的#define，展开所有的宏定义。</li><li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</li><li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。</li><li>删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</li><li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。</li><li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。</li></ol><h3 id="（2）编译"><a href="#（2）编译" class="headerlink" title="（2）编译"></a>（2）编译</h3><p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应 的汇编代码文件。</p><ol><li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分 割成一系列的记号。</li><li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的 语法树是一种以表达式为节点的树。</li><li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进 行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义。</li><li>优化：源代码级别的一个优化过程。</li><li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言 表示。</li><li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移 来替代乘法运算、删除多余的指令等。</li></ol><h3 id="（3）汇编"><a href="#（3）汇编" class="headerlink" title="（3）汇编"></a>（3）汇编</h3><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没 有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过 来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Window下)。</p><h3 id="（4）链接"><a href="#（4）链接" class="headerlink" title="（4）链接"></a>（4）链接</h3><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链 接：</p><ul><li><strong>静态链接</strong></li></ul><p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p><p>&#x3D;&#x3D;空间浪费&#x3D;&#x3D;：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p><p>&#x3D;&#x3D;更新困难&#x3D;&#x3D;：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p><p>运行&#x3D;&#x3D;速度快&#x3D;&#x3D;：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快。</p><ul><li><strong>动态链接</strong></li></ul><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形 成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><p>&#x3D;&#x3D;共享&#x3D;&#x3D;库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副 本，而是这多个程序在执行时<strong>共享同一份副本</strong>；</p><p>&#x3D;&#x3D;更新方便&#x3D;&#x3D;：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运 行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p><p>&#x3D;&#x3D;性能损耗&#x3D;&#x3D;：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损 失。</p><h2 id="（50）set，map和vector的插入复杂度"><a href="#（50）set，map和vector的插入复杂度" class="headerlink" title="（50）set，map和vector的插入复杂度"></a>（50）set，map和vector的插入复杂度</h2><ul><li>set,map的插入复杂度就是红黑树的插入复杂度，是log(N)</li><li>unordered_set,unordered_map的插入复杂度是常数，最坏是O(N)</li><li>vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝</li></ul><h2 id="（51）定义和声明的区别"><a href="#（51）定义和声明的区别" class="headerlink" title="（51）定义和声明的区别"></a>（51）定义和声明的区别</h2><ul><li><p>声明是告诉编译器变量的类型和名字，<strong>不会为变量分配内存</strong></p></li><li><p>定义就是对这个变量和函数进行<strong>内存分配和初始化</strong></p></li><li><p>同一个变量可以被声明多次，但是只能被定义一次</p></li></ul><h2 id="（52）typdef和define区别"><a href="#（52）typdef和define区别" class="headerlink" title="（52）typdef和define区别"></a>（52）typdef和define区别</h2><ul><li><p>#define是预处理命令，在预处理是执行简单的替换</p></li><li><p>typedef是在<strong>编译时</strong>处理的，它是在<strong>自己的作用域内给其中的类型起别名</strong></p></li><li><p>define不检查数据类型；typedef会检查数据类型</p></li></ul><h2 id="（53）被free回收的内存是立即返还给操作系统吗？为什么"><a href="#（53）被free回收的内存是立即返还给操作系统吗？为什么" class="headerlink" title="（53）被free回收的内存是立即返还给操作系统吗？为什么"></a>（53）被free回收的内存是立即返还给操作系统吗？为什么</h2><p><a href="https://blog.csdn.net/YMY_mine/article/details/81180168">https://blog.csdn.net/YMY_mine/article/details/81180168</a></p><ul><li><p>不是的，被free回收的内存会首先被**&#x3D;&#x3D;ptmalloc内存管理器&#x3D;&#x3D;<strong>使用</strong>双链表<strong>保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就</strong>避免了频繁的系统调用<strong>，占用过多的系统资源。同时ptmalloc也会尝试对</strong>小块内存进行合并<strong>，避免过多的</strong>内存碎片**。</p></li><li><p>了解</p><ul><li>ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk</li><li>ptmalloc将相似大小的 chunk 用<a href="https://so.csdn.net/so/search?q=%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8&spm=1001.2101.3001.7020">双向链表</a>链接起来，这样的一个链表被称为一个 bin。Ptmalloc 一共维护了 128 个 bin，并使用一个数组来存储这些 bin（如下图所示）。</li></ul><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/70.png" alt="img"></p></li></ul><h2 id="（54）引用作为函数参数以及返回值的好处"><a href="#（54）引用作为函数参数以及返回值的好处" class="headerlink" title="（54）引用作为函数参数以及返回值的好处"></a>（54）引用作为函数参数以及返回值的好处</h2><ul><li>对比值传递，<strong>引用传参</strong>的好处：<ul><li>减少了值传递的时候<strong>生成副本的时间和空间消耗</strong>，提高函数调用和运行的效率</li><li>在函数内部可以对此参数进行<strong>修改</strong></li></ul></li><li>引用作为返回值<ul><li>用引用作为返回值最大的好处就是在内存中<strong>不产生</strong>返回值的<strong>副本</strong>。</li></ul></li></ul><p>但是有以下的限制：</p><ul><li><strong>不能返回局部变量的引用</strong>。<ul><li>因为函数返回以后局部变量就会被销毁</li></ul></li><li>不能<strong>返回函数内部new分配的内存的引用</strong>。<ul><li>虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。<strong>例如</strong>，被函数返回的引用<strong>只是作为一个临时变量出现</strong>，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</li></ul></li><li><strong>可以返回类成员的引用，但是最好是const</strong>。<ul><li>因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。</li></ul></li></ul><h2 id="（55）友元函数和友元类"><a href="#（55）友元函数和友元类" class="headerlink" title="（55）友元函数和友元类"></a>（55）友元函数和友元类</h2><p><a href="https://www.cnblogs.com/zhuguanhao/p/6286145.html">https://www.cnblogs.com/zhuguanhao/p/6286145.html</a></p><p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数<strong>可以访问类中的私有成员和保护成员</strong>。友元的正确使用能提高程序的运行效率，但同时也<strong>破坏了类的封装性和数据的隐藏性</strong>，导致程序可维护性变差。</p><p>1）友元函数</p><p>有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span></span>;      <span class="comment">//该函数是友元函数的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span> </span>&#123; <span class="comment">//友元函数定义，为了访问类A中的成员</span></span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line">    <span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p><p>2）友元类</p><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br>但是另一个类里面也要相应的进行声明</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">C</span>;                         <span class="comment">//这是友元类的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;             <span class="comment">//友元类定义，为了访问类A中的成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span> </span>&#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span> c;</span><br><span class="line">    c.<span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用友元类时注意： </p><p>(1) 友元关系<strong>不能被继承</strong>。 </p><p>(2) 友元关系是<strong>单向的</strong>，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 </p><p>(3) 友元关系<strong>不具有传递性</strong>。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p><h2 id="（56）说一下volatile关键字的作用"><a href="#（56）说一下volatile关键字的作用" class="headerlink" title="（56）说一下volatile关键字的作用"></a>（56）说一下volatile关键字的作用</h2><ul><li><p>volatile的意思是“脆弱的”，表明<strong>它修饰的变量的值十分容易被改变</strong>，所以编译器就<strong>不会对这个变量进行优化</strong>（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而<strong>提供稳定的访问</strong>。每次读取volatile的变量时，系统<strong>总是会从内存中</strong>读取这个变量，并且将它的值立刻保存。</p></li><li><p><code>gcc -O main.c -o main</code>：加了 -O 参数，编译器会进行优化</p><ul><li>使用本项优化，编译器会尝试&#x3D;&#x3D;减小生成代码的尺寸&#x3D;&#x3D;，以及&#x3D;&#x3D;缩短执行时间&#x3D;&#x3D;，但并不执行需要占用大量编译时间的优化。</li><li><a href="https://cloud.tencent.com/developer/article/1858501">GCC -O0 -O1 -O2 -O3 四级优化选项</a></li></ul></li></ul><h2 id="（57）STL中的sort-算法是用什么实现的，stable-sort-呢——-和十大排序再结合看"><a href="#（57）STL中的sort-算法是用什么实现的，stable-sort-呢——-和十大排序再结合看" class="headerlink" title="（57）STL中的sort()算法是用什么实现的，stable_sort()呢——&#x3D;&#x3D;和十大排序再结合看&#x3D;&#x3D;"></a>（57）STL中的sort()算法是用什么实现的，stable_sort()呢——&#x3D;&#x3D;和十大排序再结合看&#x3D;&#x3D;</h2><ul><li>STL中的sort用到了快速排序，但<strong>不仅仅只用了快速排序</strong>，还<strong>结合了插入排序和堆排序</strong>，stable_sort()是归并排序。</li><li>区别<ul><li>sort是快速排序实现，因此是不稳定的；stable_sort是归并排序实现，因此是&#x3D;&#x3D;稳定的&#x3D;&#x3D;；</li><li>对于相等的元素sort可能&#x3D;&#x3D;改变顺序&#x3D;&#x3D;，stable_sort保证排序后相等的&#x3D;&#x3D;元素次序不变&#x3D;&#x3D;；</li><li>如果提供了比较函数，sort不要求比较函数的参数被限定为const，而stable_sort则要求&#x3D;&#x3D;参数被限定为const&#x3D;&#x3D;，否则编译不能通过。</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/36274119">C++一道深坑面试题：STL里sort算法用的是什么排序算法？</a></li><li>其他问题：了解即可<ul><li>数据量大和数据量小都适合用快速排序吗？<ul><li>数据量小不适合用快速排序，因为频繁的<strong>递归调用</strong>会带来额外的负担；</li></ul></li><li>快速排序的时间复杂度不是稳定的nlogn，最坏情况会变成n^2，怎么解决复杂度恶化问题？<ul><li>随机选取中间数</li></ul></li><li>快速排序递归实现时，怎么解决递归层次过深的问题？<ul><li>控制递归次数，到达次数后改用堆排序（稳定的O(logn)）</li></ul></li><li>递归过深会引发什么问题？<ul><li>会导致栈溢出：操作系统规定了大小，Linux默认是8M（ulimit -a显示当前栈大小，ulimit -s修改栈大小），Windows是1M</li></ul></li><li>怎么控制递归深度？如果达到递归深度了还没排完序怎么办？</li></ul></li></ul><h2 id="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"><a href="#（58）vector会迭代器失效吗？什么情况下会迭代器失效？" class="headerlink" title="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"></a>（58）vector会迭代器失效吗？什么情况下会迭代器失效？</h2><p><a href="https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html">https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html</a></p><ul><li>会</li><li>当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效</li><li>当vector在插入的时候，end迭代器肯定会失效</li><li>当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。</li></ul><h2 id="（59）为什么C-没有实现垃圾回收？"><a href="#（59）为什么C-没有实现垃圾回收？" class="headerlink" title="（59）为什么C++没有实现垃圾回收？"></a>（59）为什么C++没有实现垃圾回收？</h2><ul><li>首先，实现一个垃圾回收器会带来<strong>额外的空间和时间开销</strong>。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要<strong>单独开辟一个线程</strong>在空闲的时候进行free操作。  </li><li>垃圾回收会使得C++不适合进行<strong>很多底层的操作</strong>。</li></ul><h2 id="（60）左值引用与右值引用的区别？右值引用的作用"><a href="#（60）左值引用与右值引用的区别？右值引用的作用" class="headerlink" title="（60）左值引用与右值引用的区别？右值引用的作用"></a>（60）左值引用与右值引用的区别？右值引用的作用</h2><ul><li><strong>左值引用，就是绑定到左值的引用，通过&amp;来获得左值引用</strong><ul><li>左值引用要求右边的值必须能够取地址</li><li>可以使用<strong>常左值引用</strong>才能<strong>绑定右值</strong><ul><li>使用常左值引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了</li></ul></li></ul></li><li><strong>右值引用，就是绑定到右值的引用，通过&amp;&amp;来获得右值引用</strong><ul><li>只能绑定到一个将要销毁的对象（字面值、临时对象）</li></ul></li><li>右值引用的作用<ul><li>主要用于<strong>移动语义</strong>std::move和完美转发std::forword</li><li><strong>零拷贝</strong><ul><li>移动构造函数和移动赋值构造函数</li></ul></li></ul></li></ul><h2 id="（61）move和forward完美转发"><a href="#（61）move和forward完美转发" class="headerlink" title="（61）move和forward完美转发"></a>（61）move和forward完美转发</h2><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><ul><li><p><code>int &amp;&amp;rr2 = std::move(rr1);</code></p></li><li><p><code>move</code>告诉编译器，我们有一个左值，但我希望像右值一样处理它。</p></li><li><p>调用<code>move</code>意味着：除了对<code>rr1</code>赋值或者销毁它外，我们将不再使用它。</p></li><li><p>标准库<code>move</code>函数是使用右值引用的模板的一个很好的例子。</p></li><li><p>从一个左值<code>static_cast</code>到一个右值引用是允许的。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward"></a>完美转发 std::forward</h3><ul><li><p>使用一个名为<code>forward</code>的新标准库设施来传递参数，它能够保持**&#x3D;&#x3D;原始实参的类型&#x3D;&#x3D;**。（如果是右值，让其保持右值，如果是左值，让其保持左值）</p></li><li><p>定义在头文件<code>utility</code>中。</p></li><li><p>与move不同<strong>必须通过显式模板实参</strong>来调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::forward&lt;Type&gt;(arg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="built_in">intermediary</span>(Type &amp;&amp;arg) &#123;</span><br><span class="line"><span class="built_in">finalFcn</span>(std::forward&lt;Type&gt;(arg));</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>std::forward&lt;Type&gt;返回的是右值引用</p><ul><li>如果实参是一个右值，则Type是一个普通（非引用）类型，forward&lt;Type&gt;将返回Type&amp;&amp;（<strong>右值引用</strong>）</li><li>如果实参是一个左值，则通过**&#x3D;&#x3D;引用折叠&#x3D;&#x3D;<strong>，Type本身是一个左值引用类型，返回类型是一个指向左值引用类型的</strong>右值引用**</li></ul></li></ul><ul><li>与std::move相同，对std::forward不适用using声明是一个好主意。</li></ul><h2 id="（62）在-operator-中处理“自我赋值“"><a href="#（62）在-operator-中处理“自我赋值“" class="headerlink" title="（62）在 operator&#x3D; 中处理“自我赋值“"></a>（62）在 operator&#x3D; 中处理“自我赋值“</h2><blockquote><p> 确定任何一个函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确</p></blockquote><ul><li><p>确保当对象自我赋值时operator&#x3D; 有良好的行为。其中技术包括</p><ul><li>比较”来源对象“和”目标对象“的地址</li><li>精心周到的语句顺序</li><li>copy and swap</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//比较”来源对象“和”目标对象“的地址</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> = &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//证同测试（identity test），如果是自我赋值就不做任何事</span></span><br><span class="line"><span class="keyword">delete</span> pb;</span><br><span class="line">pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//精心周到的语句顺序</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Bitmap* pOring = pb;<span class="comment">//记住原先的pb</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);<span class="comment">//令pb指向 *pb的一个复件（副本）</span></span><br><span class="line">    <span class="keyword">delete</span> pOring;<span class="comment">//删除原先的pb</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//copy and swap</span></span><br><span class="line"><span class="comment">//————1————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>;<span class="comment">//交换*this和rhs的数据</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp;rhs) &#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);<span class="comment">//temp离开作用域后自动释放了原来的pb</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//————2————</span></span><br><span class="line">Widget&amp; Widget::oprator=(Widget rhs) &#123;<span class="comment">//rhs是一份拷贝，相当于temp</span></span><br><span class="line"><span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="（63）C-的deque的底层实现"><a href="#（63）C-的deque的底层实现" class="headerlink" title="（63）C++的deque的底层实现"></a>（63）C++的deque的底层实现</h2><ul><li>分段存储，一段的内空间是连续的，每段又分布在不同的地方，map表里面记录指向段的指针</li><li>deque 容器的分段存储结构，提高了在序列两端添加或删除元素的效率</li><li>内部为了遍历，有4个指针<ul><li>cur：指向当前正在遍历的元素；</li><li>first：指向当前连续空间的首地址；</li><li>last：指向当前连续空间的末尾地址；</li><li>node：它是一个二级指针，用于指向 map 数组中存储的指向当前连续空间的指针。</li></ul></li><li>维护 start、finish 这 2 个 deque 迭代器<ul><li>start 迭代器记录着 map 数组中首个连续空间的信息，finish 迭代器记录着 map 数组中最后一个连续空间的信息。另外需要注意的是，和普通 deque 迭代器不同，start 迭代器中的 cur 指针指向的是连续空间中首个元素；而 finish 迭代器中的 cur 指针指向的是连续空间最后一个元素的下一个位置。</li></ul></li></ul><h2 id="（64）为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"><a href="#（64）为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？" class="headerlink" title="（64）为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"></a>（64）为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</h2><ul><li>从<strong>软件设计</strong>的角度看，<strong>栈代表了处理逻辑，而堆代表了数据</strong>。**这样分开，使得处理&#x3D;&#x3D;逻辑更为清晰&#x3D;&#x3D;**。<ul><li>分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</li></ul></li><li>堆与栈的分离，使得<strong>堆中的内容可以被多个栈&#x3D;&#x3D;共享&#x3D;&#x3D;<strong>（也可以理解为</strong>多个线程访问同一个对象</strong>），节省空间，不过要注意线程安全的问题。<ul><li>这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li></ul></li><li>因为栈<strong>在运行的时侯</strong>需要保存系统运行的上下文，进行地址段的划分，需要占用比较多空间，而栈的空间又是向上增长的，空间有限。而堆不同，堆中的对象是可以<strong>根据需要&#x3D;&#x3D;动态增长&#x3D;&#x3D;的</strong>，相应栈中只需记录堆中的一个地址即可</li></ul><img src="面经整理发布版.assets/v2-c9c793adc29afdb5c42bd2f5f685c5c3_1440w.webp" alt="img" style="zoom:50%;" /><h2 id="（65）指针引用-二级指针传递"><a href="#（65）指针引用-二级指针传递" class="headerlink" title="（65）指针引用 &amp;&amp; 二级指针传递"></a>（65）指针引用 &amp;&amp; 二级指针传递</h2><ul><li>找出其中的问题：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMemory</span><span class="params">( <span class="type">char</span> *p )</span> </span>&#123;</span><br><span class="line">    p = (<span class="type">char</span> *) <span class="built_in">malloc</span>( <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">GetMemory</span>( str );</span><br><span class="line">    <span class="built_in">strcpy</span>( str, <span class="string">&quot;hello world&quot;</span> );</span><br><span class="line">    <span class="built_in">printf</span>( str );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>第一是getMemory中malloc的内存没有被free掉，会有内存泄露的问题。 </li><li>第二，整个代码的目的是str指针分配内存，然后为其复制helloworld并输出，但是最后str的值仍为NULL，输出时会报错，因为getMemory函数并没有实现为str分配空间的功能，在getMemory中传入的是一级指针，只是把str的值传进去了，没有传入str的地址，在函数中malloc后就会把一个分配好的新地址赋值给p，此时p的值就不是str的值了，所以函数结束后str的值仍为NULL。<strong>要实现为str分配地址的功能，传入的应该是二级指针或是指针的引用</strong>，不能只传入一级指针</li></ul><h2 id="（66）将文件间的编译依存关系降到最低"><a href="#（66）将文件间的编译依存关系降到最低" class="headerlink" title="（66）将文件间的编译依存关系降到最低"></a>（66）将文件间的编译依存关系降到最低</h2><ul><li><p><strong>解耦</strong>——编译的时候有时候只需要一个声明而不必把定义编译进去</p></li><li><p>支持 “编译依存性最小化” 的一般构想是：<strong>相依于声明式</strong>，<strong>不要相依于定义式</strong>。基于此构想的两个手段是 Handle classes 和 Interface classes。</p></li><li><p>程序库头文件应该以 “完全且仅有声明式”（full and declaration-only forms）的形式存在。这种做法不论是否涉及 templates 都适用</p><ul><li><strong>Handles classes</strong>：将&#x3D;&#x3D;声明和定义分类编写&#x3D;&#x3D;，声明类和定义类有同名成员函数，声明类通过成员智能指针指向实现类，声明类的成员函数通过这个指针调用定义式中的函数</li><li><strong>Interface classes</strong>：父类中通过虚函数 “声明” ，子类继承父类重写虚函数提供 “定义”，通过 factory 函数返回一个指向子类的父类智能指针</li><li>将声明与定义分离，可以**&#x3D;&#x3D;将 “非真正必要之类型定义” 与 客户端之间的编译依存关系去除掉&#x3D;&#x3D;**</li></ul></li></ul><h2 id="（67）异常安全"><a href="#（67）异常安全" class="headerlink" title="（67）异常安全"></a>（67）异常安全</h2><ul><li>异常安全函数（Exception-safe functions）即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型<ul><li><strong>基本型</strong>：如果异常被抛出，程序内的任何事务仍然保持在有效的状态下（但是不能预料现实状态，<strong>程序可能处于任何状态</strong>——只要这个状态是合法的）</li><li><strong>强烈保证型</strong>：如果异常被抛出，程序状态不改变；如果函数成功，则完全成功，如果函数失败，程序会回复到 “调用函数之前” 的状态</li><li><strong>不抛掷（nothrow）保证</strong>：承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。作用于<strong>内置类型</strong>（例如 ints，指针等等）身上的所有操作都提供 nothrow 保证。这是异常安全码中一个<strong>必不可少的关键基础材料</strong><ul><li><strong>在函数名后面加 throw()</strong> 括号内为空</li></ul></li></ul></li><li>“强烈保证” 往往能够以 copy-and-swap 实现出来，但 “强烈保证” 并非对所有函数都可实现或具备现实意义</li><li>函数提供的 “异常安全保证” 通常最高只等于其所调用之各个函数的 “异常安全保证” 最低者</li></ul><h1 id="2-计网相关"><a href="#2-计网相关" class="headerlink" title="2. 计网相关"></a>2. 计网相关</h1><h2 id="（1）在浏览器中输入URL后执行的全部过程（如www-baidu-com）-over"><a href="#（1）在浏览器中输入URL后执行的全部过程（如www-baidu-com）-over" class="headerlink" title="（1）在浏览器中输入URL后执行的全部过程（如www.baidu.com）==over=="></a>（1）在浏览器中输入URL后执行的全部过程（如<a href="http://www.baidu.com)==over==/">www.baidu.com）==over==</a></h2><ul><li><p>首先浏览器会对URL来进行解析，生成&#x3D;&#x3D;请求报文&#x3D;&#x3D;</p></li><li><p>然后再通过&#x3D;&#x3D;域名解析DNS&#x3D;&#x3D;来获得目的地的IP地址</p><ul><li>迭代查询：先看本地浏览器缓存，然后是host文件，本地DNS服务器，根域名服务器，顶级、权限、本地</li></ul></li><li><p>然后进入运输层，封装TCP头部（如果http请求消息超过MSS，要进行分片，并标上序号）</p></li><li><p>然后到网络层封装IP首部（如果报文长度ip + tcp + 消息体 超过MTU：1500字节）</p></li><li><p>然后到数据链路层封装MAC地址（需要查看ARP缓存，没有就ARP广播查询）</p></li><li><p>最后通过网卡将数字信息转换为电信号（网卡驱动程序会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>）</p></li><li><p>中间通过交换机（<strong>二层网络设备</strong>，交换机根据MAC地址表查询有没有目标MAC地址，没找到就发送给除了源端口外的所有端口）</p></li><li><p>最后到网关（如果是发送给自己的，放入接收缓冲区，接收完后去掉MAC地址，根据MAC地址后的IP地址进行转发网络包），通过将条目的子网掩码和目标IP地址进行&amp;运算，找到最匹配的，然后从这个网关（下一跳路由器）转发</p></li><li><p>然后再通过ARP寻到下一跳路由器的MAC地址，然后通过交换机转发</p></li><li><p>最后如果在路由器中的匹配的网关为空，说明到达目标地址。</p></li><li><p><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</p></li><li><p><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</p></li></ul><h2 id="（2）HTTP"><a href="#（2）HTTP" class="headerlink" title="（2）HTTP"></a>（2）HTTP</h2><h3 id="（1）HTTP基本概念"><a href="#（1）HTTP基本概念" class="headerlink" title="（1）HTTP基本概念"></a>（1）HTTP基本概念</h3><h4 id="（1）能否详细解释「超文本传输协议」？"><a href="#（1）能否详细解释「超文本传输协议」？" class="headerlink" title="（1）能否详细解释「超文本传输协议」？"></a>（1）能否详细解释「超文本传输协议」？</h4><ul><li>HTTP 是一个在计算机世界里专门在<strong>「两点」</strong>之间<strong>「传输」</strong>文字、图片、音频、视频等<strong>「超文本」</strong>数据的<strong>「约定和规范」</strong>。</li></ul><h4 id="（2）那「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？"><a href="#（2）那「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？" class="headerlink" title="（2）那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？"></a>（2）那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？</h4><ul><li>这种说法是<strong>不正确</strong>的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用<strong>两点之间</strong>的描述会更准确</li></ul><h4 id="（3）http的状态码-403-201等等是什么意思"><a href="#（3）http的状态码-403-201等等是什么意思" class="headerlink" title="（3）http的状态码 403 201等等是什么意思"></a>（3）http的状态码 403 201等等是什么意思</h4><ul><li>记住5类就好</li></ul><blockquote><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul></blockquote><h4 id="（4）HTTP-常见字段有哪些？"><a href="#（4）HTTP-常见字段有哪些？" class="headerlink" title="（4）HTTP 常见字段有哪些？"></a>（4）HTTP 常见字段有哪些？</h4><ul><li><p><code>Host: www.A.com</code></p><ul><li>客户端发送请求时，用来指定服务器的域名。</li><li>有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</li></ul></li><li><p><code>Content-Length: 1000</code></p><ul><li><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong></li></ul></li><li><p><code>Connection: Keep-Alive</code></p><ul><li>开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</li></ul></li><li><p><strong>编码</strong></p><ul><li><p><code>Content-Type: text/html; Charset=utf-8</code></p><ul><li>上面的类型表明，发送的是网页，而且编码是UTF-8。</li></ul></li><li><p><code>Accept: */*</code></p><ul><li>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</li><li>上面代码中，客户端声明自己可以接受任何格式的数据。</li></ul></li></ul></li><li><p><strong>压缩</strong></p><ul><li><p><code>Content-Encoding: gzip</code></p><ul><li>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</li></ul></li><li><p><code>Accept-Encoding: gzip, deflate</code></p><ul><li>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</li></ul></li></ul></li></ul><h3 id="（2）GET-与-POST"><a href="#（2）GET-与-POST" class="headerlink" title="（2）GET 与 POST"></a>（2）GET 与 POST</h3><h4 id="（1）-http的请求方法有哪些？get和post的区别。"><a href="#（1）-http的请求方法有哪些？get和post的区别。" class="headerlink" title="（1） http的请求方法有哪些？get和post的区别。"></a>（1） http的请求方法有哪些？get和post的区别。</h4><ul><li>HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）</li></ul><p>get和post的区别：</p><ul><li><p>get 是安全和幂等的，是只读的操作，不会修改服务器的资源，多次请求结果相同，可以做缓存，也可以保存为书签。</p></li><li><p>post 是不安全也是不幂等的，它会修改服务器上的资源，多次请求会创建多个资源，浏览器一般不会缓存，不可以保存为书签。</p></li><li><p>位置</p><ul><li>get把请求附在 <code>url</code> 上，而post把参数附在 <code>http包</code>的包体中</li></ul></li><li><p>大小</p><ul><li>浏览器和服务器一般对get方法所提交的 url长度 有限制，一般是&#x3D;&#x3D;1k或者2k&#x3D;&#x3D;，而对post方法所传输的参数大小限制为&#x3D;&#x3D;80k到4M&#x3D;&#x3D;不等</li></ul></li><li><p>编码</p><ul><li>post可以传输&#x3D;&#x3D;<strong>二进制编码</strong>&#x3D;&#x3D;的信息，get的参数一般**&#x3D;&#x3D;只支持ASCII&#x3D;&#x3D;**</li></ul></li><li><p>了解</p></li><li><p><strong>GET 的语义是从服务器获取指定的资源</strong></p><ul><li>用URL传输数据</li></ul></li><li><p><strong>POST 的语义是根据&#x3D;&#x3D;请求负荷&#x3D;&#x3D;（报文body）对指定的资源做出处理</strong></p><ul><li>比如在论坛进行留言浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。</li><li>POST用body传输数据</li></ul></li></ul><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/12-Get%E8%AF%B7%E6%B1%82.png" alt="GET 请求"></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/13-Post%E8%AF%B7%E6%B1%82.png" alt="POST 请求"></p><h4 id="（2）GET-和-POST-方法都是安全和幂等的吗？"><a href="#（2）GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="（2）GET 和 POST 方法都是安全和幂等的吗？"></a>（2）GET 和 POST 方法都是安全和幂等的吗？</h4><ul><li><p>先说明下安全和幂等的概念：</p><ul><li>在 HTTP 协议里，所谓的<strong>「安全」</strong>是指请求方法不会<strong>「破坏」</strong>服务器上的资源。</li><li>所谓的「幂等」，意思是<strong>多次执行相同</strong>的操作，结果都是<strong>「相同」</strong>的。</li></ul></li><li><p>如果从 RFC 规范定义的语义来看：</p><ul><li><strong>GET 方法就是安全且幂等的</strong>，因为它是&#x3D;&#x3D;「只读」&#x3D;&#x3D;操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li><li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li></ul></li></ul><h3 id="（3）HTTP-缓存技术"><a href="#（3）HTTP-缓存技术" class="headerlink" title="（3）HTTP 缓存技术"></a>（3）HTTP 缓存技术</h3><h4 id="（1）HTTP-缓存有哪些实现方式？"><a href="#（1）HTTP-缓存有哪些实现方式？" class="headerlink" title="（1）HTTP 缓存有哪些实现方式？"></a>（1）HTTP 缓存有哪些实现方式？</h4><ul><li><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p></li><li><p>&#x3D;&#x3D;强制缓存&#x3D;&#x3D;指的是只要浏览器判断缓存&#x3D;&#x3D;没有过期&#x3D;&#x3D;（有一个服务器过期时间<code>Cache-Control</code>），则直接使用浏览器的本地缓存</p></li><li><p>当时间过期后，通过&#x3D;&#x3D;协商缓存&#x3D;&#x3D;：就是在与服务端协商之后，通过协商结果来判断&#x3D;&#x3D;是否使用本地缓存&#x3D;&#x3D;，然后更新过期时间<code>Cache-Control</code></p><ul><li>先<code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段</li><li>后<code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段<ul><li><code>Etag</code> 的优先级更高</li><li><code>Last-Modified</code> 容易被修改</li><li>时间粒度，秒，纳秒</li><li>有些服务器保存时间不准确</li></ul></li></ul></li><li><p>了解</p><ul><li>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP&#x2F;1.1 的性能肯定肉眼可见的提升。</li><li>所以，避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。</li></ul></li></ul><h4 id="（2）什么是强制缓存"><a href="#（2）什么是强制缓存" class="headerlink" title="（2）什么是强制缓存"></a>（2）什么是强制缓存</h4><ul><li><p>强制缓存指的是只要浏览器判断缓存&#x3D;&#x3D;没有过期&#x3D;&#x3D;（有一个服务器过期时间<code>Cache-Control</code>），则直接使用浏览器的本地缓存</p></li><li><p>当时间过期后，通过&#x3D;&#x3D;协商缓存&#x3D;&#x3D;：就是在与服务端协商之后，通过协商结果来判断&#x3D;&#x3D;是否使用本地缓存&#x3D;&#x3D;，然后更新过期时间<code>Cache-Control</code></p><ul><li>先<code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段</li><li>后<code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段<ul><li><code>Etag</code> 的优先级更高</li><li><code>Last-Modified</code> 容易被修改</li><li>时间粒度，秒，纳秒</li><li>有些服务器保存时间不准确</li></ul></li></ul></li><li><p>了解</p></li></ul><p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 &#x3D;&#x3D;from disk cache&#x3D;&#x3D;，就是使用了强制缓存。</p><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/1cb6bc37597e4af8adfef412bfc57a42.png" alt="img"></p><p>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><code>Cache-Control</code>， 是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p><p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中&#x3D;&#x3D;设置了过期时间大小&#x3D;&#x3D;；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul><h4 id="（3）什么是协商缓存？"><a href="#（3）什么是协商缓存？" class="headerlink" title="（3）什么是协商缓存？"></a>（3）什么是协商缓存？</h4><ul><li><strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</li><li><strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</li></ul><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E7%BC%93%E5%AD%98etag.png" alt="img"></p><p>上图就是一个协商缓存的过程，所以<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><p>协商缓存可以基于两种头部来实现。</p><p>&#x3D;&#x3D;第一种&#x3D;&#x3D;：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p><ul><li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li></ul><p>&#x3D;&#x3D;第二种&#x3D;&#x3D;：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p><p>如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，<strong>这时 Etag 的优先级更高</strong>，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。</p><p><strong>为什么 ETag 的优先级更高？</strong>这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p><ol><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li><li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li><li>有些服务器不能精确获取文件的最后修改时间。</li></ol><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><p>下图是强制缓存和协商缓存的工作流程：</p><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/http%E7%BC%93%E5%AD%98.png" alt="img"></p><p>当使用 ETag 字段实现的协商缓存的过程：</p><ul><li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p></li><li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p><ul><li>如果没有过期，则直接使用本地缓存；</li><li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li></ul></li><li><p>服务器再次收到请求后，</p><p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</p><p>：</p><ul><li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li><li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li></ul></li><li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p></li></ul><h3 id="（4）HTTP-特性"><a href="#（4）HTTP-特性" class="headerlink" title="（4）HTTP 特性"></a>（4）HTTP 特性</h3><h4 id="（1）HTTP-1-1-的优点有哪些？"><a href="#（1）HTTP-1-1-的优点有哪些？" class="headerlink" title="（1）HTTP&#x2F;1.1 的优点有哪些？"></a>（1）HTTP&#x2F;1.1 的优点有哪些？</h4><ul><li>简单<ul><li>格式简单，header + body ，头部信息简单 key-value</li></ul></li><li>灵活和易于扩展<ul><li>请求方法、URI&#x2F;URL、状态码、头字段都允许<strong>自定义和扩充</strong>。</li><li>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>，比如：<ul><li>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</li><li>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用了 UDP 协议。</li></ul></li></ul></li><li>应用广泛和跨平台</li></ul><h4 id="（2）HTTP-1-1-的缺点有哪些？"><a href="#（2）HTTP-1-1-的缺点有哪些？" class="headerlink" title="（2）HTTP&#x2F;1.1 的缺点有哪些？"></a>（2）HTTP&#x2F;1.1 的缺点有哪些？</h4><ul><li><p>&#x3D;&#x3D;不安全&#x3D;&#x3D;</p><ul><li>不验证通信方的身份，&#x3D;&#x3D;冒充&#x3D;&#x3D;<ul><li>访问到假淘宝</li></ul></li><li>通信使用明文（不加密）&#x3D;&#x3D;窃听&#x3D;&#x3D;<ul><li>信息泄漏</li></ul></li><li>无法证明报文的完整性，&#x3D;&#x3D;篡改&#x3D;&#x3D;<ul><li>植入广告</li></ul></li></ul></li><li><p>无状态双刃剑</p><ul><li>无状态的<strong>好处</strong>，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</li><li>无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在完成&#x3D;&#x3D;有关联性的操作&#x3D;&#x3D;时会非常麻烦。<ul><li>解决方案使用 cookie，可以用于标识用户</li></ul></li></ul></li><li><p>明文传输双刃剑</p><ul><li>明文意味着在传输过程中的信息，是可方便阅读的，例如Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。</li><li>信息容易泄漏</li></ul></li></ul><h4 id="（3）HTTP-1-1-的性能如何？"><a href="#（3）HTTP-1-1-的性能如何？" class="headerlink" title="（3）HTTP&#x2F;1.1 的性能如何？"></a>（3）HTTP&#x2F;1.1 的性能如何？</h4><ul><li>长连接</li><li>管道网络传输：默认不开启<ul><li>客户端发送请求不会被阻塞</li></ul></li><li>但服务端需要顺序响应，如果一个请求没有处理完毕，会阻塞接下来收到的请求</li></ul><h3 id="（5）HTTP-与-HTTPS"><a href="#（5）HTTP-与-HTTPS" class="headerlink" title="（5）HTTP 与 HTTPS"></a>（5）HTTP 与 HTTPS</h3><h4 id="（1）HTTP-与-HTTPS-有哪些区别？"><a href="#（1）HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="（1）HTTP 与 HTTPS 有哪些区别？"></a>（1）HTTP 与 HTTPS 有哪些区别？</h4><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 &#x3D;&#x3D;SSL&#x2F;TLS 安全协议&#x3D;&#x3D;，使得报文能够加密传输。</li><li>HTTP &#x3D;&#x3D;连接建立&#x3D;&#x3D;相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的&#x3D;&#x3D;默认端口&#x3D;&#x3D;不一样，HTTP 默认端口号是 <strong>80</strong>，HTTPS 默认端口号是 <strong>443</strong>。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请&#x3D;&#x3D;数字证书&#x3D;&#x3D;，来保证服务器的身份是可信的。</li></ul><h4 id="（2）HTTPS-解决了-HTTP-的哪些问题？"><a href="#（2）HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="（2）HTTPS 解决了 HTTP 的哪些问题？"></a>（2）HTTPS 解决了 HTTP 的哪些问题？</h4><ul><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了&#x3D;&#x3D;冒充&#x3D;&#x3D;的风险。</li><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了&#x3D;&#x3D;窃听&#x3D;&#x3D;的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的指纹，指纹用于校验数据的完整性，解决了&#x3D;&#x3D;篡改&#x3D;&#x3D;的风险。</li></ul><ul><li><strong>混合加密</strong></li></ul><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/image-20230609113842344.png" alt="image-20230609113842344"></p><ul><li>公钥是公开的，需要向CA机构认证，私钥是私有的，不被公开</li><li>单向散列函数，逆向计算几乎不可能</li><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<ul><li>使用非对称加密加密了传输内容：<ul><li>在上面的基础上，<strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul></li><li>一般我们不会用非对称加密来&#x3D;&#x3D;加密实际的传输内容&#x3D;&#x3D;，因为非对称加密的计算比较耗费性能的。</li></ul></li></ul><img src="面经整理发布版.assets/image-20230609115338980.png" alt="image-20230609115338980" style="zoom: 25%;" /><h4 id="（3）HTTPS-SSL-TSL传输层是如何建立连接的？其间交互了什么"><a href="#（3）HTTPS-SSL-TSL传输层是如何建立连接的？其间交互了什么" class="headerlink" title="（3）HTTPS SSL\TSL传输层是如何建立连接的？其间交互了什么"></a>（3）HTTPS SSL\TSL传输层是如何建立连接的？其间交互了什么</h4><ul><li>客户端向服务器索要并验证服务器的公钥。<ul><li>客户端向服务器发送TSL协议版本，密码套件列表，客户端生成的随机数</li><li>服务端先确认TSL协议版本和密码套件，版本支持的话会返回服务器生成的随机数和数字证书</li></ul></li><li>双方协商生产「会话秘钥」。<ul><li>客户端用服务器给的数字证书里面公钥加密一个随机数 pre-master，以及对之前的所有信息做一个摘要（单向散列函数），发送给服务器进行检验</li><li>最后双方都有 服务器的随机数，客户端的随机数和pre-master，用协商好的加密算法对三个随机数进行加密得到会话密钥</li></ul></li><li>后续双方采用「会话秘钥」进行加密通信。</li></ul><h4 id="（4）-HTTPS-的应用数据是如何保证完整性的？"><a href="#（4）-HTTPS-的应用数据是如何保证完整性的？" class="headerlink" title="（4） HTTPS 的应用数据是如何保证完整性的？"></a>（4） HTTPS 的应用数据是如何保证完整性的？</h4><img src="面经整理发布版.assets/记录协议.png" alt="img" style="zoom:25%;" /><p>具体过程如下：</p><ul><li>首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</li><li>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li><li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li><li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ul><h4 id="（5）HTTPS-一定安全可靠吗？"><a href="#（5）HTTPS-一定安全可靠吗？" class="headerlink" title="（5）HTTPS 一定安全可靠吗？"></a>（5）HTTPS 一定安全可靠吗？</h4><ul><li><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</li></ul><h4 id="（6）为什么抓包工具能截取-HTTPS-数据？"><a href="#（6）为什么抓包工具能截取-HTTPS-数据？" class="headerlink" title="（6）为什么抓包工具能截取 HTTPS 数据？"></a>（6）为什么抓包工具能截取 HTTPS 数据？</h4><ul><li><p>中间人要拿到私钥只能通过如下方式：</p><ul><li>去网站服务端拿到私钥；</li><li>去CA处拿域名签发私钥；</li><li>自己签发证书，切要被浏览器信任；</li></ul></li><li><p>不用解释，抓包工具只能使用第三种方式取得中间人的身份。</p></li><li><p>使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装&#x3D;&#x3D;Fiddler 的根证书&#x3D;&#x3D;，这里实际上起认证中心（CA）的作用。</p></li><li><p>抓包工具能够抓包的关键是&#x3D;&#x3D;客户端会往系统受信任的根证书列表中导入抓包工具生成的证书&#x3D;&#x3D;，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。</p></li></ul><h4 id="（7）如何避免被中间人抓取数据？"><a href="#（7）如何避免被中间人抓取数据？" class="headerlink" title="（7）如何避免被中间人抓取数据？"></a>（7）如何避免被中间人抓取数据？</h4><ul><li>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。</li><li>还可以通过 <strong>HTTPS 双向认证</strong>来避免这种问题<ul><li>用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份</li></ul></li></ul><h3 id="（6）HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#（6）HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="（6）HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>（6）HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h3><h4 id="（1）HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#（1）HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="（1）HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>（1）HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h4><ul><li><p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：</p><ul><li><p>使用**&#x3D;&#x3D;长连接&#x3D;&#x3D;**改善了短连接的性能消耗</p></li><li><p><strong>节约时间</strong>：支持**&#x3D;&#x3D;管道传输&#x3D;&#x3D;**，发送（客户）端不用阻塞发送，但需要接收（服务）端阻塞等待</p></li></ul></li><li><p>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p><ul><li>&#x3D;&#x3D;<strong>头部</strong>&#x3D;&#x3D;<strong>未压缩</strong>，如果头部太长导致发送数据时间变长</li><li>头部<strong>冗余</strong>，有多个相同头部数据包出现</li><li>**队头&#x3D;&#x3D;阻塞&#x3D;&#x3D;**：服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据</li><li>请求只能从客户端开始，服务器只能**&#x3D;&#x3D;被动响应&#x3D;&#x3D;**。</li><li>没有请求优先级控制；</li></ul></li></ul><h4 id="（2）HTTP-2-做了什么优化？"><a href="#（2）HTTP-2-做了什么优化？" class="headerlink" title="（2）HTTP&#x2F;2 做了什么优化？"></a>（2）HTTP&#x2F;2 做了什么优化？</h4><img src="面经整理发布版.assets/25-HTTP2.jpeg" alt="HTT/1 ~ HTTP/2" style="zoom:50%;" /><ul><li><p>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p><ul><li><p>头部压缩</p><ul><li><p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p></li></ul></li><li><p>二进制帧</p><ul><li><p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.png" alt="HTTP/1 与 HTTP/2 "></p></li></ul></li><li><p>并发传输</p></li><li><p>服务器主动推送资源</p></li></ul></li></ul><h3 id="（）-http协议与TCP的区别与联系"><a href="#（）-http协议与TCP的区别与联系" class="headerlink" title="（） http协议与TCP的区别与联系"></a>（） http协议与TCP的区别与联系</h3><p>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</p><p>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。<br>建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。</p><h3 id="（）-http-1-0和http-1-1的区别"><a href="#（）-http-1-0和http-1-1的区别" class="headerlink" title="（） http&#x2F;1.0和http&#x2F;1.1的区别"></a>（） http&#x2F;1.0和http&#x2F;1.1的区别</h3><ul><li>HTTP 协议老的标准是 HTTP&#x2F;1.0 ，目前最通用的标准是 HTTP&#x2F;1.1 。</li><li>HTTP1.0 只保持&#x3D;&#x3D;短连接&#x3D;&#x3D;，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http&#x2F;1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive</li><li>HTTP 1.1 支持&#x3D;&#x3D;长连接&#x3D;&#x3D;，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</li></ul><h2 id="（2）-建立TCP服务器的各个系统调用-over"><a href="#（2）-建立TCP服务器的各个系统调用-over" class="headerlink" title="（2） 建立TCP服务器的各个系统调用&#x3D;&#x3D;over&#x3D;&#x3D;"></a>（2） 建立TCP服务器的各个系统调用&#x3D;&#x3D;over&#x3D;&#x3D;</h2><p>建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。<br>详见：<a href="https://blog.csdn.net/qq_37964547/article/details/81429627">建立TCP 服务器的系统调用</a></p><h2 id="（3）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"><a href="#（3）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？" class="headerlink" title="（3） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"></a>（3） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">socket()    创建套接字   </span><br><span class="line">bind()      绑定本机端口    </span><br><span class="line">connect()   建立连接     （TCP三次握手在调用这个函数时进行）</span><br><span class="line">listen()    监听端口</span><br><span class="line">accept()    接受连接</span><br><span class="line">recv(), read(), recvfrom()  数据接收</span><br><span class="line">send(), write(), sendto()   数据发送</span><br><span class="line">close(), shutdown() 关闭套接字</span><br></pre></td></tr></table></figure><p>使用close()时，只有当套接字的<strong>引用计数为0的时候才会终止连接</strong>，而用**shutdown()**就可以直接关闭连接</p><p>详见：<a href="https://blog.csdn.net/junjun150013652/article/details/37994907">网络编程Socket之TCP之close&#x2F;shutdown详解</a></p><p>TCP连接与断开详解： <a href="https://www.cnblogs.com/felixzh/p/8359066.html">https://www.cnblogs.com/felixzh/p/8359066.html</a></p><h2 id="（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP"><a href="#（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP" class="headerlink" title="（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP"></a>（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP</h2><ul><li><p>RIP“路由信息协议(Route Information Protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。RIP是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。</p></li><li><p>OSPF：详见：<a href="https://zhuanlan.zhihu.com/p/41341540">https://zhuanlan.zhihu.com/p/41341540</a></p></li></ul><h2 id="（4）-UDP如何实现可靠传输"><a href="#（4）-UDP如何实现可靠传输" class="headerlink" title="（4） UDP如何实现可靠传输"></a>（4） UDP如何实现可靠传输</h2><p>因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，<strong>只能从应用层实现</strong>。需要实现seq&#x2F;ack机制，重传机制和窗口确认机制。</p><p>就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</p><p>作者：姚冬<br>链接：<a href="https://www.zhihu.com/question/283995548/answer/661809748">https://www.zhihu.com/question/283995548/answer/661809748</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="（5）-TCP和UDP的区别"><a href="#（5）-TCP和UDP的区别" class="headerlink" title="（5） TCP和UDP的区别"></a>（5） TCP和UDP的区别</h2><ul><li>TCP是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ACK对收发的数据进行正确性检验。而UDP是无连接的协议，不管对方有没有收到或者收到的数据是否正确。</li><li>TCP提供<strong>流量控制</strong>和<strong>拥塞控制</strong>，而UDP没有。</li><li>TCP对系统资源的要求高于UDP，所以速度也比UDP慢。</li><li>TCP数据包是没有边界的，<strong>会出现粘包的问题</strong>，UDP包是独立的，不会出现粘包问题。</li><li>所以在应用方面，如果强调数据的完整性和正确性用TCP，当要求性能和速度的时候，使用UDP更加合适。</li></ul><p>注：单凭TCP是不能保证完整性的，要是有黑客伪造TCP包，是无法识别的。</p><h2 id="（6）-TCP和UDP相关的协议与端口号"><a href="#（6）-TCP和UDP相关的协议与端口号" class="headerlink" title="（6） TCP和UDP相关的协议与端口号"></a>（6） TCP和UDP相关的协议与端口号</h2><p>TCP族的协议有HTTP，HTTPS，SMTP，TelNet，FTP等，UDP族的协议有DNS，DHCP等等。<br>详见：<a href="https://blog.csdn.net/qq_22080999/article/details/81105051">https://blog.csdn.net/qq_22080999/article/details/81105051</a></p><h2 id="（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）"><a href="#（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）" class="headerlink" title="（7） TCP（UDP，IP）等首部的认识（http请求报文构成）"></a>（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</h2><p>TCP的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等</p><p>UDP的头部则包括：源端口，目的端口，长度，校验和。</p><p>IP数据包的头部包括：源IP地址，目的IP地址，协议，校验和，总长度等等</p><p>详见：<a href="https://blog.csdn.net/zhangliangzi/article/details/52554439">https://blog.csdn.net/zhangliangzi/article/details/52554439</a></p><h2 id="（8）-网页解析的过程与实现方法"><a href="#（8）-网页解析的过程与实现方法" class="headerlink" title="（8） 网页解析的过程与实现方法"></a>（8） 网页解析的过程与实现方法</h2><p>这里仅展示浏览器解析服务器响应的过程，URL解析和交互的完整过程在(9)</p><ul><li>首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成。</li><li>然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。</li><li>不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。</li><li>然后是css解析，将css文件解析为样式表对象来渲染DOM树。</li></ul><h2 id="（10）-网络层分片的原因与具体实现"><a href="#（10）-网络层分片的原因与具体实现" class="headerlink" title="（10） 网络层分片的原因与具体实现"></a>（10） 网络层分片的原因与具体实现</h2><p>因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。</p><p>IP分片和完整IP报文差不多拥有相同的IP头，16位ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对IP数据进行重新组织。<br>详见：<a href="https://blog.csdn.net/gettogetto/article/details/72851734">https://blog.csdn.net/gettogetto/article/details/72851734</a></p><h2 id="（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"><a href="#（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）" class="headerlink" title="（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"></a>（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</h2><ul><li>三次握手</li></ul><p>第一次握手：首先client给server发送连接请求报文，在这个报文中，包含了SYN&#x3D;1，client_seq&#x3D;任意值i，发送之后处于SYN-SENT状态，这是第一次握手</p><p>第二次握手：server端接收到了这个请求，并分配资源，同时给client返回一个ACK报文，这个报文中呢包含了这些字段，标志位SYN和ACK都为1，而小ack为i+1，此时位于SYN-RCVD状态，这是第二次握手</p><p>第三次握手：client收到server发来的ACK信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server回一个ACK报文，报文中同样包含了ACK&#x3D;1这样的消息，同时呢，还包括了client_ack&#x3D;k+1这样的字段，这样呢三次握手之后，连接就建立了，client进入established（已建立连接）状态<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手.png"></p><ul><li>四次挥手断开连接：</li></ul><p>TCP断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动<br>第一次挥手：当client没有数据要发送给server了，他会给server发送一个FIN报文，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后client进入FIN_WAIT_1的第一阶段</p><p>第二次挥手：当server收到client发来的FIN报文后，告诉client：“我收到你的FIN消息了，但是你等我发完的”此时给client返回一个ACK信息，并且呢ack&#x3D;seq+1，这是第二次挥手，挥手之后呢server进入CLOSE_WAIT阶段，而client收到之后处于FIN_WAIT_2第二阶段</p><p>第三次挥手：当server发完所有数据时，他会给client发送一个FIN报文，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变成LAST_ACK状态，等着client最后的ACK信息，这是第三次挥手</p><p>第四次挥手：当client收到这个FIN报文时，他会对这个消息进行确认，即给server发ACK信息，但是它不相信网络，怕server收不到信息，它会进入TIME_WAIT状态，万一server没收到ACK消息它可以可以重传，而当server收到这个ACK信息后，就正式关闭了tcp连接，处于CLOSED状态，而client等待了2MSL这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样tcp连接就断开了<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="fig/四次挥手.png"></p><h2 id="（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态"><a href="#（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态" class="headerlink" title="（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态"></a>（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</h2><p>见上</p><h2 id="（13）-为什么使用三次握手，两次握手可不可以？"><a href="#（13）-为什么使用三次握手，两次握手可不可以？" class="headerlink" title="（13） 为什么使用三次握手，两次握手可不可以？"></a>（13） 为什么使用三次握手，两次握手可不可以？</h2><p>如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。</p><p>举两个例子，第一种是黑客会伪造大量SYN请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫SYN洪泛攻击。第二种是服务器返回给客户端的ACK数据包可能会在传输的过程中丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。</p><h2 id="（14）-TIME-WAIT的意义（为什么要等于2MSL）"><a href="#（14）-TIME-WAIT的意义（为什么要等于2MSL）" class="headerlink" title="（14） TIME_WAIT的意义（为什么要等于2MSL）"></a>（14） TIME_WAIT的意义（为什么要等于2MSL）</h2><p>TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。如果客户端发送的ACK发生丢失，服务器会再次发送FIN报文给客户端，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h2 id="（15）-超时重传机制（不太高频）"><a href="#（15）-超时重传机制（不太高频）" class="headerlink" title="（15） 超时重传机制（不太高频）"></a>（15） 超时重传机制（不太高频）</h2><h2 id="（16）-TCP怎么保证可靠性？"><a href="#（16）-TCP怎么保证可靠性？" class="headerlink" title="（16） TCP怎么保证可靠性？"></a>（16） TCP怎么保证可靠性？</h2><p><strong>（校序重流拥）</strong></p><ul><li><p>校验和<br>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p></li><li><p>确认应答+序列号<br>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p></li><li><p>超时重传<br>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p></li><li><p>流量控制<br>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>接收方有即时窗口（滑动窗口），随ACK报文发送</p></li><li><p>拥塞控制<br>当网络拥塞时，减少数据的发送。<br>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</p></li></ul><p>慢启动、拥塞避免、快速重传、快速恢复 </p><h2 id="（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"><a href="#（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？" class="headerlink" title="（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"></a>（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</h2><p>所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用TCP报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。</p><p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。</p><p>解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。</p><h2 id="（18）-tcp滑动窗口协议"><a href="#（18）-tcp滑动窗口协议" class="headerlink" title="（18） tcp滑动窗口协议"></a>（18） tcp滑动窗口协议</h2><p>详见 <a href="https://blog.csdn.net/wdscq1234/article/details/52444277">TCP-IP详解：滑动窗口SlidingWindow</a>和<a href="https://www.cnblogs.com/alifpga/p/7675850.html">TCP滑动窗口</a></p><p>TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。</p><p>接收方会在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。</p><h2 id="（19）-拥塞控制和流量控制的区别"><a href="#（19）-拥塞控制和流量控制的区别" class="headerlink" title="（19） 拥塞控制和流量控制的区别"></a>（19） 拥塞控制和流量控制的区别</h2><p>拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。</p><h2 id="（20）-TCP拥塞控制，算法名字？（极其重要）"><a href="#（20）-TCP拥塞控制，算法名字？（极其重要）" class="headerlink" title="（20） TCP拥塞控制，算法名字？（极其重要）"></a>（20） TCP拥塞控制，算法名字？（极其重要）</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="拥塞控制"><br>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制自然也是控制发送者的流量，拥塞控制有四种算法，<strong>慢启动、拥塞避免，快速重传和快速恢复</strong></p><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口和接受窗口的较小值。</p><p>（1）<strong>慢启动</strong>。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16<br>*为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd &gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法</p><p>（2）<strong>拥塞避免</strong>。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p><p>（3）<strong>快速重传</strong>。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1）</p><p>（4）<strong>快速恢复</strong>。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd&#x3D;1，进入慢启动阶段</p><h2 id="（22）-TCP三次握手时的第一次的seq序号是怎样产生的"><a href="#（22）-TCP三次握手时的第一次的seq序号是怎样产生的" class="headerlink" title="（22） TCP三次握手时的第一次的seq序号是怎样产生的"></a>（22） TCP三次握手时的第一次的seq序号是怎样产生的</h2><p>第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p><p>seq &#x3D; C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。</p><h2 id="（23）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"><a href="#（23）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？" class="headerlink" title="（23） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"></a>（23） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</h2><p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16&#x3D;65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p><p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p><h2 id="（24）-对称密码和非对称密码体系"><a href="#（24）-对称密码和非对称密码体系" class="headerlink" title="（24） 对称密码和非对称密码体系"></a>（24） 对称密码和非对称密码体系</h2><p><a href="https://blog.csdn.net/qq_29689487/article/details/81634057">https://blog.csdn.net/qq_29689487/article/details/81634057</a></p><ul><li>对称加密：加密和解密使用的密钥是同一个<ul><li>优点：计算量小，算法速度快，加密效率高  缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲</li><li>常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES</li></ul></li><li>非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密<ul><li>优点：安全，不怕泄漏  缺点：速度慢</li><li>常用算法：RSA，ECC，DSA</li></ul></li></ul><h2 id="（25）-数字证书的了解（高频）"><a href="#（25）-数字证书的了解（高频）" class="headerlink" title="（25） 数字证书的了解（高频）"></a>（25） 数字证书的了解（高频）</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.jpg" alt="fig/数字证书.jpg"></p><p>权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。</p><p>网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。</p><h2 id="（26）-服务器出现大量close-wait的连接的原因以及解决方法"><a href="#（26）-服务器出现大量close-wait的连接的原因以及解决方法" class="headerlink" title="（26） 服务器出现大量close_wait的连接的原因以及解决方法"></a>（26） 服务器出现大量close_wait的连接的原因以及解决方法</h2><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p><ul><li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li><li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li></ul><p>处理方法：</p><ul><li>停止应用程序</li><li>修改程序里的bug</li></ul><h2 id="（27）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"><a href="#（27）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）" class="headerlink" title="（27） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"></a>（27） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</h2><ul><li><p>消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等</p></li><li><p>MD5算法介绍：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）</p></li></ul><ol><li>MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。</li><li>对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。</li><li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。</li><li>遍历所有分组后得到的四个变量即为结果。</li></ol><p>详见：<a href="https://blog.csdn.net/weixin_39640298/article/details/84555814">https://blog.csdn.net/weixin_39640298/article/details/84555814</a></p><ul><li><p>为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。</p></li><li><p>加强安全性：加盐（加随机数）</p></li></ul><h2 id="（28）-单条记录高并发访问的优化"><a href="#（28）-单条记录高并发访问的优化" class="headerlink" title="（28） 单条记录高并发访问的优化"></a>（28） 单条记录高并发访问的优化</h2><p>服务器端：</p><ul><li>使用缓存，如redis等</li><li>使用分布式架构进行处理</li><li>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回</li><li>将静态资源尽可能在客户端进行缓存</li><li>采用ngnix进行负载均衡 （nginx读作恩静埃克斯 &#x3D; Engine X）</li></ul><p>数据库端：</p><ul><li>数据库采用主从赋值，读写分离措施</li><li>建立适当的索引</li><li>分库分表</li></ul><h2 id="（29）-介绍一下ping的过程，分别用到了哪些协议"><a href="#（29）-介绍一下ping的过程，分别用到了哪些协议" class="headerlink" title="（29） 介绍一下ping的过程，分别用到了哪些协议"></a>（29） 介绍一下ping的过程，分别用到了哪些协议</h2><p>详见：<a href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html">Ping原理与ICMP协议</a></p><p>ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议</p><ul><li>首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。</li><li>然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li><li>然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li></ul><p>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。</p><h2 id="（30）-TCP-IP的粘包与避免介绍一下"><a href="#（30）-TCP-IP的粘包与避免介绍一下" class="headerlink" title="（30） TCP&#x2F;IP的粘包与避免介绍一下"></a>（30） TCP&#x2F;IP的粘包与避免介绍一下</h2><p>因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。</p><p>导致TCP粘包的原因有三方面：</p><ul><li>发送端等待缓冲区满才进行发送，造成粘包</li><li>接收方来不及接收缓冲区内的数据，造成粘包</li><li>由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</li></ul><p>避免粘包的措施：</p><ul><li>通过编程，强制使TCP发生数据传送，不必等到缓冲区满</li><li>优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等</li><li>设置固定长度的报文或者设置报文头部指示报文的长度。</li></ul><h2 id="（31）-说一下TCP的封包和拆包"><a href="#（31）-说一下TCP的封包和拆包" class="headerlink" title="（31） 说一下TCP的封包和拆包"></a>（31） 说一下TCP的封包和拆包</h2><p>因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p><ul><li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li><li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</li></ul><h2 id="（32）-一个ip配置多个域名，靠什么识别？"><a href="#（32）-一个ip配置多个域名，靠什么识别？" class="headerlink" title="（32） 一个ip配置多个域名，靠什么识别？"></a>（32） 一个ip配置多个域名，靠什么识别？</h2><ul><li>靠host主机名区分</li><li>靠端口号区分</li></ul><h2 id="（33）-服务器攻击（DDos攻击）"><a href="#（33）-服务器攻击（DDos攻击）" class="headerlink" title="（33） 服务器攻击（DDos攻击）"></a>（33） 服务器攻击（DDos攻击）</h2><h2 id="（34）DNS的工作过程和原理"><a href="#（34）DNS的工作过程和原理" class="headerlink" title="（34）DNS的工作过程和原理"></a>（34）DNS的工作过程和原理</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/DNS%E6%9F%A5%E8%AF%A2%E5%9B%BE%E8%A7%A3.png"><br>DNS解析有两种方式：递归查询和迭代查询</p><ul><li>递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。</li><li>迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果</li></ul><h2 id="（35）OSA七层协议和五层协议，TCP-IP四层网络模型，分别有哪些-over"><a href="#（35）OSA七层协议和五层协议，TCP-IP四层网络模型，分别有哪些-over" class="headerlink" title="（35）OSA七层协议和五层协议，TCP&#x2F;IP四层网络模型，分别有哪些&#x3D;&#x3D;over&#x3D;&#x3D;"></a>（35）OSA七层协议和五层协议，TCP&#x2F;IP四层网络模型，分别有哪些&#x3D;&#x3D;over&#x3D;&#x3D;</h2><h3 id="简要概括"><a href="#简要概括" class="headerlink" title="简要概括"></a>简要概括</h3><ul><li>应用层：各种应用软件，包括 Web 应用。</li><li>表示层：数据格式标识，基本压缩加密功能。</li><li>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</li><li>传输层：端到端传输数据的基本功能；如 TCP、UDP。</li><li>网络层：定义IP编址，定义<strong>路由功能</strong>；如不同设备的数据转发。</li><li>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</li><li>物理层：底层数据传输，如网线；网卡标准。</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>在四层，既传输层数据被称作<strong>tcp报文段或udp用户数据报</strong>（Segments）；</li><li>三层网络层数据被称做<strong>包</strong>（Packages）；</li><li>二层数据链路层时数据被称为<strong>帧</strong>（Frames）；</li><li>一层物理层时数据被称为<strong>比特流</strong>（Bits）。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>网络七层模型是&#x3D;&#x3D;一个标准，而非实现&#x3D;&#x3D;。</li><li>网络四层模型是一个&#x3D;&#x3D;实现的应用&#x3D;&#x3D;模型。</li><li>网络四层模型由七层模型简化合并而来。</li></ul><p>五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。</p><p>TCP&#x2F;IP 四层模型：应用层，传输层，网络层，网络接口层</p><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82.png" alt="(fig/网络协议层.png"></p><h2 id="（36）IP寻址和MAC寻址有什么不同，怎么实现的"><a href="#（36）IP寻址和MAC寻址有什么不同，怎么实现的" class="headerlink" title="（36）IP寻址和MAC寻址有什么不同，怎么实现的"></a>（36）IP寻址和MAC寻址有什么不同，怎么实现的</h2><h1 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3. 操作系统"></a>3. 操作系统</h1><h2 id="（1）-进程与线程的区别和联系（重点）"><a href="#（1）-进程与线程的区别和联系（重点）" class="headerlink" title="（1） 进程与线程的区别和联系（重点）"></a>（1） 进程与线程的区别和联系（重点）</h2><ul><li>区别</li></ul><ol><li>进程是对运行时程序的封装，是系统进行资源分配和调度的基本单元，而线程是进程的子任务，是CPU分配和调度的基本单元。</li><li>一个进程可以有多个线程，但是一个线程只能属于一个进程。</li><li>进程的创建需要系统分配内存和CPU，文件句柄等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。</li><li>进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。</li></ol><ul><li>联系 进程与线程之间的关系：线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。</li></ul><h2 id="（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"><a href="#（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关" class="headerlink" title="（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"></a>（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</h2><p>答：32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。</p><p>至于线程。进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。Linux32位下是300多个。</p><h2 id="（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"><a href="#（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）" class="headerlink" title="（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"></a>（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</h2><ul><li>存储器：内存</li><li>控制器：南桥北桥</li><li>运算器：CPU</li><li>输入设备：键盘</li><li>输出设备：显示器、网卡</li></ul><h2 id="（4）-进程之间的通信方法有哪几种-（重点）"><a href="#（4）-进程之间的通信方法有哪几种-（重点）" class="headerlink" title="（4） 进程之间的通信方法有哪几种 （重点）"></a>（4） 进程之间的通信方法有哪几种 （重点）</h2><p>进程之间的通信方式主要有六种，包括<strong>管道，信号量，消息队列，信号，共享内存，套接字</strong>。</p><ul><li><p>管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png" alt="fig/管道通信.png"></p><p>匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。</p><p>管道的底层实现 <a href="https://segmentfault.com/a/1190000009528245">https://segmentfault.com/a/1190000009528245</a></p></li><li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。</p></li><li><p>信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的</p></li><li><p>共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。</p></li><li><p>消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。<br>消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。<br>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p></li><li><p>套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p></li></ul><h2 id="（5）-进程调度方法详细介绍"><a href="#（5）-进程调度方法详细介绍" class="headerlink" title="（5） 进程调度方法详细介绍"></a>（5） 进程调度方法详细介绍</h2><p><a href="https://blog.csdn.net/u011080472/article/details/51217754">https://blog.csdn.net/u011080472/article/details/51217754</a></p><p><a href="https://blog.csdn.net/leex_brave/article/details/51638300">https://blog.csdn.net/leex_brave/article/details/51638300</a></p><ul><li>先来先服务 （FCFS first come first serve）：按照作业到达任务队列的顺序调度  FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）而不利于短作业（I&#x2F;O繁忙性）。</li><li>短作业优先 （SHF short job first）：每次从队列里选择预计时间最短的作业运行。SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业可能一直处于等待状态，出现饥饿现象；完全未考虑作业的优先紧迫程度，不能用于实时系统。</li><li>最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。</li><li>高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。响应比 &#x3D; （等待时间 + 服务时间） &#x2F; 服务时间 &#x3D; 等待时间 &#x2F; 服务时间 + 1。因为每次都需要计算响应比，所以比较耗费系统资源。</li><li>时间片轮转 用于分时系统的进程调度。基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。</li><li>多级反馈队列(Multilevel Feedback Queue)</li></ul><h2 id="（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？"><a href="#（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？" class="headerlink" title="（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？"></a>（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？</h2><p>进程的执行需要经过三大步骤：编译，链接和装入。</p><ul><li>编译：将源代码编译成若干模块</li><li>链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）</li><li>装入：将模块装入内存运行</li></ul><p><a href="https://blog.csdn.net/qq_38623623/article/details/78306498">https://blog.csdn.net/qq_38623623/article/details/78306498</a></p><p>将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。</p><p>通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。</p><h2 id="（6）-操作系统的内存管理说一下"><a href="#（6）-操作系统的内存管理说一下" class="headerlink" title="（6） 操作系统的内存管理说一下"></a>（6） 操作系统的内存管理说一下</h2><p><a href="https://www.cnblogs.com/peterYong/p/6556619.html">https://www.cnblogs.com/peterYong/p/6556619.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/141602175">https://zhuanlan.zhihu.com/p/141602175</a></p><p>操作系统的内存管理包括物理内存管理和虚拟内存管理</p><ul><li>物理内存管理包括交换与覆盖，分页管理，分段管理和段页式管理等；</li><li>虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等；</li></ul><p>（面试官这样问的时候，其实是希望你能讲讲虚拟内存）</p><h2 id="（7）-实现一个LRU算法"><a href="#（7）-实现一个LRU算法" class="headerlink" title="（7） 实现一个LRU算法"></a>（7） 实现一个LRU算法</h2><p>用到两个数据结构：哈希+双向链表 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; &gt; cache ;<span class="comment">// 存放键，迭代器</span></span><br><span class="line">list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; auxlist; <span class="comment">// 存放 &lt;键，值&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; l;  <span class="comment">// front:new back:old 存放值</span></span><br><span class="line">                             <span class="comment">// 新的放前面，因为前面的可以取得有效的迭代器</span></span><br><span class="line">    map&lt;<span class="type">int</span>, list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt; cache;  <span class="comment">// 存放键，迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123; cap = capacity; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> mapitera = cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (mapitera == cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// found</span></span><br><span class="line">            list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator listItera = mapitera-&gt;second;</span><br><span class="line">            <span class="type">int</span> value = (*listItera).second;</span><br><span class="line"></span><br><span class="line">            l.<span class="built_in">erase</span>(listItera);</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key, value&#125;);</span><br><span class="line">            cache[key] = l.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> itera = cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (itera != cache.<span class="built_in">end</span>()) &#123;  <span class="comment">// exist</span></span><br><span class="line">            list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator listItera = itera-&gt;second;</span><br><span class="line"></span><br><span class="line">            l.<span class="built_in">erase</span>(listItera);</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key, value&#125;);</span><br><span class="line">            cache[key] = l.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// not exist</span></span><br><span class="line">            <span class="keyword">if</span> (cache.<span class="built_in">size</span>() &gt;= cap) &#123;</span><br><span class="line">                pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; oldpair = l.<span class="built_in">back</span>();</span><br><span class="line">                l.<span class="built_in">pop_back</span>();</span><br><span class="line">                cache.<span class="built_in">erase</span>(oldpair.first);</span><br><span class="line">            &#125;</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key, value&#125;);</span><br><span class="line">            cache[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）"><a href="#（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）" class="headerlink" title="（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）"></a>（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）</h2><p>（1） 互斥：一个资源每次只能被一个进程使用。<br><br>（2） 占有并请求：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br><br>（3） 不可剥夺:进程已获得的资源，在末使用完之前，不能强行剥夺。<br><br>（4） 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。<br></p><p>产生死锁的原因主要是：<br><br>（1） 因为系统资源不足。<br><br>（2） 进程运行推进的顺序不合适。<br><br>（3） 资源分配不当等。<br></p><h2 id="（8）-死锁的恢复"><a href="#（8）-死锁的恢复" class="headerlink" title="（8） 死锁的恢复"></a>（8） 死锁的恢复</h2><ol><li>重新启动：是最简单、最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。</li><li>终止进程(process termination)：终止参与死锁的进程并回收它们所占资源。<br>(1) 一次性全部终止；(2) 逐步终止(优先级，代价函数)</li><li>剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。<br>(1) 逐步剥夺：一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。<br>(2) 一次剥夺：一次性地剥夺死锁进程所占有的全部资源。</li><li>进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大：<br>(1) 要实现“回退”，必须“记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。<br>(2) 一个回退的进程应当“挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的</li></ol><h2 id="（8）什么是饥饿"><a href="#（8）什么是饥饿" class="headerlink" title="（8）什么是饥饿"></a>（8）什么是饥饿</h2><p>饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。</p><h2 id="（9）-如果要你实现一个mutex互斥锁你要怎么实现？"><a href="#（9）-如果要你实现一个mutex互斥锁你要怎么实现？" class="headerlink" title="（9） 如果要你实现一个mutex互斥锁你要怎么实现？"></a>（9） 如果要你实现一个mutex互斥锁你要怎么实现？</h2><p><a href="https://blog.csdn.net/kid551/article/details/84338619">https://blog.csdn.net/kid551/article/details/84338619</a></p><p>实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag&#x3D;1表明该锁已经锁住，flag&#x3D;0表明锁没有锁住。<br>实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;flag,<span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//flag=1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为while有可能被重入，所以可以用TestandSet()方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> old = *ptr;</span><br><span class="line">    *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？"><a href="#（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？" class="headerlink" title="（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？"></a>（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</h2><p>线程之间通信：</p><ul><li>使用全局变量</li><li>使用信号机制</li><li>使用事件</li></ul><p>进程之间同步：<br><a href="https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html">https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html</a></p><ul><li>信号量</li><li>管程</li></ul><h2 id="（13）-什么时候用多进程，什么时候用多线程"><a href="#（13）-什么时候用多进程，什么时候用多线程" class="headerlink" title="（13） 什么时候用多进程，什么时候用多线程"></a>（13） 什么时候用多进程，什么时候用多线程</h2><p><a href="https://blog.csdn.net/yu876876/article/details/82810178">https://blog.csdn.net/yu876876/article/details/82810178</a></p><ul><li>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></li><li>计算量：需要大量计算的优先使用<strong>多线程</strong>  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</li><li>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</li><li>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</li></ul><p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p><h2 id="（14）-文件读写使用的系统调用"><a href="#（14）-文件读写使用的系统调用" class="headerlink" title="（14） 文件读写使用的系统调用"></a>（14） 文件读写使用的系统调用</h2><h2 id="（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？"><a href="#（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？" class="headerlink" title="（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？"></a>（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？</h2><p><a href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p><ul><li>孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。</li><li>僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。</li></ul><h2 id="（16）-说一下PCB-说一下进程地址空间"><a href="#（16）-说一下PCB-说一下进程地址空间" class="headerlink" title="（16） 说一下PCB&#x2F;说一下进程地址空间&#x2F;"></a>（16） 说一下PCB&#x2F;说一下进程地址空间&#x2F;</h2><p><a href="https://blog.csdn.net/qq_38499859/article/details/80057427">https://blog.csdn.net/qq_38499859/article/details/80057427</a></p><p>PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。</p><p>PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息</p><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/Center.jpeg"></p><p>进程地址空间内有：</p><ul><li>代码段text：存放程序的二进制代码</li><li>初始化的数据Data：已经初始化的变量和数据</li><li>未初始化的数据BSS：还没有初始化的数据</li><li>栈</li><li>堆</li></ul><h2 id="（17）-内核空间和用户空间是怎样区分的"><a href="#（17）-内核空间和用户空间是怎样区分的" class="headerlink" title="（17） 内核空间和用户空间是怎样区分的"></a>（17） 内核空间和用户空间是怎样区分的</h2><p>在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。</p><p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。</p><h2 id="（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"><a href="#（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）" class="headerlink" title="（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"></a>（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</h2><p><a href="https://blog.csdn.net/s_lisheng/article/details/74278765">https://blog.csdn.net/s_lisheng/article/details/74278765</a></p><ul><li>临界区</li><li>信号量</li><li>事件</li><li>互斥量</li></ul><h2 id="（19）-同一个进程内的线程会共享什么资源？"><a href="#（19）-同一个进程内的线程会共享什么资源？" class="headerlink" title="（19） 同一个进程内的线程会共享什么资源？"></a>（19） 同一个进程内的线程会共享什么资源？</h2><ul><li>该进程的地址空间</li><li>全局变量</li><li>堆空间</li></ul><p>线程的栈空间是自己独有的</p><h2 id="（20）-异常和中断的区别"><a href="#（20）-异常和中断的区别" class="headerlink" title="（20） 异常和中断的区别"></a>（20） 异常和中断的区别</h2><h2 id="（21）-一般情况下在Linux-windows平台下栈空间的大小"><a href="#（21）-一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="（21） 一般情况下在Linux&#x2F;windows平台下栈空间的大小"></a>（21） 一般情况下在Linux&#x2F;windows平台下栈空间的大小</h2><p>在Linux下栈空间通常是8M，Windows下是1M</p><h2 id="（22）虚拟内存的了解"><a href="#（22）虚拟内存的了解" class="headerlink" title="（22）虚拟内存的了解"></a>（22）虚拟内存的了解</h2><p><a href="https://www.cnblogs.com/Przz/p/6876988.html">https://www.cnblogs.com/Przz/p/6876988.html</a></p><p>在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。<br>当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。</p><h2 id="（23）服务器高并发的解决方案"><a href="#（23）服务器高并发的解决方案" class="headerlink" title="（23）服务器高并发的解决方案"></a>（23）服务器高并发的解决方案</h2><ol><li><p>应用数据与静态资源分离<br>将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p></li><li><p>客户端缓存<br>因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p></li><li><p>集群和分布式<br>（集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br><br>（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br><br>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p></li><li><p>反向代理<br>在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</p></li></ol><h2 id="（24）协程了解吗（高频）"><a href="#（24）协程了解吗（高频）" class="headerlink" title="（24）协程了解吗（高频）"></a>（24）协程了解吗（高频）</h2><p>协程和微线程是一个东西。</p><p>协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。<br>这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。</p><h2 id="（25）那协程的底层是怎么实现的，怎么使用协程？"><a href="#（25）那协程的底层是怎么实现的，怎么使用协程？" class="headerlink" title="（25）那协程的底层是怎么实现的，怎么使用协程？"></a>（25）那协程的底层是怎么实现的，怎么使用协程？</h2><p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p><h2 id="（23）进程的状态以及转换图"><a href="#（23）进程的状态以及转换图" class="headerlink" title="（23）进程的状态以及转换图"></a>（23）进程的状态以及转换图</h2><ul><li><p>三态模型<br>三态模型包括三种状态：</p><ol><li>执行：进程分到CPU时间片，可以执行</li><li>就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行</li><li>阻塞：有IO事件或者等待其他资源<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B.png"></li></ol></li><li><p>五态模型</p><ol><li>新建态：进程刚刚创建。</li><li>就绪态：</li><li>运行态：</li><li>等待态：出现等待事件</li><li>终止态：进程结束<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B.png"></li></ol></li><li><p>七态模型</p><ol><li>新建态</li><li>就绪挂起态</li><li>就绪态</li><li>运行态</li><li>等待态</li><li>挂起等待态</li><li>终止态<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%B8%83%E6%80%81%E6%A8%A1%E5%9E%8B.png"></li></ol></li></ul><h2 id="（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？"><a href="#（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？" class="headerlink" title="（24）在执行malloc申请内存的时候，操作系统是怎么做的？&#x2F;内存分配的原理说一下&#x2F;malloc函数底层是怎么实现的？&#x2F;进程是怎么分配内存的？"></a>（24）在执行malloc申请内存的时候，操作系统是怎么做的？&#x2F;内存分配的原理说一下&#x2F;malloc函数底层是怎么实现的？&#x2F;进程是怎么分配内存的？</h2><p><a href="https://blog.csdn.net/yusiguyuan/article/details/39496057">https://blog.csdn.net/yusiguyuan/article/details/39496057</a></p><p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p><ul><li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li><li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li></ul><p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p><p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p><h2 id="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"><a href="#（25）什么是字节序？怎么判断是大端还是小端？有什么用？" class="headerlink" title="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"></a>（25）什么是字节序？怎么判断是大端还是小端？有什么用？</h2><p><a href="https://www.cnblogs.com/broglie/p/5645200.html">https://www.cnblogs.com/broglie/p/5645200.html</a></p><p>字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。<br>判断大小端的方法：使用一个union数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">endian</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    endian value;</span><br><span class="line">    value.a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//a和ch共用4字节的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (value.ch == <span class="number">0x12</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;big endian&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value.ch == <span class="number">0x34</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;little endian&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在网络编程中不同字节序的机器发送和接收的顺序不同。</p><h1 id="4-Linux"><a href="#4-Linux" class="headerlink" title="4. Linux"></a>4. Linux</h1><h2 id="（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"><a href="#（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）" class="headerlink" title="（1） Linux的I&#x2F;O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"></a>（1） Linux的I&#x2F;O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</h2><p><a href="https://blog.csdn.net/sqsltr/article/details/92762279">https://blog.csdn.net/sqsltr/article/details/92762279</a></p><p><a href="https://www.cnblogs.com/euphie/p/6376508.html">https://www.cnblogs.com/euphie/p/6376508.html</a></p><p>（IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据）</p><ul><li><p>阻塞：调用IO操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝。</p></li><li><p>非阻塞：调用IO操作的时候，内核会马上返回结果，如果IO不可用，会返回错误，这种方式下进程需要不断轮询直到IO可用为止，但是当进程从内核拷贝数据时是阻塞的。</p></li><li><p>IO多路复用就是同时监听多个描述符，一旦某个描述符IO就绪（读就绪或者写就绪），就能够通知进程进行相应的IO操作，否则就将进程阻塞在select或者epoll语句上。</p></li><li><p>同步IO：同步IO模型包括阻塞IO，非阻塞IO和IO多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。</p></li><li><p>异步IO：在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当IO完成后内核会给进程发送一个信号。</p></li></ul><h2 id="（2）-文件系统的理解（EXT4，XFS，BTRFS）"><a href="#（2）-文件系统的理解（EXT4，XFS，BTRFS）" class="headerlink" title="（2） 文件系统的理解（EXT4，XFS，BTRFS）"></a>（2） 文件系统的理解（EXT4，XFS，BTRFS）</h2><h2 id="（3）-EPOLL的介绍和了解"><a href="#（3）-EPOLL的介绍和了解" class="headerlink" title="（3） EPOLL的介绍和了解"></a>（3） EPOLL的介绍和了解</h2><p><a href="https://zhuanlan.zhihu.com/p/56486633">https://zhuanlan.zhihu.com/p/56486633</a> </p><p><a href="https://www.jianshu.com/p/397449cadc9a">https://www.jianshu.com/p/397449cadc9a</a></p><p><a href="https://blog.csdn.net/davidsguo008/article/details/73556811">https://blog.csdn.net/davidsguo008/article/details/73556811</a></p><p>Epoll是Linux进行IO多路复用的一种方式，用于在一个线程里监听多个IO源，在IO源可用的时候返回并进行操作。它的特点是基于事件驱动，性能很高。</p><p>epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。</p><p>Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。</p><ul><li><p>eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。</p></li><li><p>epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。</p></li><li><p>epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。</p></li></ul><h2 id="（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？"><a href="#（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？" class="headerlink" title="（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？"></a>（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</h2><p>（1）select的方法介绍：select把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024.<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/select.png" alt="select"><br>（2)poll使用链表保存文件描述符，其他的跟select没有什么不同。</p><p>（3）epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/epoll.png" alt="epoll"><br>详见 <a href="https://www.cnblogs.com/Anker/p/3265058.html">https://www.cnblogs.com/Anker/p/3265058.html</a></p><h2 id="（5）-Epoll的ET模式和LT模式（ET的非阻塞）"><a href="#（5）-Epoll的ET模式和LT模式（ET的非阻塞）" class="headerlink" title="（5） Epoll的ET模式和LT模式（ET的非阻塞）"></a>（5） Epoll的ET模式和LT模式（ET的非阻塞）</h2><ul><li>ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。</li><li>LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。</li></ul><h2 id="（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"><a href="#（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）" class="headerlink" title="（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"></a>（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</h2><p>详见：<a href="https://blog.csdn.net/qq_36357820/article/details/76606113">https://blog.csdn.net/qq_36357820/article/details/76606113</a></p><ol><li>top命令查看linux负载：</li><li>uptime查看linux负载</li><li>w查看linux负载：</li><li>vmstat查看linux负载</li></ol><h2 id="（7）-linux的其他常见命令（kill，find，cp等等）"><a href="#（7）-linux的其他常见命令（kill，find，cp等等）" class="headerlink" title="（7） linux的其他常见命令（kill，find，cp等等）"></a>（7） linux的其他常见命令（kill，find，cp等等）</h2><h2 id="（8）-shell脚本用法"><a href="#（8）-shell脚本用法" class="headerlink" title="（8） shell脚本用法"></a>（8） shell脚本用法</h2><h2 id="（9）-硬连接和软连接的区别"><a href="#（9）-硬连接和软连接的区别" class="headerlink" title="（9） 硬连接和软连接的区别"></a>（9） 硬连接和软连接的区别</h2><h2 id="（10）-文件权限怎么看（rwx）"><a href="#（10）-文件权限怎么看（rwx）" class="headerlink" title="（10） 文件权限怎么看（rwx）"></a>（10） 文件权限怎么看（rwx）</h2><h2 id="（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变"><a href="#（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变" class="headerlink" title="（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变"></a>（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</h2><h2 id="（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"><a href="#（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令" class="headerlink" title="（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"></a>（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</h2><h2 id="（13）Linux中线程的同步方式有哪些？"><a href="#（13）Linux中线程的同步方式有哪些？" class="headerlink" title="（13）Linux中线程的同步方式有哪些？"></a>（13）Linux中线程的同步方式有哪些？</h2><h2 id="（14）怎么修改一个文件的权限"><a href="#（14）怎么修改一个文件的权限" class="headerlink" title="（14）怎么修改一个文件的权限"></a>（14）怎么修改一个文件的权限</h2><p>chmod 777  (177 277 477 等，权限组合是 1 2 4，分别代表r x w )</p><h2 id="（15）查看文件内容常用命令"><a href="#（15）查看文件内容常用命令" class="headerlink" title="（15）查看文件内容常用命令"></a>（15）查看文件内容常用命令</h2><p>详见： <a href="http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html">http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html</a></p><ol><li>cat 与 tac</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。所以通常使用重定向的方式，输出满足指定格式的内容</span><br><span class="line"></span><br><span class="line">cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）</span><br><span class="line"></span><br><span class="line">tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令不常用。</span><br><span class="line"></span><br><span class="line">tac语法：tac 文件名。</span><br></pre></td></tr></table></figure><ol start="2"><li>more和less（常用）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | more</span><br><span class="line"></span><br><span class="line">more的语法：more 文件名</span><br><span class="line"></span><br><span class="line">Enter 向下n行，需要定义，默认为1行； </span><br><span class="line"></span><br><span class="line">Ctrl f 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">空格键 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">Ctrl b 返回上一屏； </span><br><span class="line"></span><br><span class="line">= 输出当前行的行号； </span><br><span class="line"></span><br><span class="line">:f 输出文件名和当前行的行号； </span><br><span class="line"></span><br><span class="line">v 调用vi编辑器； </span><br><span class="line"></span><br><span class="line">! 命令 调用Shell，并执行命令； </span><br><span class="line"></span><br><span class="line">q 退出more</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">less的功能和more相似，但是使用more无法向前翻页，只能向后翻。</span><br><span class="line"></span><br><span class="line">less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。</span><br><span class="line"></span><br><span class="line">less的语法：less 文件名</span><br></pre></td></tr></table></figure><ol start="3"><li>head和tail</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容</span><br><span class="line"></span><br><span class="line">head的语法：head [n number] 文件名 (number 显示行数)</span><br><span class="line"></span><br><span class="line">tail的功能恰好和head相反，只显示最后几行内容</span><br><span class="line"></span><br><span class="line">tail的语法:tail [-n number] 文件名</span><br></pre></td></tr></table></figure><ol start="4"><li>nl</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来</span><br><span class="line"></span><br><span class="line">nl的语法：nl 文件名</span><br></pre></td></tr></table></figure><ol start="5"><li>vim</li></ol><p>这个用的太普遍了，主要是用于编辑。</p><h2 id="（16）怎么找出含有关键字的前后4行"><a href="#（16）怎么找出含有关键字的前后4行" class="headerlink" title="（16）怎么找出含有关键字的前后4行"></a>（16）怎么找出含有关键字的前后4行</h2><h2 id="（17）Linux的GDB调试"><a href="#（17）Linux的GDB调试" class="headerlink" title="（17）Linux的GDB调试"></a>（17）Linux的GDB调试</h2><h2 id="（18）coredump是什么-怎么才能coredump，为什么产生core文件"><a href="#（18）coredump是什么-怎么才能coredump，为什么产生core文件" class="headerlink" title="（18）coredump是什么 怎么才能coredump，为什么产生core文件"></a>（18）coredump是什么 怎么才能coredump，为什么产生core文件</h2><ul><li>它是进程运行时在突然崩溃的<strong>那一刻的一个内存快照</strong>。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻<strong>内存</strong>、<strong>寄存器状态</strong>、<strong>运行堆栈等信息</strong>转储保存在一个core文件里。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</li></ul><p>coredump产生的条件</p><ol><li>shell<strong>资源控制限制</strong>，使用 ulimit -c 命令查看shell执行程序时的资源 ，如果为0，则不会产生coredump。可以用ulimit -c unlimited设置为不限大小。</li><li>读写越界，包括：数组访问越界，指针指向错误的内存，字符串读写越界</li><li>堆栈溢出</li><li>使用了<strong>线程不安全</strong>的函数，读写未加锁保护</li><li>错误<strong>使用指针转换</strong></li></ol><h2 id="（19）tcpdump常用命令"><a href="#（19）tcpdump常用命令" class="headerlink" title="（19）tcpdump常用命令"></a>（19）tcpdump常用命令</h2><p>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p><p>实用命令实例</p><p>将某端口收发的数据包保存到文件<br><br><code>sudo tcpdump -i any port 端口 -w 文件名.cap</code></p><p>打印请求到屏幕<br><br><code>sudo tcpdump -i any port 端口 -Xnlps0</code></p><p>默认启动<br><br><code>tcpdump</code><br>普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。<br>监视指定网络接口的数据包<br><br><code>tcpdump -i eth1</code><br>如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。</p><h2 id="（20）-crontab命令"><a href="#（20）-crontab命令" class="headerlink" title="（20） crontab命令"></a>（20） crontab命令</h2><p>详见：<a href="https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html">https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html</a></p><p>corntab命令是用来指定用户计划任务的。用户将需要定时执行的任务写入crontab文件中，提交给crond进程定期执行。</p><ul><li>crontab命令用来对crontab文件进行管理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1．命令格式：</span><br><span class="line">crontab [-u user] file</span><br><span class="line">crontab [-u user] [ -e | -l | -r ]</span><br><span class="line">2．命令功能：</span><br><span class="line">通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</span><br><span class="line">3．命令参数：</span><br><span class="line">-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</span><br><span class="line">file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</span><br><span class="line">-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line">-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line">-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line">-i：在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure><ul><li>crontab文件内容</li></ul><p>crond是Linux下的周期性执行系统任务的守护进程，他会根据&#x2F;etc下的crontab配置文件的内容执行。用户需要将计划任务写入crontab文件中才能执行。</p><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">minute   hour   day   month   week   command</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">minute： 表示分钟，可以是从0到59之间的任何整数。</span><br><span class="line">hour：表示小时，可以是从0到23之间的任何整数。</span><br><span class="line">day：表示日期，可以是从1到31之间的任何整数。</span><br><span class="line">month：表示月份，可以是从1到12之间的任何整数。</span><br><span class="line">week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</span><br><span class="line">在以上各个字段中，还可以使用以下特殊字符：</span><br><span class="line">星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class="line">逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</span><br><span class="line">中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</span><br><span class="line">正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</span><br></pre></td></tr></table></figure><h2 id="（21）-查看后台进程"><a href="#（21）-查看后台进程" class="headerlink" title="（21） 查看后台进程"></a>（21） 查看后台进程</h2><ul><li>jobs</li></ul><p>查看当前控制台的后台进程</p><p>想要停止后台进程，使用jobs命令查看其进程号（比如为num），然后kill %num即可</p><ul><li>ps</li></ul><p>查看后台进程</p><ul><li>top</li></ul><p>查看所有进程和资源使用情况，类似Windows中的任务管理器</p><p>停止进程：界面是交互式的，在窗口输入k 之后输入PID，会提示输入停止进程模式 有SIGTERM和 SIGKILL 如果留空不输入，就是SIGTERM（优雅停止）</p><p>退出top：输入q即可</p><h2 id="（22）池化技术"><a href="#（22）池化技术" class="headerlink" title="（22）池化技术"></a>（22）池化技术</h2><p><a href="https://zhuanlan.zhihu.com/p/538360410">池化技术</a></p><h2 id="（23）硬中断和软中断——-new"><a href="#（23）硬中断和软中断——-new" class="headerlink" title="（23）硬中断和软中断——&#x3D;&#x3D;new&#x3D;&#x3D;"></a>（23）硬中断和软中断——&#x3D;&#x3D;new&#x3D;&#x3D;</h2><blockquote><p>当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数</p></blockquote><h3 id="硬件中断处理函数会做如下的事情："><a href="#硬件中断处理函数会做如下的事情：" class="headerlink" title="硬件中断处理函数会做如下的事情："></a>硬件中断处理函数会做如下的事情：</h3><ul><li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li><li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li></ul><p>至此，硬件中断处理函数的工作就已经完成。</p><p>硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。</p><h3 id="软中断的处理"><a href="#软中断的处理" class="headerlink" title="软中断的处理"></a>软中断的处理</h3><ul><li>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。</li><li>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</li><li>Ring Buffer——&gt;环形缓存</li></ul><h2 id="（23）发送网络数据的时候，涉及几次内存拷贝操作？——-new"><a href="#（23）发送网络数据的时候，涉及几次内存拷贝操作？——-new" class="headerlink" title="（23）发送网络数据的时候，涉及几次内存拷贝操作？——&#x3D;&#x3D;new&#x3D;&#x3D;"></a>（23）发送网络数据的时候，涉及几次内存拷贝操作？——&#x3D;&#x3D;new&#x3D;&#x3D;</h2><ul><li><p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p></li><li><p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</p></li><li><p>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</p></li><li><p>这里提一下，sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，UDP协议的称为 数据报（datagrams），在 IP 层我们叫 packet，在数据链路层称为 frame</p><ul><li><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/sk_buff.jpg" alt="img"></li></ul></li></ul><h2 id="（24）Linux网络模型——-new"><a href="#（24）Linux网络模型——-new" class="headerlink" title="（24）Linux网络模型——&#x3D;&#x3D;new&#x3D;&#x3D;"></a>（24）Linux网络模型——&#x3D;&#x3D;new&#x3D;&#x3D;</h2><ul><li>和 TCP&#x2F;IP 四层网络模型相似</li></ul><img src="面经整理发布版.assets/协议栈.png" alt="img" style="zoom:50%;" /><h1 id="5-数据库"><a href="#5-数据库" class="headerlink" title="5. 数据库"></a>5. 数据库</h1><h2 id="（1）-关系型和非关系型数据库的区别（低频）"><a href="#（1）-关系型和非关系型数据库的区别（低频）" class="headerlink" title="（1） 关系型和非关系型数据库的区别（低频）"></a>（1） 关系型和非关系型数据库的区别（低频）</h2><ul><li>关系型数据库的优点<ol><li>容易理解。因为它采用了关系模型来组织数据。</li><li>可以保持数据的一致性。</li><li>数据更新的开销比较小。</li><li>支持复杂查询（带where子句的查询）</li></ol></li><li>非关系型数据库的优点<ol><li>不需要经过sql层的解析，读写效率高。</li><li>基于键值对，数据的扩展性很好。</li><li>可以支持多种类型数据的存储，如图片，文档等等。</li></ol></li></ul><h2 id="（2）-什么是非关系型数据库（低频）"><a href="#（2）-什么是非关系型数据库（低频）" class="headerlink" title="（2） 什么是非关系型数据库（低频）"></a>（2） 什么是非关系型数据库（低频）</h2><p>非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。</p><p>适合使用非关系型数据库的场景：</p><ul><li>日志系统</li><li>地理位置存储</li><li>数据量巨大</li><li>高可用</li></ul><h2 id="（3）-说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#（3）-说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="（3） 说一下 MySQL 执行一条查询语句的内部执行过程？"></a>（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</h2><ul><li>连接器：客户端先通过连接器连接到 MySQL 服务器。</li><li>缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li><li>分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li><li>优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li><li>执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li></ul><h2 id="（4）-数据库的索引类型"><a href="#（4）-数据库的索引类型" class="headerlink" title="（4） 数据库的索引类型"></a>（4） 数据库的索引类型</h2><p>数据库的索引类型分为逻辑分类和物理分类<br><br>逻辑分类：</p><ul><li>主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。</li><li>唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。</li><li>普通索引 一张表可以有多个普通索引，可以重复可以为空值</li><li>全文索引 可以加快模糊查询，不常用</li></ul><p>物理分类：</p><ul><li>聚集索引（聚簇索引） 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。</li><li>非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。</li></ul><h2 id="（5）-说一下事务是怎么实现的"><a href="#（5）-说一下事务是怎么实现的" class="headerlink" title="（5） 说一下事务是怎么实现的"></a>（5） 说一下事务是怎么实现的</h2><p><a href="https://blog.csdn.net/u013256816/article/details/103966510">https://blog.csdn.net/u013256816/article/details/103966510</a></p><p><a href="https://www.cnblogs.com/takumicx/p/9998844.html">https://www.cnblogs.com/takumicx/p/9998844.html</a></p><p>事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p><ul><li>日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<strong>持久性</strong>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的<strong>原子性</strong>。</li><li>并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的<strong>隔离性</strong>。MVCC通过为数据添加时间戳来实现。</li></ul><h2 id="（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"><a href="#（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？" class="headerlink" title="（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"></a>（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</h2><p>MySQL建立索引有两种方式：用alter table或者create index。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add primary key(column_list) #添加一个主键索引</span><br><span class="line">alter table table_name add index (column_list)      #添加一个普通索引</span><br><span class="line">alter table table_name add unique (column_list)     #添加一个唯一索引</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name (column_list)   #创建一个普通索引</span><br><span class="line">create unique index_name on table_name (column_list)  #创建一个唯一索引</span><br></pre></td></tr></table></figure><p>Mysql删除索引同样也有两种方式：alter table 和 drop index</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name drop index index_name    #删除一个普通索引</span><br><span class="line">alter table table_name drop primary key         #删除一个主键索引</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name on table table_name</span><br></pre></td></tr></table></figure><h2 id="（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"><a href="#（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）" class="headerlink" title="（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"></a>（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</h2><p><a href="https://www.cnblogs.com/wezheng/p/8399305.html">https://www.cnblogs.com/wezheng/p/8399305.html</a></p><ul><li>经常搜索的列上建索引</li><li>作为主键的列上要建索引</li><li>经常需要连接（where子句）的列上</li><li>经常需要排序的列</li><li>经常需要范围查找的列</li></ul><p>哪些列不适合建索引？</p><ul><li>很少查询的列</li><li>更新很频繁的列</li><li>数据值的取值比较少的列（比如性别）</li></ul><h2 id="（8）-索引的底层实现（重点）"><a href="#（8）-索引的底层实现（重点）" class="headerlink" title="（8） 索引的底层实现（重点）"></a>（8） 索引的底层实现（重点）</h2><p>数据库的索引是使用B+树来实现的。</p><p>（为什么要用B+树，为什么不用红黑树和B树）<br><br>B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。</p><p>而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。</p><h2 id="（9）-B树和B-树的区别（重点）"><a href="#（9）-B树和B-树的区别（重点）" class="headerlink" title="（9） B树和B+树的区别（重点）"></a>（9） B树和B+树的区别（重点）</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/Bptree.png" alt="./fig/Bptree.png"></p><p>这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。</p><ol><li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li><li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li><li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li><li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li></ol><p>B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。</p><h2 id="（10）-索引最左前缀-最左匹配"><a href="#（10）-索引最左前缀-最左匹配" class="headerlink" title="（10） 索引最左前缀&#x2F;最左匹配"></a>（10） 索引最左前缀&#x2F;最左匹配</h2><p>假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。</p><h2 id="（11）-Mysql的优化（高频，索引优化，性能优化）"><a href="#（11）-Mysql的优化（高频，索引优化，性能优化）" class="headerlink" title="（11） Mysql的优化（高频，索引优化，性能优化）"></a>（11） Mysql的优化（高频，索引优化，性能优化）</h2><p>高频访问：</p><ul><li>分表分库：将数据库表进行水平拆分，减少表的长度</li><li>增加缓存： 在web和DB之间加上一层缓存层</li><li>增加数据库的索引：在合适的字段加上索引，解决高频访问的问题</li></ul><p>并发优化：</p><ul><li>主从读写分离：只在主服务器上写，从服务器上读</li><li>负载均衡集群：通过集群或者分布式的方式解决并发压力</li></ul><h2 id="（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别"><a href="#（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别" class="headerlink" title="（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别"></a>（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</h2><ul><li>InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁</li><li>MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用  表级锁</li><li>MEMORY ： memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景</li><li>CSV</li><li>blackhole</li></ul><h2 id="（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"><a href="#（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）" class="headerlink" title="（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"></a>（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</h2><p>数据库事务是指逻辑上对数据的一种操作，这个事务要么全部成功，要么全部失败。</p><p><strong>A: atom 原子性</strong><br><br>数据库事务的原子性是指：事务是一个不可分割的工作单位，这组操作要么全部发生，要么全部不发生。</p><p><strong>C: consistency 一致性</strong><br><br>数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。<br>比如在银行转账操作后两个账户的总额应当不变。</p><p><strong>I: isolation 隔离性</strong><br><br>数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响，对于数据库中同时执行的每个事务来说，其他事务要么还没开始执行，要么已经执行结束，它都感觉不到还有别的事务正在执行。</p><p><strong>D：durability 持久性</strong><br><br>数据库事务的持久性要求事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。<br>如果事务没有完成，数据库因故断电了，那么重启后也应该是没有执行事务的状态，如果事务已经完成后数据库断电了，那么重启后就应该是事务执行完成后的状态。</p><h2 id="（14）什么是脏读，不可重复读和幻读？"><a href="#（14）什么是脏读，不可重复读和幻读？" class="headerlink" title="（14）什么是脏读，不可重复读和幻读？"></a>（14）什么是脏读，不可重复读和幻读？</h2><p>详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a></p><ul><li><p>脏读：脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据。</p><blockquote><p>比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读</p></blockquote></li><li><p>不可重复读：不可重复读是对于数据库中的某一个字段，一个事务多次查询却返回了不同的值，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。</p><blockquote><p>比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。<br>不可重复读与脏读的不同之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。</p></blockquote></li><li><p>幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。</p><blockquote><p>比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。<br>不可重复度和幻读的不同之处在于，幻读是多次读取的结果行数不同，不可重复度是读取结果的值不同。</p></blockquote></li></ul><p>避免不可重复读需要锁行，避免幻读则需要锁表。</p><p>脏读，不可重复读和幻读都是数据库的读一致性问题，是在并行的过程中出现的问题，必须采用一定的隔离级别解决。<br>详见<a href="https://www.cnblogs.com/Hakuna-Matata/p/7772794.html">脏读、不可重复读和幻读的区别</a></p><h2 id="（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"><a href="#（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）" class="headerlink" title="（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"></a>（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</h2><p>详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a>和<a href="https://blog.csdn.net/fg2006/article/details/6937413">数据库隔离级别</a></p><p>为了保证数据库事务一致性，解决脏读，不可重复读和幻读的问题，数据库的隔离级别一共有四种隔离级别：</p><ul><li>读未提交 Read Uncommitted: 最低级别的隔离，不能解决以上问题</li><li>读已提交 Read committed:   可以避免脏读的发生 </li><li>可重复读 Reapeatable read:  确保事务可以多次从一个字段中读取相同的值，在该事务执行期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读。 通过锁行来实现 </li><li>串行化 Serializaion  最严格的事务隔离机制，要求所有事务被串行执行，可以避免以上所有问题。 通过锁表来实现</li></ul><p>Oracle的默认隔离级别是<strong>读已提交</strong>，实现了四种隔离级别中的读已提交和串行化隔离级别</p><p>MySQL的默认隔离级别是<strong>可重复读</strong>，并且实现了所有四种隔离级别</p><h2 id="（16）-数据库连接池的作用"><a href="#（16）-数据库连接池的作用" class="headerlink" title="（16） 数据库连接池的作用"></a>（16） 数据库连接池的作用</h2><h2 id="（17）-Mysql的表空间方式，各自特点"><a href="#（17）-Mysql的表空间方式，各自特点" class="headerlink" title="（17） Mysql的表空间方式，各自特点"></a>（17） Mysql的表空间方式，各自特点</h2><ul><li>共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 </li><li>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题</li></ul><h2 id="（18）-分布式事务"><a href="#（18）-分布式事务" class="headerlink" title="（18） 分布式事务"></a>（18） 分布式事务</h2><h2 id="（19）-数据库的范式"><a href="#（19）-数据库的范式" class="headerlink" title="（19） 数据库的范式"></a>（19） 数据库的范式</h2><p><a href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p><ul><li><strong>第一范式(确保每列保持原子性)</strong><br><br>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</li></ul><blockquote><p>比如 学生 选课（包括很多课程） 就不符合第一范式</p></blockquote><ul><li><strong>第二范式(确保表中的每列都和主键相关)</strong><br><br>在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。</li></ul><blockquote><p>比如一张学生信息表，由主键（学号）可以唯一确定一个学生的姓名，班级，年龄等信息。但是主键 （学号，班级） 与列 姓名，班主任，教室 就不符合第二范式，因为班主任跟部分主键（班级）是依赖关系</p></blockquote><ul><li><strong>第三范式(确保非主键的列没有传递依赖)</strong><br><br>在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。</li></ul><blockquote><p>比如一张学生信息表，主键是（学号）列包括 姓名，班级，班主任 就不符合第三范式，因为非主键的列中 班主任 依赖于 班级</p></blockquote><ul><li><strong>BCNF范式（确保主键之间没有传递依赖）</strong><br><br>主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。</li></ul><h2 id="（20）-数据的锁的种类，加锁的方式"><a href="#（20）-数据的锁的种类，加锁的方式" class="headerlink" title="（20） 数据的锁的种类，加锁的方式"></a>（20） 数据的锁的种类，加锁的方式</h2><p>以MYSQL为例，</p><ul><li>按照类型来分有乐观锁和悲观锁</li><li>根据粒度来分有行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁）</li><li>根据作用来分有共享锁（读锁）和排他锁（写锁）。</li></ul><h2 id="（21）-什么是共享锁和排他锁"><a href="#（21）-什么是共享锁和排他锁" class="headerlink" title="（21） 什么是共享锁和排他锁"></a>（21） 什么是共享锁和排他锁</h2><ul><li><p>共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。</p></li><li><p>排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）</p><p><a href="https://blog.csdn.net/qq_42743933/article/details/81236658">https://blog.csdn.net/qq_42743933/article/details/81236658</a></p></li></ul><h2 id="（22）-分库分表的理解和简介"><a href="#（22）-分库分表的理解和简介" class="headerlink" title="（22） 分库分表的理解和简介"></a>（22） 分库分表的理解和简介</h2><h2 id="（23）数据库高并发的解决方案"><a href="#（23）数据库高并发的解决方案" class="headerlink" title="（23）数据库高并发的解决方案"></a>（23）数据库高并发的解决方案</h2><ol><li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li><li>增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li><li>主从读写分离，让主服务器负责写，从服务器负责读。</li><li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li><li>使用分布式架构，分散计算压力。</li></ol><h2 id="（24）乐观锁与悲观锁解释一下"><a href="#（24）乐观锁与悲观锁解释一下" class="headerlink" title="（24）乐观锁与悲观锁解释一下"></a>（24）乐观锁与悲观锁解释一下</h2><p>一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。</p><p>悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。</p><h2 id="（25）乐观锁与悲观锁是怎么实现的"><a href="#（25）乐观锁与悲观锁是怎么实现的" class="headerlink" title="（25）乐观锁与悲观锁是怎么实现的"></a>（25）乐观锁与悲观锁是怎么实现的</h2><p>悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。</p><p>悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。</p><p>乐观锁有三种常用的实现形式：</p><ul><li>一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。</li><li>一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。</li><li>最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。</li></ul><h2 id="（26）对数据库目前最新技术有什么了解吗"><a href="#（26）对数据库目前最新技术有什么了解吗" class="headerlink" title="（26）对数据库目前最新技术有什么了解吗"></a>（26）对数据库目前最新技术有什么了解吗</h2><h1 id="6-redis"><a href="#6-redis" class="headerlink" title="6. redis"></a>6. redis</h1><h1 id="7-场景题-算法题"><a href="#7-场景题-算法题" class="headerlink" title="7. 场景题&#x2F;算法题"></a>7. 场景题&#x2F;算法题</h1><h2 id="（0）leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！"><a href="#（0）leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！" class="headerlink" title="（0）leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！"></a>（0）leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</h2><p>面试中90%的算法题都从leetcode hot100和剑指offer中出 刷两遍非常有必要</p><h2 id="（1）介绍熟悉的设计模式（单例，简单工厂模式）"><a href="#（1）介绍熟悉的设计模式（单例，简单工厂模式）" class="headerlink" title="（1）介绍熟悉的设计模式（单例，简单工厂模式）"></a>（1）介绍熟悉的设计模式（单例，简单工厂模式）</h2><h2 id="（2）写单例模式，线程安全版本"><a href="#（2）写单例模式，线程安全版本" class="headerlink" title="（2）写单例模式，线程安全版本"></a>（2）写单例模式，线程安全版本</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">      <span class="comment">// initialize</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="（3）写三个线程交替打印ABC"><a href="#（3）写三个线程交替打印ABC" class="headerlink" title="（3）写三个线程交替打印ABC"></a>（3）写三个线程交替打印ABC</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mymutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 1: a&quot;</span> &lt;&lt; endl;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;my thread 1 finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">1</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 2: b&quot;</span> &lt;&lt; endl;</span><br><span class="line">        flag = <span class="number">2</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;my thread 2 finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">2</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 3: c&quot;</span> &lt;&lt; endl;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;my thread 3 finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(printa)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(printb)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th3</span><span class="params">(printc)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.<span class="built_in">join</span>();</span><br><span class="line">    th2.<span class="built_in">join</span>();</span><br><span class="line">    th3.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; main thread &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（4）二维码登录的实现过程-场景题"><a href="#（4）二维码登录的实现过程-场景题" class="headerlink" title="（4）二维码登录的实现过程 场景题"></a>（4）二维码登录的实现过程 场景题</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png"></p><h2 id="（5）不使用临时变量实现swap函数"><a href="#（5）不使用临时变量实现swap函数" class="headerlink" title="（5）不使用临时变量实现swap函数"></a>（5）不使用临时变量实现swap函数</h2><ul><li>使用异或&#x2F;加减等方式，下面给出使用异或的实现方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">  a=a^b;</span><br><span class="line">  b=a^b;</span><br><span class="line">  a=a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（6）实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"><a href="#（6）实现一个strcpy函数（或者memcpy），如果内存可能重叠呢" class="headerlink" title="（6）实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"></a>（6）实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</h2><h2 id="（7）十大排序"><a href="#（7）十大排序" class="headerlink" title="（7）十大排序"></a>（7）十大排序</h2><blockquote><p><a href="https://lumingdong.cn/detailed-explanation-of-ten-classic-sorting-algorithms.html">十大经典排序算法详解</a></p></blockquote><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    vec[a] = vec[a] ^ vec[b];</span><br><span class="line">    vec[b] = vec[a] ^ vec[b];</span><br><span class="line">    vec[a] = vec[a] ^ vec[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = vec[start + (end - start) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end <span class="keyword">and</span> vec[start] &lt; pivot) start++;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end <span class="keyword">and</span> vec[end] &gt; pivot) end--;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end)</span><br><span class="line">            <span class="built_in">swap</span>(vec, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">partition</span>(vec, start, end);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec, start, pivot - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec, pivot + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个堆排序"><a href="#实现一个堆排序" class="headerlink" title="实现一个堆排序"></a>实现一个堆排序</h3><p>堆排序的基本过程：</p><ul><li>将n个元素的序列构建一个大顶堆或小顶堆</li><li>将堆顶的元素放到序列末尾</li><li>将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</li></ul><p>整体时间复杂度为nlogn</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    arr[a] = arr[a] ^ arr[b];</span><br><span class="line">    arr[b] = arr[a] ^ arr[b];</span><br><span class="line">    arr[a] = arr[a] ^ arr[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> len, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxid = index;</span><br><span class="line">    <span class="comment">// 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>, right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找当前以index为根的子树中最大/最小的元素的下标</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; len <span class="keyword">and</span> arr[left] &lt; arr[maxid])</span><br><span class="line">        maxid = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len <span class="keyword">and</span> arr[right] &lt; arr[maxid])</span><br><span class="line">        maxid = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行交换，记得要递归进行adjust,传入的index是maxid</span></span><br><span class="line">    <span class="keyword">if</span> (maxid != index) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr, maxid, index);</span><br><span class="line">        <span class="built_in">adjust</span>(arr, len, maxid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (len - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">adjust</span>(arr, len, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr, <span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">adjust</span>(arr, i, <span class="number">0</span>);  <span class="comment">// 注意每次adjust是从根往下调整，所以这里index是0！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : arr) cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">heapsort</span>(arr, arr.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : arr) cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个插入排序"><a href="#实现一个插入排序" class="headerlink" title="实现一个插入排序"></a>实现一个插入排序</h3><p><a href="https://blog.csdn.net/left_la/article/details/8656425">https://blog.csdn.net/left_la/article/details/8656425</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = nums[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; key) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快排存在的问题，如何优化"><a href="#快排存在的问题，如何优化" class="headerlink" title="快排存在的问题，如何优化"></a>快排存在的问题，如何优化</h3><ul><li>3 种快排基准选择方法：</li></ul><p>随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）</p><ul><li>4种优化方式：</li></ul><p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</p><p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p><p>优化3：优化递归操作</p><p>优化4：使用并行或多线程处理子序列</p><h3 id="希尔排序说一下-手撕"><a href="#希尔排序说一下-手撕" class="headerlink" title="希尔排序说一下&#x2F;手撕"></a>希尔排序说一下&#x2F;手撕</h3><p><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">https://www.cnblogs.com/chengxiao/p/6104371.html</a><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h2 id="（8）反转一个链表（招银网络二面）"><a href="#（8）反转一个链表（招银网络二面）" class="headerlink" title="（8）反转一个链表（招银网络二面）"></a>（8）反转一个链表（招银网络二面）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* root)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>, cur = root, nxt;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        nxt = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（9）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）"><a href="#（9）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）" class="headerlink" title="（9） Top K问题（可以采取的方法有哪些，各自优点？）（重点）"></a>（9） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</h2><p><em>Top K 问题的常见形式：</em></p><blockquote><p>给定10000个整数，找第K大（第K小）的数<br><br>给定10000个整数，找出最大（最小）的前K个数<br><br>给定100000个单词，求前K词频的单词<br></p></blockquote><p><em>解决Top K问题若干种方法</em></p><ul><li>使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。</li><li>Quick Select算法。使用类似快排的思路，根据pivot划分数组。</li><li>使用排序方法，排序后再寻找top K元素。</li><li>使用选择排序的思想，对前K个元素部分排序。</li><li>将1000…..个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数。</li></ul><ol><li>使用最大最小堆的思路 （以top K 最大元素为例）<br><br>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</li></ol><blockquote><p>note：最小堆的插入时间复杂度为log(n)，n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p></blockquote><p>C++中的最大最小堆要用标准库的priority_queue来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> v, <span class="type">int</span> i): <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.value &lt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; pq; <span class="comment">// 此时pq为最大堆</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用Quick Select的思路（以寻找第K大的元素为例）<br><br>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的：<br>首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。<br>此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作；<br>如果左边的数组元素个数等于K-1，则第K大的数就是pivot；<br>如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</li></ol><p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 此为Java实现</span><br><span class="line">public</span><br><span class="line">int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">    return quickSelect(nums, k, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// quick select to find the kth-largest element</span><br><span class="line">public</span><br><span class="line">int quickSelect(int[] arr, int k, int left, int right) &#123;</span><br><span class="line">    if (left == right)</span><br><span class="line">        return arr[right];</span><br><span class="line">    int index = partition(arr, left, right);</span><br><span class="line">    if (index - left + 1 &gt; k)</span><br><span class="line">        return quickSelect(arr, k, left, index - 1);</span><br><span class="line">    else if (index - left + 1 == k)</span><br><span class="line">        return arr[index];</span><br><span class="line">    else</span><br><span class="line">        return quickSelect(arr, k - (index - left + 1), index + 1, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）<br><br>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K)</li></ol><h2 id="（10）8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"><a href="#（10）8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）" class="headerlink" title="（10）8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"></a>（10）8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</h2><p>我们可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。</p><p><a href="https://blog.csdn.net/ailunlee/article/details/84548950">https://blog.csdn.net/ailunlee/article/details/84548950</a></p><h2 id="（11）自己构建一棵二叉树，使用带有null标记的前序遍历序列"><a href="#（11）自己构建一棵二叉树，使用带有null标记的前序遍历序列" class="headerlink" title="（11）自己构建一棵二叉树，使用带有null标记的前序遍历序列"></a>（11）自己构建一棵二叉树，使用带有null标记的前序遍历序列</h2><p>在写二叉树相关算法的时候，如果需要自己构造测试用例（自己构造一棵二叉树），往往是一件很麻烦的事情，我们可以用一个带有null标记的前序遍历序列来进行构造。 <strong>需要注意的是vec2tree()参数中的start是引用传递，而不是简单的参数值传递</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treeNode</span> &#123;</span><br><span class="line">    string val;</span><br><span class="line">    treeNode *left, *right;</span><br><span class="line">    <span class="built_in">treeNode</span>(string val) : <span class="built_in">val</span>(val) &#123;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">treeNode* <span class="title">vec2tree</span><span class="params">(vector&lt;string&gt;&amp; vec, <span class="type">int</span>&amp; start)</span> </span>&#123;</span><br><span class="line">    treeNode* root;</span><br><span class="line">    <span class="keyword">if</span> (vec[start] == <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">        start += <span class="number">1</span>;</span><br><span class="line">        root = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">treeNode</span>(vec[start]);</span><br><span class="line">        start += <span class="number">1</span>;</span><br><span class="line">        root-&gt;left = <span class="built_in">vec2tree</span>(vec, start);</span><br><span class="line">        root-&gt;right = <span class="built_in">vec2tree</span>(vec, start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree2vec</span><span class="params">(treeNode* root, vector&lt;string&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;left, vec);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;right, vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec = &#123;<span class="string">&quot;2&quot;</span>,    <span class="string">&quot;4&quot;</span>,    <span class="string">&quot;5&quot;</span>,    <span class="string">&quot;7&quot;</span>,    <span class="string">&quot;null&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;null&quot;</span>, <span class="string">&quot;null&quot;</span>, <span class="string">&quot;null&quot;</span>, <span class="string">&quot;3&quot;</span>,    <span class="string">&quot;6&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;null&quot;</span>, <span class="string">&quot;null&quot;</span>, <span class="string">&quot;2&quot;</span>,    <span class="string">&quot;null&quot;</span>, <span class="string">&quot;null&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>, &amp;start = index;</span><br><span class="line">    treeNode* root = <span class="built_in">vec2tree</span>(vec, start);</span><br><span class="line">    <span class="comment">// displaytree(root);</span></span><br><span class="line">    vector&lt;string&gt; mvec;</span><br><span class="line">    <span class="built_in">tree2vec</span>(root, mvec);</span><br><span class="line">    <span class="keyword">for</span> (string item : mvec) cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="（12）介绍一下b树和它的应用场景有哪些"><a href="#（12）介绍一下b树和它的应用场景有哪些" class="headerlink" title="（12）介绍一下b树和它的应用场景有哪些"></a>（12）介绍一下b树和它的应用场景有哪些</h2><p>B树也叫做B-树，或者平衡多路树，它是每个节点最多有m个子树的<strong>平衡树</strong>。一个m阶的B树具有如下几个特征：</p><ol><li>根结点至少有两个子女。</li><li>每个中间节点都包含至多m个子树 ， 每个节点包含的元素个数是其子树个数-1（其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m）</li><li>所有的叶子结点都位于同一层。</li><li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个子树包含的元素的值域分划。</li></ol><p>b树主要应用于文件系统中，在数据库中（mongoDB）也有应用，与B+树相比好处应该是有时不需要访问到叶节点就可以获取数据。</p><p>查询时间复杂度是logN</p><h2 id="（13）介绍一下b-树和它的应用场景有哪些"><a href="#（13）介绍一下b-树和它的应用场景有哪些" class="headerlink" title="（13）介绍一下b+树和它的应用场景有哪些"></a>（13）介绍一下b+树和它的应用场景有哪些</h2><p>B+树是一种特殊的B树，它把数据都存储在叶子节点，并且叶节点间有指针连接。内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点。</p><p>应用场景主要是数据库的索引</p><p>查询时间复杂度也是logN<br><a href="https://zhuanlan.zhihu.com/p/110202102">https://zhuanlan.zhihu.com/p/110202102</a></p><p><a href="https://blog.csdn.net/hguisu/article/details/7786014">https://blog.csdn.net/hguisu/article/details/7786014</a></p><h2 id="（14）介绍一下红黑树和它的应用场景有哪些"><a href="#（14）介绍一下红黑树和它的应用场景有哪些" class="headerlink" title="（14）介绍一下红黑树和它的应用场景有哪些"></a>（14）介绍一下红黑树和它的应用场景有哪些</h2><p>红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。<br>它的性质是这样的：</p><ol><li>每个节点不是红色就是黑色。</li><li>根节点是黑色的。</li><li>叶节点的空节点是黑色的。</li><li>如果一个节点是红色的，那么它的两个子节点是黑色的。</li><li>对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。</li></ol><p>红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是O(log(n))</p><p>应用场景主要是STL中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logN</p><h2 id="（15）-怎么写sql取表的前1000行数据（招银网络二面）"><a href="#（15）-怎么写sql取表的前1000行数据（招银网络二面）" class="headerlink" title="（15） 怎么写sql取表的前1000行数据（招银网络二面）"></a>（15） 怎么写sql取表的前1000行数据（招银网络二面）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 limit <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="（16）-N个骰子出现和为m的概率"><a href="#（16）-N个骰子出现和为m的概率" class="headerlink" title="（16） N个骰子出现和为m的概率"></a>（16） N个骰子出现和为m的概率</h2><h2 id="（17）-海量数据问题（可参考左神的书）"><a href="#（17）-海量数据问题（可参考左神的书）" class="headerlink" title="（17） 海量数据问题（可参考左神的书）"></a>（17） 海量数据问题（可参考左神的书）</h2><h2 id="（18）-一致性哈希"><a href="#（18）-一致性哈希" class="headerlink" title="（18） 一致性哈希"></a>（18） 一致性哈希</h2><h2 id="（19）Dijkstra算法说一下"><a href="#（19）Dijkstra算法说一下" class="headerlink" title="（19）Dijkstra算法说一下"></a>（19）Dijkstra算法说一下</h2><h2 id="（20）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"><a href="#（20）实现一个动态数组要怎么实现，说思路（腾讯teg一面）" class="headerlink" title="（20）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"></a>（20）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</h2><p>模拟STL中vector的实现即可，去看一下vector的源码。</p><h2 id="（21）最小生成树算法说一下"><a href="#（21）最小生成树算法说一下" class="headerlink" title="（21）最小生成树算法说一下"></a>（21）最小生成树算法说一下</h2><h2 id="（22）-海量数据的bitmap使用原理"><a href="#（22）-海量数据的bitmap使用原理" class="headerlink" title="（22） 海量数据的bitmap使用原理"></a>（22） 海量数据的bitmap使用原理</h2><p>bitmap算法就是使用一个比特映射一个值，它可以用在整数排序和数据压缩上，因为使用一个比特位去存储一个数，所以它可以大大节省空间。</p><p>它的具体过程是：先根据数组中元素最大的数N计算需要分配多大的空间。<br>如果使用int型数组的形式来保存的话，一个int &#x3D; 4字节  &#x3D;4*8比特 &#x3D; 32比特。也就是一个int数可以映射32个数据（图1），然后需要找到最大的数Max，表示最多需要的位数，所以需要开辟的数组空间为int a[1+Max&#x2F;32]。<br>然后需要推导一个整数a内如何映射32个数据，方法是将待存储的数据模32，然后将a中相应位置的比特置为1。<br>依此方法映射每一个元素，待读取的时候扫描每个比特位，遇到值为1的就还原该数字。<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/bitmap1.png"></p><p><strong>移位计算公式：</strong><br>N&#x2F;32就是将N的二进制右移log32（也就是5）位 ： N&gt;&gt;5<br><br>N%32就是求N的后5位：N&amp; 0x1F  (0x1F &#x3D; 00011111)<br><br>模32然后相应位置置为1： a[i] |&#x3D; 1&lt;&lt; N &amp; 0x1F<br></p><p>所以总的公式为： a[ N&gt;&gt;5 ] |&#x3D; 1&lt;&lt; N &amp; 0x1F<br></p><p><strong>BitMap算法评价</strong></p><ul><li>优点：<ol><li>运算效率高，不进行比较和移位；</li><li>占用内存少，比如最大的数MAX&#x3D;10000000；只需占用内存为MAX&#x2F;8&#x3D;1250000Byte&#x3D;1.25M。</li></ol></li><li>缺点：<ol><li>所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。</li><li>所需要的空间随着最大元素的增大而增大，当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</li></ol></li></ul><h2 id="（23）-布隆过滤器原理与优点"><a href="#（23）-布隆过滤器原理与优点" class="headerlink" title="（23） 布隆过滤器原理与优点"></a>（23） 布隆过滤器原理与优点</h2><p>布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，用来查找一个元素是否在集合中，支持高效插入和查询某条记录。常作为针对超大数据量下高效查找数据的一种方法。</p><p><strong>它的具体工作过程是这样子的：</strong><br>假设布隆过滤器的大小为m（比特向量的长度为m），有k个哈希函数，它对每个数据用这k个哈希函数计算哈希，得到k个哈希值，然后将向量中相应的位设为1。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为1，如果某一个相应的位不为1，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。</p><p><strong>为什么说有可能存在呢？</strong><br>因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到1也可能是由于某个另外的数据映射得到的。</p><p><strong>支持删除操作吗</strong><br>目前布隆过滤器只支持插入和查找操作，不支持删除操作，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为1则计数加一，删除则减一。</p><p>布隆过滤器中哈希函数的个数需要选择。如果太多则很快所有位都置为1，如果太少会容易误报。</p><p><strong>布隆过滤器的大小以及哈希函数的个数怎么选择？</strong><br>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png"></p><h2 id="（24）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"><a href="#（24）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题" class="headerlink" title="（24） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"></a>（24） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</h2><h2 id="（25）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"><a href="#（25）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）" class="headerlink" title="（25）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"></a>（25）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 评测题目:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFOQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// isFull</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        unique_lock&lt;mutex&gt;&lt;/ mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">        <span class="keyword">while</span> (flag == <span class="literal">true</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        end = (end + <span class="number">1</span>) % initCap;</span><br><span class="line">        vec[end] = v;</span><br><span class="line">        cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unique_lock&lt;mutex&gt;&lt;/ mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">        <span class="keyword">if</span> (start != end) &#123;</span><br><span class="line">            <span class="type">int</span> val = vec[start];</span><br><span class="line">            start = (start + <span class="number">1</span>) % initCap;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            cv.<span class="built_in">notifyall</span>();</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            cv.<span class="built_in">notifyall</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(initCap, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是面试时写的，并没有运行，也许有错误，请客观参考</p><h2 id="（26）位图排序"><a href="#（26）位图排序" class="headerlink" title="（26）位图排序"></a>（26）位图排序</h2><p><a href="https://blog.csdn.net/songzitea/article/details/8759635">位图排序</a></p><h1 id="8-智力题"><a href="#8-智力题" class="headerlink" title="8. 智力题"></a>8. 智力题</h1><h2 id="（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"><a href="#（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）" class="headerlink" title="（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"></a>（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）</h2><ul><li>（给定了楼层数和鸡蛋数的情况）二分法+线性查找  从100&#x2F;2&#x3D;50楼扔起，如果破了就用另一个从0扔起直到破。如果没破就从50&#x2F;2&#x3D;25楼扔起，重复。</li><li>动态规划</li></ul><h2 id="（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"><a href="#（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠" class="headerlink" title="（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"></a>（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠</h2><p>用二进制的思路解决问题。2的十次方是1024，使用十只小鼠喝一次即可。方法是先将每瓶水编号，同时10个小鼠分别表示二进制中的一个位。将每瓶水混合到水瓶编号中二进制为1的小鼠对应的水中。喝完后统计，将死亡小鼠对应的位置为1，没死的置为0，根据死亡小鼠的编号确定有毒的是哪瓶水，如0000001010表示10号水有毒。</p><h2 id="（5）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"><a href="#（5）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿" class="headerlink" title="（5） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"></a>（5） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿</h2><p>寻找每个回合固定的拿取模式。最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。关键是第一次我必须先手拿（100%6&#x3D;4）本（这不算在第一回合里面）。</p><h2 id="（6）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"><a href="#（6）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。" class="headerlink" title="（6） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"></a>（6） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。</h2><p>碰到就当没发生，继续走，相当于碰到的两个蚂蚁交换了一下身体。其实就是每个蚂蚁从当前位置一直走直到停止的总距离或者时间。</p><h2 id="（7）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"><a href="#（7）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶" class="headerlink" title="（7） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"></a>（7） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶</h2><p>拿走3瓶，换回1瓶，相当于减少2瓶。但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4&#x3D;996，996&#x2F;2&#x3D;498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1&#x3D;1499瓶。</p><h2 id="（8）在24小时里面时针分针秒针可以重合几次"><a href="#（8）在24小时里面时针分针秒针可以重合几次" class="headerlink" title="（8）在24小时里面时针分针秒针可以重合几次"></a>（8）在24小时里面时针分针秒针可以重合几次</h2><p>24小时中时针走2圈，而分针走24圈，时针和分针重合24-2&#x3D;22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次</p><h2 id="（9）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"><a href="#（9）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？" class="headerlink" title="（9） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"></a>（9） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？</h2><p>至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；<br>第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；</p><h2 id="（10）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"><a href="#（10）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？" class="headerlink" title="（10） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"></a>（10） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？</h2><p>砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y &#x3D; 550 - x，第y组就是轻的那组</p><h2 id="（11）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？"><a href="#（11）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？" class="headerlink" title="（11）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？"></a>（11）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</h2><p>思路：由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。<br>记住下面这个式子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandNN= N( RandN()-1 ) + RandN() ;// 生成1到N^2之间的随机数</span><br><span class="line">可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度，RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙</span><br></pre></td></tr></table></figure><p>比如<code> Rand25= 5( Rand5()-1 ) + Rand5()</code>可以生成1到25之间的随机数。我们可以只要1到21（3*7）之间的数字，所以可以这么写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rand7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">21</span>) &#123;</span><br><span class="line">        x = <span class="number">5</span> * (<span class="built_in">rand5</span>() - <span class="number">1</span>) + <span class="built_in">rand5</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">7</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（12）赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"><a href="#（12）赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？" class="headerlink" title="（12）赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"></a>（12）赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？</h2><ul><li>第一次，分成5个赛道ABCDE，每个赛道5匹马，每个赛道比赛一场，每个赛道的第12345名记为 A1,A2,A3,A4,A5  B1,B2,B3,B4,B5等等，这一步要赛5场。 </li><li>第二次，我们将每个赛道的前三名，共15匹。分成三组，然后每组进行比赛。这一步要赛3场。</li><li>第三次，我们取每组的前三名。共9匹，第一名赛道的马编号为1a,1b,1c，第二名赛道的马编号为2a,2b,2c，第三名赛道的马编号为3a,3b,3c。这时进行分析，1a表示第一名里面的第一名，绝对是所有马中的第一，所以不用再比了。2c表示第二名的三匹里头的最后一匹，3b和3c表示第三名里面的倒数两匹，不可能是所有马里面的前三名，所以也直接排除，剩下1b,1c,2a,2b,,3a，共5匹，再赛跑一次取第一第二名，加上刚筛选出来的1a就是所有马里面的最快3匹了。这一步要赛1场。</li><li>所以一共是5+3+1&#x3D;9场。</li></ul><h2 id="（13）烧-香-绳子-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"><a href="#（13）烧-香-绳子-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？" class="headerlink" title="（13）烧 香&#x2F;绳子&#x2F;其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"></a>（13）烧 香&#x2F;绳子&#x2F;其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？</h2><p>（说了求15分钟，没说开始的15分钟还是结束的15分钟，这里是可以求最后的15分钟）点燃一根A，同时点燃另一根B的两端，当另一根B烧完的时候就是半小时，这是再将A的另一端也点燃，从这时到A燃烧完就正好15分钟。</p><h2 id="（13）掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"><a href="#（13）掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）" class="headerlink" title="（13）掰巧克力问题 NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"></a>（13）掰巧克力问题 N<em>M块巧克力，每次掰一块的一行或一列，掰成1</em>1的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）</h2><p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有N*M块，所以要掰N*M-1次，-1是因为最开始的一块是不用算进去的。</p><p>每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1&#x3D;999场。</p><h1 id="9-大数据（暂时不用）"><a href="#9-大数据（暂时不用）" class="headerlink" title="9. 大数据（暂时不用）"></a>9. 大数据（暂时不用）</h1><h2 id="1-介绍一下Hadoop"><a href="#1-介绍一下Hadoop" class="headerlink" title="1. 介绍一下Hadoop"></a>1. 介绍一下Hadoop</h2><p>Hadoop是一套大数据解决方案，提供了一套分布式的系统基础架构，包括HDFS，MapReduce和YARN。</p><ul><li>HDFS提供分布式的数据存储</li><li>MapReduce负责进行数据运算 </li><li>YARN负责任务调度</li></ul><p>HDFS是主从架构的，包括namenode，secondarynamenode和datanode。datanode负责存储数据，namenode负责管理HDFS的目录树和文件元信息。<br><br>MapReduce包括jobtracker,tasktracker和client。Jobtracker负责进行资源调度和作业监控。tasktracker会周期性的通过心跳向jobtracker汇报资源使用情况。</p><h2 id="2-说一下MapReduce的运行机制"><a href="#2-说一下MapReduce的运行机制" class="headerlink" title="2. 说一下MapReduce的运行机制"></a>2. 说一下MapReduce的运行机制</h2><p>MapReduce包括输入分片、map阶段、combine阶段、shuffle阶段和reduce阶段。分布式计算框架包括client，jobtracker和tasktracker和调度器。</p><ul><li>输入分片阶段，mapreduce会根据输入文件计算分片，每个分片对应一个map任务</li><li>map阶段会根据mapper方法的业务逻辑进行计算，映射成键值对</li><li>combine阶段是在节点本机进行一个reduce，减少传输结果对带宽的占用</li><li>shuffle阶段是对map阶段的结果进行分区，排序，溢出然后写入磁盘。将map端输出的无规则的数据整理成为有一定规则的数据，方便reduce端进行处理，有点像洗牌的逆过程。  <a href="https://blog.csdn.net/ASN_forever/article/details/81233547">https://blog.csdn.net/ASN_forever/article/details/81233547</a></li><li>reduce阶段是根据reducer方法的业务逻辑进行计算，最终结果会存在hdfs上。</li></ul><h2 id="3-介绍一下kafka"><a href="#3-介绍一下kafka" class="headerlink" title="3. 介绍一下kafka"></a>3. 介绍一下kafka</h2><p><a href="https://blog.csdn.net/qq_29186199/article/details/80827085">https://blog.csdn.net/qq_29186199/article/details/80827085</a></p><p><a href="https://blog.csdn.net/student__software/article/details/81486431">https://blog.csdn.net/student__software/article/details/81486431</a></p><p>kafka是一个分布式消息队列，包括producer、broker和consumer。kafka会对每个消息根据topic进行归类，每个topic又会分成多个partition，消息会根据先进先出的方式存储。消费者通过offset进行消费。 </p><p>kafka的特点是吞吐量高，可以进行持久化，高可用。</p><h2 id="4-为什么kafka吞吐量高？-介绍一下零拷贝"><a href="#4-为什么kafka吞吐量高？-介绍一下零拷贝" class="headerlink" title="4. 为什么kafka吞吐量高？&#x2F;介绍一下零拷贝"></a>4. 为什么kafka吞吐量高？&#x2F;介绍一下零拷贝</h2><p>kafka吞吐量高是因为一个利用了磁盘顺序读写的特性，速度比随机读写要快很多，另一个是使用了零拷贝，数据直接在内核进行输入和输出，减少了用户空间和内核空间的切换。</p><p>零拷贝：传统文件读取并发送至网络的步骤是：先将文件从磁盘拷贝到内核空间，然后内核空间拷贝到用户空间的缓冲区，再从用户空间拷贝到内核空间的socket缓冲区，最后拷贝到网卡并发送。而零拷贝技术是先将文件从磁盘空间拷贝到内核缓冲区，然后直接拷贝至网卡进行发送，减少了重复拷贝操作。</p><h2 id="5-介绍一下spark"><a href="#5-介绍一下spark" class="headerlink" title="5. 介绍一下spark"></a>5. 介绍一下spark</h2><p><a href="https://blog.csdn.net/u011204847/article/details/51010205">https://blog.csdn.net/u011204847/article/details/51010205</a></p><p>spark是一个通用内存并行计算框架。它可以在内存中对数据进行计算，效率很高，spark的数据被抽象成RDD（弹性分布式数据集）并且拥有DAG执行引擎，兼容性和通用性很好。可以和Hadoop协同工作。</p><h2 id="6-介绍一下spark-streaming"><a href="#6-介绍一下spark-streaming" class="headerlink" title="6. 介绍一下spark-streaming"></a>6. 介绍一下spark-streaming</h2><p><a href="https://blog.csdn.net/yu0_zhang0/article/details/80569946">https://blog.csdn.net/yu0_zhang0/article/details/80569946</a></p><p>spark-streaming是spark的核心组件之一。主要提供高效的流计算能力。spark-streaming的原理是将输入数据流以时间片进行拆分，然后经过spark引擎以类似批处理的方式处理每个时间片数据。</p><p>spark-streaming将输入根据时间片划分成一段一段的Dstream（也就是离散数据流），然后将每一段数据转换成RDD进行操作。 </p><h2 id="7-spark的transformation和action有什么区别"><a href="#7-spark的transformation和action有什么区别" class="headerlink" title="7. spark的transformation和action有什么区别"></a>7. spark的transformation和action有什么区别</h2><p>spark的算子分成transformation和action两类</p><ul><li>transformation是变换算子，这类算子不会触发提交，是延迟执行的。也就是说执行到transformation算子的时候数据并没有马上进行计算，只是记住了对RDD的逻辑操作 </li><li>action算子是执行算子，会出发spark提交作业，并将数据输出到spark</li></ul><h2 id="8-spark常用的算子说几个"><a href="#8-spark常用的算子说几个" class="headerlink" title="8. spark常用的算子说几个"></a>8. spark常用的算子说几个</h2><p>spark的算子分为两类：transformation和action</p><p>常用的transformation算子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union 求并集</span></span><br><span class="line"><span class="keyword">val</span> rdd8 = rdd6.union(rdd7)</span><br><span class="line"></span><br><span class="line"><span class="comment">// intersection 求交集 </span></span><br><span class="line"><span class="keyword">val</span> rdd9 = rdd6.intersection(rdd7)</span><br><span class="line"></span><br><span class="line"><span class="comment">// join 将rdd进行聚合连接，类似数据库的join </span></span><br><span class="line"><span class="keyword">val</span> rdd3 = rdd1.join(rdd2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map flatMap mapPartition 传入一个函数对数据集中的每一个数据进行操作 </span></span><br><span class="line"><span class="keyword">val</span> arr1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> arr2 = rdd1.map(_+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// countByKey reduceByKey partitionByKey 统计每个key有多少个键值对 </span></span><br></pre></td></tr></table></figure><p>常用的action算子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce 按照一定的方法将元素进行合并 </span></span><br><span class="line"><span class="keyword">val</span> rdd2 = rdd1.reduce(_+_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// collect 将RDD转换为数组</span></span><br><span class="line">rdd1.collect</span><br><span class="line"></span><br><span class="line"><span class="comment">// top 返回最大的k个元素</span></span><br><span class="line">rdd1.top(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="9-如何保证kafka的消息不丢失"><a href="#9-如何保证kafka的消息不丢失" class="headerlink" title="9. 如何保证kafka的消息不丢失"></a>9. 如何保证kafka的消息不丢失</h2><p><a href="https://blog.csdn.net/liudashuang2017/article/details/88576274">https://blog.csdn.net/liudashuang2017/article/details/88576274</a></p><p>我们可以从三个方面保证kafka不丢失消息</p><ul><li>首先从producer生产者方面，为send()方法注册一个回调函数，可以得知消息发送有没有成功；将重试次数retrie设置为3；设置acks参数为all，当消息被写入所有同步副本之后才算发送成功。</li><li>在consumer消费者方面，关闭自动提交；</li><li>在broker集群方面，设置复制系数replica.factor为大于等于3</li></ul><h2 id="10-kafka如何选举leader"><a href="#10-kafka如何选举leader" class="headerlink" title="10. kafka如何选举leader"></a>10. kafka如何选举leader</h2><p>首先启动的broker在zookeeper中创建一个临时节点并让自己称为leader，其他的节点会创建watch对象进行监听并成为follower，当broker宕机的时候，其他follower会尝试创建这个临时节点，但是只有一个能够创建成功，创建成功的broker就会成为leader。</p><h2 id="11-说下spark中的宽依赖和窄依赖"><a href="#11-说下spark中的宽依赖和窄依赖" class="headerlink" title="11. 说下spark中的宽依赖和窄依赖"></a>11. 说下spark中的宽依赖和窄依赖</h2><p><a href="https://blog.csdn.net/a1043498776/article/details/54889922">https://blog.csdn.net/a1043498776/article/details/54889922</a></p><ul><li>宽依赖：指子RDD的分区依赖于父RDD的所有分区，举例：groupbykey,join</li><li>窄依赖：指父RDD的每个分区被最多一个子RDD的分区所依赖,举例：map，filter<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/SouthEast.png"></li></ul><h2 id="12-说下spark中stage是依照什么划分的"><a href="#12-说下spark中stage是依照什么划分的" class="headerlink" title="12. 说下spark中stage是依照什么划分的"></a>12. 说下spark中stage是依照什么划分的</h2><p><a href="https://zhuanlan.zhihu.com/p/57124273">https://zhuanlan.zhihu.com/p/57124273</a></p><p>spark中的stage其实是一组并行的任务，spark会将多个RDD根据依赖关系划分成有向无环图DAG，DAG会被划分成多个stage，划分的依据是RDD之间的宽窄依赖。遇到宽依赖就划分stage。因为宽依赖与窄依赖的区别之一就是宽依赖会发生shuffle操作，所以也可以说stage的划分依据是是否发生shuffle操作。</p><h2 id="13-spark的内存管理是怎样的"><a href="#13-spark的内存管理是怎样的" class="headerlink" title="13. spark的内存管理是怎样的"></a>13. spark的内存管理是怎样的</h2><p><a href="https://www.jianshu.com/p/4f1e551553ae">https://www.jianshu.com/p/4f1e551553ae</a> </p><p><a href="https://www.cnblogs.com/wzj4858/p/8204282.html">https://www.cnblogs.com/wzj4858/p/8204282.html</a></p><p>spark的内存包括静态内存管理和统一内存管理两种机制。静态内存管理中存储和执行两块内存区域是分开的，统一内存管理中两块内存之间可以相互借用<br></p><ul><li>静态内存管理：静态内存管理机制下堆内内存包括安全内存，存储内存，shuffle内存和unroll内存</li></ul><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/spark%E5%86%85%E5%AD%98%E4%B8%80.png"></p><ul><li>统一内存管理：统一内存管理机制下内存分为spark内存，用户内存和保留内存三部分。用户内存存放用户代码逻辑和自定义数据结构等，保留内存存放的是spark的内部对象和逻辑。<br><img src="https://upload-images.jianshu.io/upload_images/195230-f119edabb5683f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></li></ul><h2 id="14-spark的容错机制是什么样的"><a href="#14-spark的容错机制是什么样的" class="headerlink" title="14. spark的容错机制是什么样的"></a>14. spark的容错机制是什么样的</h2><p><a href="https://blog.csdn.net/dengxing1234/article/details/73613484">https://blog.csdn.net/dengxing1234/article/details/73613484</a></p><p>spark的容错机制是通过血统（lineage）和checkpoint来实现的 。</p><ul><li>RDD的lineage可以看作是一个重做日志（redo log）记录的是它粗粒度上的transformation操作。当rdd的分区数据丢失时，它可以根据lineage重新计算来恢复数据。 在窄依赖上可以直接计算父RDD的节点数据进行恢复，在宽依赖上则要等到父RDD所有数据计算完后并将结果shuffle到子RDD上才能完成恢复。</li><li>如果DAG中的lineage过长，或者在宽依赖上进行checkpoint的收益更大，就会使用checkpoint进行容错，将RDD写入磁盘进行持久化存储，如果节点数据丢失，就从磁盘读取数据进行恢复。</li></ul><h1 id="10-HR面"><a href="#10-HR面" class="headerlink" title="10. HR面"></a>10. HR面</h1><h2 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h2><p>（HR面试的自我介绍可以侧重软实力部分，项目技术方面介绍可以适当少一些）</p><h2 id="2-项目中遇到的最大难点"><a href="#2-项目中遇到的最大难点" class="headerlink" title="2. 项目中遇到的最大难点"></a>2. 项目中遇到的最大难点</h2><ul><li><p>在项目中曾经遇到了新的框架不知道该如何上手的问题，以及面对新的概念，新的技术不知道从何学起。解决的办法是在官网寻找说明文档和demo，按照说明文档上的内容一步步了解，以及咨询身边有用过这个框架的同学，或者在CSDN上寻找相关博客。</p></li><li><p>项目的时间比较紧迫，没有那么多的时间可以用。解决方法是把还没有完成的项目分一个轻重缓急，在有限的时间里，先做重要而且紧急的，然后完成紧急的，再做重要的。利用轻重缓急做一个取舍。</p></li></ul><h2 id="3-项目中的收获"><a href="#3-项目中的收获" class="headerlink" title="3. 项目中的收获"></a>3. 项目中的收获</h2><p>一个是了解了相关框架的使用方法（比如Dataframe的使用，xgboost的使用等等），这些框架或者技术可以在以后的开发中使用到。和对自己开发能力的锻炼。</p><p>一个是锻炼了与他人的交流能力，因为在团队项目里经常会跟别人汇报自己的想法和进度，同时也会跟其他成员沟通模块之间的交互，所以在这个过程中对自己的表达能力和理解能力都是一个很大的提升。</p><h2 id="4-可以实习的时间，实习时长"><a href="#4-可以实习的时间，实习时长" class="headerlink" title="4. 可以实习的时间，实习时长"></a>4. 可以实习的时间，实习时长</h2><p>一定要往长了说！半年起步，最好七八个月，因为实习生是可以随时跑路的。而且实习时间越长HR越青睐。</p><h2 id="5-哪里人"><a href="#5-哪里人" class="headerlink" title="5. 哪里人"></a>5. 哪里人</h2><h2 id="6-说一下自己的性格"><a href="#6-说一下自己的性格" class="headerlink" title="6. 说一下自己的性格"></a>6. 说一下自己的性格</h2><p>我是比较内向谨慎的人，平时做的多说的少。比较善于总结，在与人交流的时候更倾向于倾听别人的意见后才发言。并且别人都说我办事认真靠谱。</p><h2 id="7-你的优缺点是什么"><a href="#7-你的优缺点是什么" class="headerlink" title="7. 你的优缺点是什么"></a>7. 你的优缺点是什么</h2><p>我的缺点是容易在一些细节的地方花费太多的时间，有时候过分追求细节。并且我的实习经验比较缺乏，对于实际项目的业务流程和工作流程不是很了解。（所以我打算通过实习来熟悉实际的软件开发的流程和技术。）</p><p>我的优点是责任心比较强，做事比较负责，在校期间我负责的大创项目进展很顺利，我经常组织组员们进行讨论和推进项目的开发，最后这个项目得到了92的评分，在同级别里面是比较高的。</p><h2 id="8-有什么兴趣爱好，画的怎么样-球打的如何-游戏打的怎么样"><a href="#8-有什么兴趣爱好，画的怎么样-球打的如何-游戏打的怎么样" class="headerlink" title="8. 有什么兴趣爱好，画的怎么样&#x2F;球打的如何&#x2F;游戏打的怎么样"></a>8. 有什么兴趣爱好，画的怎么样&#x2F;球打的如何&#x2F;游戏打的怎么样</h2><p>平时的爱好是画画打游戏，在CSDN写写博客，还有就是看书，我很喜欢学到新知识掌握新技能的感觉。</p><h2 id="9-看过最好的一本书是什么"><a href="#9-看过最好的一本书是什么" class="headerlink" title="9. 看过最好的一本书是什么"></a>9. 看过最好的一本书是什么</h2><p>技术类：编程之美 机器学习西瓜书 STL源码剖析 剑指offer C++primer</p><p>非技术类：明朝那些事儿 香水（聚斯金德） 解忧杂货店 人类简史 沉默的大多数 与时间做朋友（李笑来） 千年历史千年诗</p><h2 id="10-学习技术中有什么难点"><a href="#10-学习技术中有什么难点" class="headerlink" title="10. 学习技术中有什么难点"></a>10. 学习技术中有什么难点</h2><h2 id="11-怎么看待加班"><a href="#11-怎么看待加班" class="headerlink" title="11. 怎么看待加班"></a>11. 怎么看待加班</h2><p>我觉得 任何一家单位都有可能要加班。如果自己的工作没有按时完成，那自觉加班是理所当然的，当然，自己要不断提高工作效率，避免这种原因导致的加班。如果遇到紧急任务或者突发状况时，为了顺利配合团队完成任务，我会尽自己所能加班共同完成。</p><h2 id="12-觉得深圳怎么样（或者其他地点）"><a href="#12-觉得深圳怎么样（或者其他地点）" class="headerlink" title="12. 觉得深圳怎么样（或者其他地点）"></a>12. 觉得深圳怎么样（或者其他地点）</h2><h2 id="13-遇见过最大的挫折是什么，怎么解决的"><a href="#13-遇见过最大的挫折是什么，怎么解决的" class="headerlink" title="13. 遇见过最大的挫折是什么，怎么解决的"></a>13. 遇见过最大的挫折是什么，怎么解决的</h2><h2 id="14-职业规划"><a href="#14-职业规划" class="headerlink" title="14. 职业规划"></a>14. 职业规划</h2><p>在工作的第一个阶段，先尽快适应工作的环境，包括开发环境开发工具和工作流程等，把自己负责的部分快速的完成，不能出差错。第二个阶段要熟悉整个项目的业务流程，所有模块的结构和依赖关系，知道每个模块为什么要这么设计，以及它们的实现细节。第三个阶段要培养独立设计一个项目的能力，可以独立或者在别人的协作下设计项目的模块分工和架构。</p><p>在工作和项目中多写博客或者笔记，积累技术影响力，将经验总结成文档。同时与同事搞好关系，尝试培养领导能力和组织能力。</p><h2 id="15-目前的offer情况"><a href="#15-目前的offer情况" class="headerlink" title="15. 目前的offer情况"></a>15. 目前的offer情况</h2><p>可以如实说</p><h2 id="16-你最大的优势和劣势是什么"><a href="#16-你最大的优势和劣势是什么" class="headerlink" title="16. 你最大的优势和劣势是什么"></a>16. 你最大的优势和劣势是什么</h2><h2 id="17-介绍在项目里面充当的角色"><a href="#17-介绍在项目里面充当的角色" class="headerlink" title="17. 介绍在项目里面充当的角色"></a>17. 介绍在项目里面充当的角色</h2><h2 id="18-介绍一下本科获得的全国赛奖项的情况"><a href="#18-介绍一下本科获得的全国赛奖项的情况" class="headerlink" title="18. 介绍一下本科获得的全国赛奖项的情况"></a>18. 介绍一下本科获得的全国赛奖项的情况</h2><h2 id="19-最有成就感的事情-最骄傲的一件事情"><a href="#19-最有成就感的事情-最骄傲的一件事情" class="headerlink" title="19. 最有成就感的事情&#x2F;最骄傲的一件事情"></a>19. 最有成就感的事情&#x2F;最骄傲的一件事情</h2><h2 id="20-在实验室中担任什么角色，参加的XXX能聊聊吗"><a href="#20-在实验室中担任什么角色，参加的XXX能聊聊吗" class="headerlink" title="20. 在实验室中担任什么角色，参加的XXX能聊聊吗"></a>20. 在实验室中担任什么角色，参加的XXX能聊聊吗</h2><h2 id="21-如何学习的"><a href="#21-如何学习的" class="headerlink" title="21.如何学习的"></a>21.如何学习的</h2><h2 id="22-用两个词来形容自己"><a href="#22-用两个词来形容自己" class="headerlink" title="22. 用两个词来形容自己"></a>22. 用两个词来形容自己</h2><p>踏实 认真</p><h1 id="看阿秀补充知识——不需要背，相同跳过，重要记录，其他了解"><a href="#看阿秀补充知识——不需要背，相同跳过，重要记录，其他了解" class="headerlink" title="看阿秀补充知识——不需要背，相同跳过，重要记录，其他了解"></a>看阿秀补充知识——不需要背，相同跳过，重要记录，其他了解</h1><ul><li><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</strong></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++笔记</title>
      <link href="/2023/07/25/Effective%20C++/"/>
      <url>/2023/07/25/Effective%20C++/</url>
      
        <content type="html"><![CDATA[<h1 id="条款0：导读"><a href="#条款0：导读" class="headerlink" title="条款0：导读"></a>条款0：导读</h1><ul><li>每个函数的声明揭示其签名式（signature），也就是参数和返回类型</li><li>除非有一个好理由允许构造函数被用于隐式类型转换，否则把它<strong>声明为explicit</strong></li></ul><h1 id="1-让自己习惯C"><a href="#1-让自己习惯C" class="headerlink" title="1. 让自己习惯C++"></a>1. 让自己习惯C++</h1><h2 id="条款1：视C-为一个语言联邦"><a href="#条款1：视C-为一个语言联邦" class="headerlink" title="条款1：视C++为一个语言联邦"></a>条款1：视C++为一个语言联邦</h2><ul><li><p>C++语言的四个层次：</p><ul><li>C。没有C++的面向对象，没有模板，没有异常，没有重载等。</li><li>Object-Oriented C++。这部分也就是C with Classes。classes、封装、继承、多态、虚函数。这部分是面向对象的特性。</li><li>Template C++。这部分是C++的泛型编程部分。这部分带来的是template metaprogramming，也就是所谓的模板元编程。</li><li>STL。STL是个template程序库。它对容器、迭代器、算法及函数对象的规约，并且是以templates及程序库的方式构建出来。</li></ul><p>每个层次应该有自己的最佳实践。例如对于C层次，传入函数最佳的实践应该是传入值，而不是指针，而对于C with classes层次，则以传递引用为最佳的实践。</p></li></ul><h2 id="条款2：尽量以const，enum，inline代替-define"><a href="#条款2：尽量以const，enum，inline代替-define" class="headerlink" title="条款2：尽量以const，enum，inline代替 #define"></a>条款2：尽量以const，enum，inline代替 #define</h2><blockquote><p>宁可以编译器代替预处理器</p></blockquote><ul><li>对于单纯常量，最好使用 const 对象或 enums 替代 #defines</li><li>对于形似函数的宏（macros），最好使用 inline 函数替换 #defines</li></ul><ul><li><p>对于全局的，用define定义的值，在预处理的时候会被替换成相应的值，这对于调试的符号表不利。并且用define的符号在多处使用都会要替换，会使编译生成的代码量变大。</p></li><li><p>对于class的常量，为了只提供一份定义，一般用static const。用define无法创建一个class专属常量，因为#define并不重视作用于，一旦宏被定义，它就在其后的编译过程中有效。有时候，<strong>为了不让获取常量的定义地址，则可以用enum来代替#define</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">enum &#123;NumTurns = 5&#125;;</span><br><span class="line">int scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>有时候需要用模板函数来代替宏</p><p>宏的一些副作用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span><br><span class="line">int a = 5, b = 0;</span><br><span class="line">CALL_WITH_MAX(++a, b); //a被累加两次</span><br><span class="line">CALL_WITH_MAX(++a, b+10); //a被累加一次</span><br></pre></td></tr></table></figure><p>这时候可以用模板函数来代替</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void callWithMax(const T &amp;a, const T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">  f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了consts、enums和inlines，我们对预处理器的需求降低了，但是不等于没有。#include仍然是必需品，而#ifdef&#x2F;#ifndef也继续扮演控制编译的重要角色。</p></li></ul><ul><li>Static 成员必须在 class 定义式之外被定义（除非它是 const 而且是整数型</li></ul><h2 id="条款3：-尽可能使用const"><a href="#条款3：-尽可能使用const" class="headerlink" title="条款3：&#x3D;&#x3D;尽可能使用const&#x3D;&#x3D;"></a>条款3：&#x3D;&#x3D;尽可能使用const&#x3D;&#x3D;</h2><blockquote><p>加了mutable的成员变量可能总是被更改，即使在const成员函数内</p></blockquote><ul><li><p>将某些东西声明成const可帮助编译器侦测出错误用法。const可被施加于任何作用域的对象、函数参数、函数返回类型、成员函数本体</p></li><li><p>编译器强制实施 bitwise constness，但你编写程序时**应该使用 “概念上的常量性” **（conceptual constness）</p></li><li><p>当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用 const 版本<strong>避免代码重复</strong></p></li><li><p>const 修饰的 operator* 的<strong>返回类型</strong>，可以阻止客户因 ”用户自定义类型“而犯错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a * b = c) ... <span class="comment">//原意其实是做一次比较操作</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="条款4：确定对象被使用前已被初始化"><a href="#条款4：确定对象被使用前已被初始化" class="headerlink" title="条款4：确定对象被使用前已被初始化"></a>条款4：确定对象被使用前已被初始化</h2><blockquote><p>编译单元：指产出单一目标文件（single object file）的那些源码。</p><p>基本上它时单一源代码文件加上其所含入的头文件（#include files）</p></blockquote><ul><li>为内置型对象进行手动初始化，因为C++不保证初始化它们</li><li>构造函数最好使用成员初值列（ member initialization list ），而不要在构造函数本体内使用赋值操作（ assignment )。初值列列出的成员变量，其排序次序应该和它们在class中的声明次序相同</li><li>为免除 “跨编译单元之<strong>初始化次序</strong>” 问题，请以 local static 对象替换 non-local static 对象<ul><li>local static：在函数体内定义初始化static对象，然后返回该对象引用，这个是单例模式一个常见的实现手法。</li><li>C++对于 “定义在不同编译单元内的 non-local static 对象” 的初始化次序并无明确定义</li></ul></li></ul><h1 id="2-构造-析构-赋值运算"><a href="#2-构造-析构-赋值运算" class="headerlink" title="2. 构造&#x2F;析构&#x2F;赋值运算"></a>2. 构造&#x2F;析构&#x2F;赋值运算</h1><h2 id="条款5：了解C-默默编写并调用哪些函数"><a href="#条款5：了解C-默默编写并调用哪些函数" class="headerlink" title="条款5：了解C++默默编写并调用哪些函数"></a>条款5：了解C++默默编写并调用哪些函数</h2><blockquote><p>内含 reference 成员和 const 成员，编译器会拒绝生成赋值构造函数</p><p>如果某个base classes 将 copy assignment 操作符声明为 private 其 derived classes 编译器会拒绝生成赋值构造函数</p></blockquote><ul><li>编译器可以暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符，以及析构函数</li></ul><h2 id="条款6：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款6：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款6：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款6：若不想使用编译器自动生成的函数，就该明确拒绝</h2><ul><li>为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为private并且不予实现。使用想<strong>Uncopyable</strong>这样的base class也是一种做法<ul><li><strong>Uncopyable</strong>：derived class 继承 Uncopyable 来把自身的默认拷贝&#x2F;赋值函数给禁止（因为 Uncopyable 的拷贝&#x2F;复制构造函数时 private 的）</li></ul></li></ul><h2 id="条款7：为多态基类声明-virtual-析构函数"><a href="#条款7：为多态基类声明-virtual-析构函数" class="headerlink" title="条款7：为多态基类声明 virtual 析构函数"></a>条款7：为多态基类声明 virtual 析构函数</h2><ul><li><p>必须为pure virtual 析构函数提供定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AWOV</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AWOV</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">AWOV::~<span class="built_in">AWOV</span>()&#123; &#125;<span class="comment">//pure virtual析构函数的定义</span></span><br></pre></td></tr></table></figure></li><li><p>polymorphic（带多态性质）base classes 应该声明一个 virtual 析构函数。如果 class 带有任何 virtual 函数，它就应该拥有一个virtual 析构函数</p></li><li><p>Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性质（polymorphically），就不应该声明为 virtual 函数</p></li></ul><h2 id="条款8：-别让异常逃离析构函数"><a href="#条款8：-别让异常逃离析构函数" class="headerlink" title="条款8：&#x3D;&#x3D;别让异常逃离析构函数&#x3D;&#x3D;"></a>条款8：&#x3D;&#x3D;别让异常逃离析构函数&#x3D;&#x3D;</h2><ul><li><p>析构函数绝对不要突出异常。如果一个被析构函数调用的函数可能抛出异常，<strong>析构函数应该捕捉任何异常</strong>，然后吞下它们（不传播）或结束程序。</p></li><li><p>如果用户需要对某个操作函数运行期间抛出异常<strong>做出反应</strong>，那么 class 应该<strong>提供一个普通函数</strong>（下文提供的close()）（而非在析构函数中）执行该操作</p></li><li><p>假设一个数据库连接的类，为了防止客户忘记关闭连接，往往会在析构的时候尝试关闭连接，例如</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class DBCONN</span><br><span class="line">&#123;</span><br><span class="line">~DBCONN()</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">  db.close();</span><br><span class="line">  &#125;catch </span><br><span class="line">  &#123;</span><br><span class="line">  //记下错误，继续执行或者调用abort，终止程序</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">DB db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>这种处理方式的缺点是，客户没有太多选择，要么是abort终止程序，要么是继续执行。</p></li><li><p>为了让客户有选择，可以<strong>单独提供一个close函数</strong>，让用户自己处理异常。如果用户决定自己不处理，那么析构函数的时候再采用一个默认的方式来处理。</p></li></ul><h2 id="条款9：绝不在构造函数和析构函数过程中调用-virtual-函数"><a href="#条款9：绝不在构造函数和析构函数过程中调用-virtual-函数" class="headerlink" title="条款9：绝不在构造函数和析构函数过程中调用 virtual 函数"></a>条款9：绝不在构造函数和析构函数过程中调用 virtual 函数</h2><ul><li><p>在构造和析构期间不要调用 virtual 函数，因为这类调用从不下降至 derived class（比起当前执行构造函数和析构函数的那层）</p></li><li><p>由于无法使用 virtual 函数从 base classes 向下调用，在构造期间你可以籍由“令 derived classes 将必要信息向上传递至 base classes 构造函数”替换之而加以弥补</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//virtual logTranscation(...) const = 0; 在base classes中调用无法向下传递</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Transcation</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logTranscation</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">Transcation::<span class="built_in">Transcation</span>(<span class="type">const</span> std::string&amp; logInfo)&#123;</span><br><span class="line">...</span><br><span class="line">logTranscation</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTranscation</span>: <span class="keyword">public</span> Transcation&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BuyTrancation</span>( parameters );</span><br><span class="line">: <span class="built_in">Transcation</span>(<span class="built_in">createLogString</span>( parameters ))<span class="comment">//将log信息传递给 base classes 构造函数</span></span><br><span class="line">&#123; ... &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> std::string <span class="title">createLogString</span><span class="params">( parameters )</span></span>; <span class="comment">//先于其他初始化，所以Transcation的构造函数在之后</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在构造函数中，调用构造函数的顺序是基类-&gt;子类，当基类在构造的时候，子类的部分还没有开始构造，这时候，如果调用虚函数，<strong>只会调用基类版本</strong>的，不符合虚函数的语义。</p></li><li><p>在析构函数中，调用析构函数的顺序是子类-&gt;基类，当基类在析构的时候，子类的部分已经析构完成，这时候，如果调用虚函数，同样<strong>只会调用基类版本</strong>的，不符合虚函数的语义。</p></li></ul><h2 id="条款10：令-operator-返回一个-reference-to-this"><a href="#条款10：令-operator-返回一个-reference-to-this" class="headerlink" title="条款10：令 operator&#x3D; 返回一个 reference to *this"></a>条款10：令 operator&#x3D; 返回一个 <em>reference to</em> *this</h2><ul><li>令赋值（assignment）操作符返回一个reference to *this</li></ul><h2 id="条款11：在-operator-中-处理“自我赋值“"><a href="#条款11：在-operator-中-处理“自我赋值“" class="headerlink" title="条款11：在 operator&#x3D; 中&#x3D;&#x3D;处理“自我赋值“&#x3D;&#x3D;"></a>条款11：在 operator&#x3D; 中&#x3D;&#x3D;处理“自我赋值“&#x3D;&#x3D;</h2><ul><li><p>确保当对象自我赋值时operator&#x3D; 有良好的行为。其中技术包括比较”来源对象“和”目标对象“的地址、精心周到的语句顺序、以及copy and swap</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//比较”来源对象“和”目标对象“的地址</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> = &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//证同测试（identity test），如果是自我赋值就不做任何事</span></span><br><span class="line"><span class="keyword">delete</span> pb;</span><br><span class="line">pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//精心周到的语句顺序</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Bitmap* pOring = pb;<span class="comment">//记住原先的pb</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);<span class="comment">//令pb指向 *pb的一个复件（副本）</span></span><br><span class="line">    <span class="keyword">delete</span> pOring;<span class="comment">//删除原先的pb</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//copy and swap</span></span><br><span class="line"><span class="comment">//————1————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>;<span class="comment">//交换*this和rhs的数据</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp;rhs)&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);<span class="comment">//temp离开作用域后自动释放了原来的pb</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//————2————</span></span><br><span class="line">Widget&amp; Widget::oprator=(Widget rhs)&#123;<span class="comment">//rhs是一份拷贝，相当于temp</span></span><br><span class="line"><span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定任何一个函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确</p></li></ul><h2 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h2><ul><li>Copying 函数应该确保复制 ”对象内的所有成员变量“ 以及 ”所有 base classes 成分“</li><li>不要尝试以某个 copying 函数 实现另一个 copying（比如赋值） 函数。应该将<strong>共同机能</strong>放进第三个函数中，并由两个copying函数共同调用</li></ul><h1 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3. 资源管理"></a>3. 资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><blockquote><p>RAII：Resource Acquisition Is Initialization</p><p>资源取得时机就是初始化时机</p></blockquote><ul><li>为防止资源泄露，请<strong>使用RAII对象</strong>，它们<strong>在构造函数中获得资源并在析构函数中释放资源</strong></li><li>两个常被使用的 RAII classes 分别是 tr1::shared_ptr 和 auto_ptr。前者通常是最佳选择，因为copy行为比较直观。若选择 auto_ptr，复制动作会使它（被复制物）指向 null</li></ul><h2 id="条款14：在资源管理类中小心-copying-行为"><a href="#条款14：在资源管理类中小心-copying-行为" class="headerlink" title="条款14：在资源管理类中小心 copying 行为"></a>条款14：在资源管理类中小心 copying 行为</h2><ul><li>复制 RAII 对象必须一并复制它管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为</li><li>普遍而常见的 RAII class copying 行为是：<strong>抑制 copying</strong>（继承 Uncopyable base classes）、施行引用计数法（reference counting）。不过其他行为也能被实现</li><li>引用计数法—&gt;shared_ptr：可以自定义删除器（客制化析构函数，例如析构操作是释放锁（解开）而不是将锁资源释放）</li><li>复制底部资源（heap上的）：需要进行**&#x3D;&#x3D;深度拷贝&#x3D;&#x3D;**，不论指针或其所指内存都会被复制出一个复件（避免重复delete资源）、</li><li>转移底部资源的所有权：确保RAII对象指向一个未加工的资源。即使复制，此时资源的拥有权从被复制物转移到目标物（auto_ptr）</li></ul><h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><ul><li><p>APIs往往要求访问原始资源（raw resources），所以每一个 RAII classes 应该提供一个 ”取得其所管理之资源“ 的办法</p></li><li><p>对原始资源的访问可能经由显示转换或隐式转换。一般而言<strong>显示转换比较安全</strong>，但<strong>隐式转换</strong>对客户<strong>比较方便</strong></p></li></ul><h2 id="条款16：成对使用-new-和-delete-时要采用相同形式"><a href="#条款16：成对使用-new-和-delete-时要采用相同形式" class="headerlink" title="条款16：成对使用 new 和 delete 时要采用相同形式"></a>条款16：成对使用 new 和 delete 时要采用相同形式</h2><ul><li><p>如果你在new表达式中使用[]，必须在相应的 delete 表达式中也使用[]。如果你在 new 表达式中不使用[]，一定不要在相应的 delete 表达式中使用[]</p><ul><li>动态分配的 arrays 可能包含额外的空间存放元素</li></ul></li><li><p>为避免诸如此类的错误，最好尽量不要对数组形式做 typedefs 动作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];<span class="comment">//每个人的地址有4行，每行都是一个string</span></span><br><span class="line">std::string *pa1 = <span class="keyword">new</span> AddressLines; <span class="comment">//注意，”new AddressLines“返回一个string*，就像”new string[4]“一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pa1； <span class="comment">//未定义</span></span><br><span class="line"><span class="keyword">delete</span> [] pa1; <span class="comment">//很好</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="条款17：-以独立语句将-newed-对象置入智能指针"><a href="#条款17：-以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款17：&#x3D;&#x3D;以独立语句将 newed 对象置入智能指针&#x3D;&#x3D;"></a>条款17：&#x3D;&#x3D;以独立语句将 newed 对象置入智能指针&#x3D;&#x3D;</h2><ul><li><p>以独立语句将 newed 对象存储于（置入）智能指针中。如果不这样做，<strong>一旦异常被抛出</strong>，有可能导致<strong>难以察觉的资源泄露</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());  <span class="comment">//shared_ptr的构造函数是explicit的</span></span><br><span class="line"><span class="comment">//new Widget一定在构造函数前发生，如果在调用new Widget之后，先调用了priority()，万一对priority()的调用导致异常，此时new Widget返回的指针将会遗失，引发资源泄漏</span></span><br><span class="line"></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;<span class="comment">//完成new Widget和调用pw的构造函数两步操作——独立语句</span></span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());<span class="comment">//和调用priority()分开</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4. 设计与声明"></a>4. 设计与声明</h1><h2 id="条款18：-让接口容易被正确使用，不易被误用"><a href="#条款18：-让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：&#x3D;&#x3D;让接口容易被正确使用，不易被误用&#x3D;&#x3D;"></a>条款18：&#x3D;&#x3D;让接口容易被正确使用，不易被误用&#x3D;&#x3D;</h2><ul><li><p>好的接口很容易被正确使用，不容易被勿用。你应该在你的所有接口中努力达成这些性质</p><ul><li><p>要设计不易被误用的接口</p></li><li><p>例如，要创建一个时间类型</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date(int month, int year, int day);</span><br></pre></td></tr></table></figure><ul><li><p>上面的接口就是容易被误用的接口，因为可能把年月日的顺序给搞错了。</p></li><li><p>可以给年月日分别设计一个类型，构造函数中传入对应的类型才能正确编译。</p></li></ul></li><li><p>”促进正确使用“ 的办法包括<strong>接口一致性</strong>（比如string，vector，list等通过调用相同名字的size()获取长度），以及与内置类型的行为兼容</p></li><li><p>”阻止误用“ 的办法包括<strong>建立新类型</strong>（12月份-&gt;Month::Dec()）、<strong>限制类型上的操作</strong>（比如opeator *的返回值类型为const），<strong>束缚对象值</strong>（例如返回智能指针，强制用户使用智能指针），以及<strong>消除客户的资源管理责任</strong>（将delete和其他操作<del>引用计数-1</del>封装起来给用户释放资源，如shared_ptr）</p></li><li><p>tr1::shared_ptr 支持<strong>定制性删除器</strong>（custom deleter）。这可<strong>防范DLL问题</strong>（new&#x2F;delete这对操作在不同动态链接库中，shared_ptr会自动调用本模块的delete函数），可被用来<strong>自动解除互斥锁</strong>（mutexes）等等</p></li></ul><h2 id="条款19：设计-class-犹如设计-type"><a href="#条款19：设计-class-犹如设计-type" class="headerlink" title="条款19：设计 class 犹如设计 type"></a>条款19：设计 class 犹如设计 type</h2><ul><li><p>Class 的设计就是 type 的设计。在定义一个新的 type 之前，请确定你已经考虑过本条款覆盖的所有讨论主题</p><ul><li><p>新type的对象应该如何被创建和销毁</p></li><li><p>对象的初始化和对象的赋值该有什么样的差别</p></li><li><p>新type的对象如果被passed by value，意味着什么？即copy构造函数该如何实现</p></li><li><p>什么是新type的“合法值”？成员函数必须对菲合法值进行必要的错误检查</p></li><li><p>你的新type需要配合某个继承图系？</p></li><li><p>你的新type需要什么样的转换？是否需要隐式或者显式转换成其他类型。</p></li><li><p>什么样的操作符和函数对此新type而言是合理的?该声明哪些函数，哪些应该是member函数，某些则不是。</p></li><li><p>什么样的标准含税应该驳回？例如，自动生成的拷贝构造函数，赋值函数和析构函数等等。</p></li><li><p>谁该取用新type的成员？哪些为public、哪些为protected、哪些为private。</p></li><li><p>什么是新type的“未声明接口”？这个不太懂</p></li><li><p>你的新type有多么一般化？或许你其实并非定义一个新type，而是定义一整个</p><p>types家族。</p></li><li><p>你真的需要一个新type吗？如果只是定义新的derived class以便为既有的class添加机能，那么说不定单纯定义一个或多个non-member函数或者template更能达到目标。</p></li></ul></li></ul><h2 id="条款20：宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#条款20：宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款20：宁以 pass-by-reference-to-const 替换 pass-by-value"></a>条款20：宁以 pass-by-reference-to-const 替换 pass-by-value</h2><ul><li>尽量以 pass-by-reference-to-const 替换 pass-by-value。前者通常比较高效，并可避免切割问题（slicing problem）<ul><li><strong>&#x3D;&#x3D;切割问题&#x3D;&#x3D;<strong>：参数类型为Window w，</strong>如果传递其子类，则其子类的特化信息会被切除</strong></li></ul></li><li>以上规则<strong>并不适用于内置类型</strong>，以及 STL 的迭代器和函数对象。对它们而言，pass-by-value 往往比较合适</li></ul><h2 id="条款21：必须返回对象时，别妄想返回其-reference"><a href="#条款21：必须返回对象时，别妄想返回其-reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其 reference"></a>条款21：必须返回对象时，别妄想返回其 reference</h2><ul><li>绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象（这个需要外部调用delete，而且如果<strong>连续赋值</strong>可能导致内存空间无法释放），或返回 pointer 或 reference 指向一个 local static 对象而<strong>有可能同时需要多个这样的对象</strong>。条款4已经为 ”在单线程模型中合理返回 reference 指向一个 local static 对象“ 提供了一份设计实例</li></ul><h2 id="条款22：将成员变量声明为-private"><a href="#条款22：将成员变量声明为-private" class="headerlink" title="条款22：将成员变量声明为 private"></a>条款22：将成员变量声明为 private</h2><ul><li>切记将变量声明为 private。这可赋予客户<strong>访问数据的一致性</strong>、可细微划分访问控制、允诺约束条件获得保证、并提供 class 作者充分的实现弹性</li><li>protected 并不比 public 更具封装性</li></ul><h2 id="条款23：宁以-non-member、non-friend-替换-member-函数"><a href="#条款23：宁以-non-member、non-friend-替换-member-函数" class="headerlink" title="条款23：宁以 non-member、non-friend 替换 member 函数"></a>条款23：宁以 non-member、non-friend 替换 member 函数</h2><ul><li>宁可拿non-member non-friend 函数替换 member 函数。这样做可以<strong>增加封装性、包裹弹性（packaging flexibility）和技能扩展性</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//————1————</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//————2————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser &amp;wb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  wb.<span class="built_in">clearCache</span>();</span><br><span class="line">  wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">  wb.<span class="built_in">removeCookies</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>从上面代码看出，以 non-member-non-friend 函数方式形式来实现 clear 操作会更有封装性，因为它不能访问类里面的数据，更加符合封装的思想。</li></ul><h2 id="条款24：若所有参数皆需要类型转换，请为此采用-non-member-函数"><a href="#条款24：若所有参数皆需要类型转换，请为此采用-non-member-函数" class="headerlink" title="条款24：若所有参数皆需要类型转换，请为此采用 non-member 函数"></a>条款24：若所有参数皆需要类型转换，请为此采用 non-member 函数</h2><ul><li>如果你需要为某个函数的所有参数（<strong>包括被 this 指针所指的那个隐喻参数</strong>）进行类型转换，那么这个函数必须是个 non-member</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational &amp;rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>对于上面代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rational result = oneHalf * oneEighth;</span><br><span class="line">result = result * oneEighth;</span><br><span class="line">result = oneHalf * <span class="number">2</span>;</span><br><span class="line">result = <span class="number">2</span> * oneHalf; <span class="comment">//有错误</span></span><br></pre></td></tr></table></figure><ul><li>为了使得第四个赋值也能支持，可以把operator*实现成以下<ul><li>此函数可以使用 Rational 的 public 接口来实现功能，就不用声明为 friend</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs, <span class="type">const</span> Rational &amp;rhs);</span><br></pre></td></tr></table></figure><h2 id="条款25：-考虑写出一个不抛出异常的-swap-函数"><a href="#条款25：-考虑写出一个不抛出异常的-swap-函数" class="headerlink" title="条款25：&#x3D;&#x3D;考虑写出一个不抛出异常的 swap 函数&#x3D;&#x3D;"></a>条款25：&#x3D;&#x3D;考虑写出一个不抛出异常的 swap 函数&#x3D;&#x3D;</h2><ul><li>当 std::swap 对你的类型效率不高时，提供一个swap成员函数，并确定这个函数<strong>不抛出异常</strong></li><li>如果你提供一个 <strong>member</strong> swap，也该提供一个 <strong>non-member</strong> swap 用来调用前者。对于 <strong>classes</strong>（而非 <strong>template</strong>），也请<strong>特化std::swap</strong></li><li>调用 swap 时应针对 std::swap 使用 using 声明式，然后调用 swap 并且不带任何“命名空间资格修饰”（让编译器自己选择，如果类型匹配，会选择用户自己特化的）</li><li>为“用户定义类型”进行 std templates 全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">...<span class="comment">//模板化的WidgetImpl等等</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//内含swap成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; other)</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> std::swap;<span class="comment">//使用标准库的swap</span></span><br><span class="line"><span class="built_in">swap</span>(pImpl, other.pImpl);<span class="comment">//交换的基本数据类型（底层指针），内置类型上的操作绝不会抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">WidgetImpl* pImpl;<span class="comment">//指针，所指对象内含Widget数据</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span></span>&#123;</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> std::swap;<span class="comment">//令std::swap在此函数可用</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1, obj2);<span class="comment">//为T型对象调用最佳的swap版本</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h1><h2 id="条款26：尽可能延后变量定义式的时间"><a href="#条款26：尽可能延后变量定义式的时间" class="headerlink" title="条款26：尽可能延后变量定义式的时间"></a>条款26：尽可能延后变量定义式的时间</h2><ul><li>尽可能<strong>延后变量定义式的出现</strong>。这样做可增加程序的清晰度并改善程序的效率<ul><li>定义变量会有构造的时间消耗，若之后一段时间没使用，此时中间发生异常，又会有这个变量析构的时间消耗</li></ul></li></ul><p>对于循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法A：定义循环外</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  w = 取决于i的某个值;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法B：定义循环内</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Widget <span class="title">w</span><span class="params">(取决于i的某个值)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>做法A：1个构造函数+1个析构函数+n个赋值函数</li><li>做法B：n个构造函数+n个析构函数</li></ul><p>如果classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效。尤其当n比较大的时候。否则做法B或许比较好。</p><p>另外A带的是w的作用域变大，有时候会对程序的可理解性和易维护性造成冲突。</p><p>因此：</p><ul><li>你知道<strong>赋值成本</strong>比 <strong>“构造+析构” 成本</strong>低</li><li>你正在处理代码中效率高度敏感的部分，否则你应该使用做法B</li></ul><h2 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h2><ul><li><strong>const_cast</strong>：通常被用来<strong>将对象的常量性剔除</strong></li><li><strong>dynamic_cast</strong>：主要用来执行“<strong>安全向下转型</strong>”，也就是用来判断某对象是否归属继承体系中的某个类型</li><li><strong>reinterpret_cast</strong>：意图执行<strong>低级转型</strong>，实际动作及结果可能取决于编译器，这也就表示它不可移植<ul><li>允许将任何指针转换为任何其他指针类型。 也允许将任何整数类型转换为任何指针类型以及反向转换。</li></ul></li><li><strong>static_cast</strong>：用来强迫隐式转换，但它无法将const转为non-const</li><li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计——virtual：子类override父类，父类指针指向子类实例</li><li>如果转型是必要的，试着将它隐藏于某个函数背后。客户可以调用该函数，而不需要将转型放进他们自己的代码内（应该用 “基于virtual 函数调用” 替代 dynamic_cast）</li><li>宁可以C++-style转型，不要使用旧式转型。前者很容易辨认出来，而且也比较有着分门别类的职掌</li></ul><h2 id="条款28：避免返回-handles-指向对象内部成分"><a href="#条款28：避免返回-handles-指向对象内部成分" class="headerlink" title="条款28：避免返回 handles 指向对象内部成分"></a>条款28：避免返回 handles 指向对象内部成分</h2><blockquote><p>handles：号码牌，用于获得某个对象</p></blockquote><ul><li><strong>避免返回 handles</strong>（包括 reference 、指针、迭代器）<strong>指向内部对象</strong>。遵守这个条款<strong>可增加封装性</strong>，帮助 const 成员函数的行为像个 const，并将发生 “虚拟号码牌” （dangling handles）的可能性降到最低（返回临时对象的内部对象的引用，一旦临时对象销毁，这个引用就是变成了空悬、虚吊（dangling））</li></ul><h2 id="条款29：-为-“-异常安全”-而努力是值得的"><a href="#条款29：-为-“-异常安全”-而努力是值得的" class="headerlink" title="条款29：&#x3D;&#x3D;为 “ 异常安全” 而努力是值得的&#x3D;&#x3D;"></a>条款29：&#x3D;&#x3D;为 “ 异常安全” 而努力是值得的&#x3D;&#x3D;</h2><ul><li>异常安全函数（Exception-safe functions）即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型<ul><li><strong>基本型</strong>：如果异常被抛出，程序内的任何事务仍然保持在有效的状态下（但是不能预料现实状态，<strong>程序可能处于任何状态</strong>——只要这个状态是合法的）</li><li><strong>强烈保证型</strong>：如果异常被抛出，程序状态不改变；如果函数成功，则完全成功，如果函数失败，程序会回复到 “调用函数之前” 的状态</li><li><strong>不抛掷（nothrow）保证</strong>：承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。作用于<strong>内置类型</strong>（例如 ints，指针等等）身上的所有操作都提供 nothrow 保证。这是异常安全码中一个<strong>必不可少的关键基础材料</strong><ul><li><strong>在函数名后面加 throw()</strong> 括号内为空</li></ul></li></ul></li><li>“强烈保证” 往往能够以 copy-and-swap 实现出来，但 “强烈保证” 并非对所有函数都可实现或具备现实意义</li><li>函数提供的 “异常安全保证” 通常最高只等于其所调用之各个函数的 “异常安全保证” 最低者</li></ul><h2 id="条款30：-透彻了解-inlining-的里里外外"><a href="#条款30：-透彻了解-inlining-的里里外外" class="headerlink" title="条款30：&#x3D;&#x3D;透彻了解 inlining 的里里外外&#x3D;&#x3D;"></a>条款30：&#x3D;&#x3D;透彻了解 inlining 的里里外外&#x3D;&#x3D;</h2><ul><li>inline函数如果起作用了，会在每次调用的时候用实现的代码替换它，所以会<strong>造成程序体积变大</strong>。</li><li>inline只是向编译器的一个申请，可以<strong>明确用inline关键字</strong>，也可以<strong>在类体内部定义</strong>。</li><li>template的实例化和inline无关，如果需要template函数为inline，需要显式地声明它。</li><li>inline函数<strong>无法随着程序库的升级而升级</strong>。换句话说如果f是程序库内的一个inline函数，客户讲“f函数本体”编进其程序中，一旦程序库设计者决定改变f，所有用到f的客户端程序都<strong>必须重新编译</strong>。</li><li>将大多数inline<strong>限制在小型、被频繁调用的函数身上</strong>。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li><li>80-20 法则：一个典型的程序有 80% 的执行时间花费在 20%的代码身上</li></ul><h2 id="条款31：-将文件间的编译依存关系降到最低"><a href="#条款31：-将文件间的编译依存关系降到最低" class="headerlink" title="条款31：&#x3D;&#x3D;将文件间的编译依存关系降到最低&#x3D;&#x3D;"></a>条款31：&#x3D;&#x3D;将文件间的编译依存关系降到最低&#x3D;&#x3D;</h2><ul><li><p><strong>解耦</strong>——编译的时候有时候只需要一个声明而不必把定义编译进去</p></li><li><p>支持 “编译依存性最小化” 的一般构想是：<strong>相依于声明式</strong>，<strong>不要相依于定义式</strong>。基于此构想的两个手段是 Handle classes 和 Interface classes。</p></li><li><p>程序库头文件应该以 “完全且仅有声明式”（full and declaration-only forms）的形式存在。这种做法不论是否涉及 templates 都适用</p><ul><li><strong>Handles classes</strong>：将声明和定义分类编写，声明类和定义类有同名成员函数，声明类通过成员智能指针指向实现类，声明类的成员函数通过这个指针调用定义式中的函数</li><li><strong>Interface classes</strong>：父类中通过虚函数 “声明” ，子类继承父类重写虚函数提供 “定义”，通过 factory 函数返回一个指向子类的父类智能指针</li><li>将声明与定义分离，可以**&#x3D;&#x3D;将 “非真正必要之类型定义” 与 客户端之间的编译依存关系去除掉&#x3D;&#x3D;**</li></ul></li></ul><h1 id="6-继承与面向对象设计"><a href="#6-继承与面向对象设计" class="headerlink" title="6. 继承与面向对象设计"></a>6. 继承与面向对象设计</h1><h2 id="条款32：确定你的-public-继承塑模出-is-a-关系"><a href="#条款32：确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="条款32：确定你的 public 继承塑模出 is-a 关系"></a>条款32：确定你的 public 继承塑模出 is-a 关系</h2><ul><li>“<strong>public 继承</strong>” 意味着 <strong>is-a</strong>。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class 对象。</li></ul><h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><ul><li>以下代码中加的 virtual 只是为了说明不管成员函数是不是pure virtual 、impure virtual 、non-virtual，<strong>只看名称</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">int x;</span><br><span class="line">public:</span><br><span class="line">virtual void mf1() = 0;</span><br><span class="line">    virtual void mf1(int);</span><br><span class="line">    virtual void mf2();</span><br><span class="line">    void mf3();</span><br><span class="line">    void mf3(double);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">class Derived : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void mf1();</span><br><span class="line">    void mf3();</span><br><span class="line">    void mf4();</span><br><span class="line">&#125;；</span><br><span class="line">Derived d;</span><br><span class="line">int x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); //没问题，调用Dervied::mf1</span><br><span class="line">d.mf1(x); //错误，因为Derived::mf1遮掩了Base::mf1</span><br><span class="line">d.mf2();//没问题，调用Base::mf2</span><br><span class="line">d.mf3(); //没问题，调用Dervied::mf3</span><br><span class="line">d.mf3(x); //错误！因为Derived::mf3遮掩了Base::mf3</span><br></pre></td></tr></table></figure><ul><li><p>如果你正在使用public继承而又不继承那些重载函数，就是违反Base和derived classes之间的is-a关系，而is-a是public的基石。</p></li><li><p>为了被遮掩的名称再见天日，可<strong>使用using声明式</strong></p></li></ul><h2 id="条款34：区分接口继承还是实现继承"><a href="#条款34：区分接口继承还是实现继承" class="headerlink" title="条款34：区分接口继承还是实现继承"></a>条款34：区分接口继承还是实现继承</h2><ul><li>考虑如下一段代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Shape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void draw() const = 0;</span><br><span class="line">    virtual void error(const std::string &amp;msg);</span><br><span class="line">    int objectID() const;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">class Rectangle : public Shape &#123;...&#125;;</span><br><span class="line">class Ellipse : public Shape &#123;...&#125;;</span><br></pre></td></tr></table></figure><ul><li>对于一个pure virtual函数，且不带定义，目的是为了让derived classes<strong>只继承函数接口</strong>。然后，<strong>继承类必须实现它自身的行为</strong>。</li><li>声明impure virtual函数的目的是，让derived classes继承该函数的<strong>接口和缺省实现</strong>。也就是，如果某个集成类不想对该功能做特殊处理的时候，可以采用缺省的默认实现，否则，需要自己提供实现。这种方法可能会造成继承类忘记实现自己该实现的功能，这时候编译照样是过的。</li><li>声明pure virtual函数且带定义，也是让derived classes继承该函数的接口和缺省实现。这种方法跟上面的区别是<strong>，它可以防止集成类忘记实现自己功能的情况</strong>，<strong>因为是pure virual</strong>，采用默认实现也得显式地调用基类的函数。</li><li>声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份<strong>强制性实现</strong>。</li></ul><h2 id="条款35：-考虑-virtual-函数以外的其他选择"><a href="#条款35：-考虑-virtual-函数以外的其他选择" class="headerlink" title="条款35：&#x3D;&#x3D;考虑 virtual 函数以外的其他选择&#x3D;&#x3D;"></a>条款35：&#x3D;&#x3D;考虑 virtual 函数以外的其他选择&#x3D;&#x3D;</h2><ul><li>场景：假如你打算为游戏内的人物设计一个继承体系。你的游戏属于暴力砍杀类型，剧中人物被伤害或因其他因素而降低健康状态的情况并不罕见。因此，你决定提供一个成员函数healthValue，它会返回一个整数，表示人物的健康程度。由于不同的人物可能已不同的方式计算它们的健康指数，将healthValue声明为virtual似乎是再明白不过的做法。</li></ul><h3 id="方案1-虚函数方法"><a href="#方案1-虚函数方法" class="headerlink" title="方案1-虚函数方法"></a>方案1-虚函数方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual int healthValue() const; //返回人物的健康指数</span><br><span class="line">                                     //derived classes可重新定义它</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方案2-借由-Non-Virtual-Interface-手法实现-Template-Method-模式"><a href="#方案2-借由-Non-Virtual-Interface-手法实现-Template-Method-模式" class="headerlink" title="方案2-借由 Non-Virtual Interface 手法实现 Template Method 模式"></a>方案2-借由 Non-Virtual Interface 手法实现 Template Method 模式</h3><ul><li>这个方案的思路是保留healthValue为public成员函数，但让它成为non-virtual，表调用一个private virtual函数，进行实际工作：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int healthValue() const</span><br><span class="line">    &#123;</span><br><span class="line">  ... //derived classes不重新定义它</span><br><span class="line">        int retVal = doHealthValue(); //做一些事情工作，详下</span><br><span class="line">        ... //做一些事后工作</span><br><span class="line">        return retVal;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">virtual int doHealthValue() const //derived classes可重新定义它</span><br><span class="line">    &#123;</span><br><span class="line">  ... //缺省算法，计算健康指数</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>令客户通过 public non-virtual 成员函数间接调用 private virtual 函数，<strong>称为 non-virtual interface 手法(NVI)<strong>。它是所谓Template Method 设计模式的一个独特表现形式。我把这个 non-virtual 函数称为 virtual 函数的</strong>外覆器</strong>（wrapper）。</p></li><li><p><strong>优点</strong>：可以使得 virtual 函数在调用的时候，之前<strong>可以设定好适当场景</strong>，并在调用结束后清理场景。事前工作可以是锁定互斥器、制造运转日志记录项目、验证 class 约束条件。<strong>事后工作</strong>可以包括互斥器解除锁定，验证函数的时候条件、再次验证 class 约束条件等等。</p></li></ul><h3 id="方案3-借由-Function-Pointers-实现-Strategy-模式"><a href="#方案3-借由-Function-Pointers-实现-Strategy-模式" class="headerlink" title="方案3-借由 Function Pointers 实现 Strategy 模式"></a>方案3-借由 Function Pointers 实现 Strategy 模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">explict GameCharacter(HealthCalcFunc hcf = defaultHealthCalc);</span><br><span class="line">  void setHealthCalculator(HealthCalcFunc hcf);</span><br><span class="line">private:</span><br><span class="line">HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>优点：<strong>运用函数指针替换 virtual 函数</strong>， “每个对象可<strong>各自拥有</strong>自己的健康计算函数” 和 “可在运行期间改变计算函数”</p></li><li><p>缺点：<strong>降低了封装性</strong>——&gt;如果计算血量，需要依赖non-public的信息，<strong>就需要弱化 class 的封装</strong>，例如 class 可声明这个 non-member 函数为 friends，或为其实现的某一部分提供 public 访问函数</p></li></ul><h3 id="方案4-借由-tr1-function-完成-strategy-模式"><a href="#方案4-借由-tr1-function-完成-strategy-模式" class="headerlink" title="方案4-借由 tr1::function 完成 strategy 模式"></a>方案4-借由 tr1::function 完成 strategy 模式</h3><ul><li>tr1::function 对象的行为就像一般函数指针。这样的对象可接纳“与给定的目标标签格式兼容”的所有可调用物，也就是函数指针、函数对象或成员函数指针。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">typedef std::tr1::function&lt;int (const GameCharacter &amp;)&gt; HealthCalcFunc;</span><br><span class="line">private:</span><br><span class="line">    HealthCalcFunc healthCalcFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>优点：灵活性，可以使用<strong>任何可调用的对象</strong>。</li></ul><h3 id="方案5-古典的-Strategy-策略模式"><a href="#方案5-古典的-Strategy-策略模式" class="headerlink" title="方案5-古典的 Strategy 策略模式"></a>方案5-古典的 Strategy 策略模式</h3><p>![1685202455586](effective C++.assets&#x2F;1685202455586.jpg)</p><ul><li>这个解法的吸引力在于，熟悉标准 Strategy 模式的人很容易辨认它，而且它还提供 “将一个既有的健康算法纳入使用” 的可能性——只要为 HealthCalcFunc 继承体系添加一个 derived class 即可</li></ul><h2 id="条款36：绝不重新定义继承而来的-non-virtual-函数"><a href="#条款36：绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="条款36：绝不重新定义继承而来的 non-virtual 函数"></a>条款36：绝不重新定义继承而来的 non-virtual 函数</h2><ul><li>绝不重新定义继承而来的non-virtual函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">D x;</span><br><span class="line">B *pb = &amp;x;</span><br><span class="line">pb-&gt;<span class="built_in">mf</span>();<span class="comment">//调用B::mf</span></span><br><span class="line">D *pd = &amp;x;</span><br><span class="line">pd-&gt;<span class="built_in">mf</span>();<span class="comment">//调用D::mf</span></span><br></pre></td></tr></table></figure><ul><li>在D中重载non-virtual的B类对象中的函数，其实已经违反了在 public 继承下每个D is-a B的约束。即对于non-virtual的接口，继承类应该和基类行为是一致的，否则就不应该设计成non-virtual接口。</li></ul><h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><ul><li><p>virtual函数系动态绑定，而缺省参数值却是静态绑定。</p></li><li><p>举个例子</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ShapeColor</span>&#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>有以下代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps;</span><br><span class="line">Shape *pc = <span class="keyword">new</span> Circle;</span><br><span class="line">Shape *pr = <span class="keyword">new</span> Rectangle;</span><br></pre></td></tr></table></figure><ul><li><p>用 pc-&gt;draw() 的时候，采用的默认参数是 Red，是 Shape 类的默认参数，而不是 Derived 的类的默认参数，因为默认参数是静态编译期间绑定的。</p></li><li><p>即使把 Base class 和 Derived class 设计成相同的默认参数，<strong>如果某一天要修改这个参数，得两个类都需要修改</strong>。</p></li><li><p>这个问题可以通过 NVI 方法来避免，把函数功能抽象成 private 的 virtual 函数，然后把缺省的默认参数移到 non-virtual 的 public 函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ShapeColor</span>&#123;Red, Green, Blue&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = RED)</span></span>&#123;</span><br><span class="line">        <span class="built_in">doDraw</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="条款38：通过-复合-塑模出-has-a-或-“根据某物实现出”"><a href="#条款38：通过-复合-塑模出-has-a-或-“根据某物实现出”" class="headerlink" title="条款38：通过&#x3D;&#x3D;复合&#x3D;&#x3D;塑模出 has-a 或 “根据某物实现出”"></a>条款38：通过&#x3D;&#x3D;复合&#x3D;&#x3D;塑模出 has-a 或 “根据某物实现出”</h2><ul><li><p>复合 （composition）的意义和 public 继承完全不同</p></li><li><p>在应用域（application domain），复合意味着 has-a（有一个）。在实现域（implementation domain），复合意味着 is-implemented-in-terms-of</p></li><li><p>例如，我们希望基于std::list来实现一个set，可以，在一个set类里面定义一个std::list作为内部成员，来实现set。</p></li></ul><h2 id="条款39：明智而审慎地使用-private-继承"><a href="#条款39：明智而审慎地使用-private-继承" class="headerlink" title="条款39：明智而审慎地使用 private 继承"></a>条款39：明智而审慎地使用 private 继承</h2><ul><li>Private 继承意味着 is-implemented-in-terms-of（根据某物实现出）。它<strong>通常比复合（composition）的级别低</strong>。但是当 derived classes 需要访问 protected base class 的成员，或需要重新定义一个或多个 virtual 函数时，这么设计是合理的</li><li>和复合（composition）不同，private 继承可以造成 <strong>empty base 最优化</strong>（EBO：empty base optimization）。这对致力于 “对象尺寸最小化” 的程序库开发者而言，可能很重要</li><li>复合和 private 继承都意味着 is-implemented-in-terms-of，但复合比较容易理解，所以无论什么时候，<strong>只要可以，你还是应该选择复合</strong></li></ul><h2 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h2><ul><li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要</li><li>virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes不带任何数据，将是最具使用价值的情况</li><li>多重继承的确有正当用途。其中一个情节涉及 “<strong>public 继承某个Interface class</strong>” 和 “<strong>private 继承某个协助实现的class</strong>” 的两相组合<ul><li>和条款31相似，不过子类重写的操作交给 private 继承的 class</li></ul></li></ul><h1 id="7-模板与泛型编程"><a href="#7-模板与泛型编程" class="headerlink" title="7. 模板与泛型编程"></a>7. 模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款41：了解隐式接口和编译期多态</h2><ul><li>class 和 templates 都支持接口（interfaces）和多态（polymorphism）</li><li>对 classes 而言<strong>接口是显示的</strong>（explicit），以函数签名为中心，多态则是通过 virtual 函数发生于运行期——<strong>运行期多态</strong></li><li>对 template 参数而言，<strong>接口是隐式的</strong>（implici），<strong>奠基于有效表达式</strong>。多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期——<strong>编译器多态</strong></li></ul><ul><li>对于template编程，隐式接口和编译期多态移到了前头，例如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T &amp;W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">    temp.<span class="built_in">normalize</span>();</span><br><span class="line">    temp.<span class="built_in">swap</span>(w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>w必须支持哪一种接口，系由template中执行于w身上的操作来决定。本例看来w的类型T好像必须支持size，normalize和swap成员函数、copy构造函数、不等比较。</li><li>凡涉及w的任何函数调用，例如operator&gt;和operator!&#x3D;，有可能造成template具现化，使得这些调用得以成功。这样的具现行为发生在<strong>编译期</strong>。“以不同的template参数具现化function templates”会导致调用不同的函数，这是<strong>编译期多态</strong>。</li></ul><h2 id="条款42：了解-typename-的双重意义"><a href="#条款42：了解-typename-的双重意义" class="headerlink" title="条款42：了解 typename 的双重意义"></a>条款42：了解 typename 的双重意义</h2><ul><li><p>声明 template 参数时，前缀关键字 class 和 typename 可互换</p></li><li><p>请使用关键字 typename 标识<strong>嵌套从属类型</strong>名称；但不得在 <strong>base class lists</strong> 或 <strong>member initialization list</strong> 内以它作为 base class 修饰符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;               <span class="comment">//允许使用typename或class</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(<span class="type">const</span> C &amp;container,        <span class="comment">//不允许使用typename</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">typename</span> C::iterator iter)</span> <span class="comment">//一定要使用typename</span></span></span><br></pre></td></tr></table></figure><p>因为C::iterator看起来有可能是类型，也有可能是成员变量，所以，要<strong>明确告诉编译器</strong>。</p></li></ul><h2 id="条款43：-学习处理模板化基类的名称"><a href="#条款43：-学习处理模板化基类的名称" class="headerlink" title="条款43：&#x3D;&#x3D;学习处理模板化基类的名称&#x3D;&#x3D;"></a>条款43：&#x3D;&#x3D;学习处理模板化基类的名称&#x3D;&#x3D;</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgInfo</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClear</span><span class="params">(<span class="type">const</span> MsgInfo &amp;info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  std::string msg;</span><br><span class="line">        Company c;</span><br><span class="line">        c.<span class="built_in">sendCleartext</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo &amp;info)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span> : <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo &amp;info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  将<span class="string">&quot;传送前&quot;</span>的信息写至log;</span><br><span class="line">        <span class="built_in">sendClear</span>(info);  <span class="comment">//调用base class函数：这段代码无法通过编译</span></span><br><span class="line">        将<span class="string">&quot;传送后&quot;</span>的信息写至log;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之所以无法通过编译是因为编译器无法确认 MsgInfo&lt;Company&gt; 中是否有 sendClear() 函数，也就<strong>不会进入父类作用域</strong>去查看是否有这个函数<ul><li>因为就算一般（泛化）的 template 中确实是有sendClear() 函数，但可能有全特化版本，而这个版本没有 sendClear() 函数</li></ul></li></ul><p><strong>解决方案有三个：</strong></p><p>在 derived class templates ——&gt;假定这个函数被继承</p><ul><li>在sendClear之前加上<strong>this操作符</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info);</span><br></pre></td></tr></table></figure><ul><li>使用<strong>using声明式</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br></pre></td></tr></table></figure><ul><li>明白<strong>指出被调用的函数位于base class</strong>内<ul><li>此操作的明确资格修饰（explicit qualification）会关闭 “ virtual ” 绑定行为</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info);</span><br></pre></td></tr></table></figure><h2 id="条款44：将与参数无关的代码抽离-templates"><a href="#条款44：将与参数无关的代码抽离-templates" class="headerlink" title="条款44：将与参数无关的代码抽离 templates"></a>条款44：将与参数无关的代码抽离 templates</h2><ul><li>Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系</li><li>因<strong>非类型模板参数</strong>（non-type template parameters）而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数<ul><li>如以下代码示例</li></ul></li><li>因<strong>类型参数</strong>（type parameters）而造成的代码膨胀，往往可降低，做法是让带有<strong>完全相同二进制</strong>表述的具现类型<strong>共享实现码</strong><ul><li>例如 vector&lt;int&gt; 和 vector&lt;long&gt; 的成员函数可能完全相同，会<strong>使用唯一一份底层实现</strong></li></ul></li></ul><p>代码示例：</p><ul><li>对于template class或者template function，其间的代码重复可能不是很容易能看出来，需要对调用情况进行分析，可能会实现仅仅是参数不同的函数，例如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line"> std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1; <span class="comment">//调用SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line">sm1.<span class="built_in">invert</span>();</span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2; <span class="comment">//调用SquareMatrix&lt;double, 10&gt;::invert</span></span><br><span class="line">sm2.<span class="built_in">invert</span>();</span><br></pre></td></tr></table></figure><ul><li>解决方案是写一个带参数的invert函数，然后，public函数的接口调用带参数的invert函数。<ul><li><strong>减少了具现模板时的代码膨胀</strong>，将具现<strong>模板间的一些相同机能</strong>交由其他类&#x2F;函数模板实现，再继承调用，这样都会使用一份代码，而不需要每次模板具现的时候都有一份重复代码</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span><span class="comment">//将与参数是std::size_t n无关的代码抽离了出来</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;<span class="comment">//避免覆盖base版的invert</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123;<span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n);&#125;<span class="comment">//this是为了假定invert被继承——条款43</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="条款45：运用-成员函数模板-接受所有兼容类型"><a href="#条款45：运用-成员函数模板-接受所有兼容类型" class="headerlink" title="条款45：运用&#x3D;&#x3D;成员函数模板&#x3D;&#x3D;接受所有兼容类型"></a>条款45：运用&#x3D;&#x3D;成员函数模板&#x3D;&#x3D;接受所有兼容类型</h2><ul><li><p>同一个 template 的不同具现体（instantiations）之间并不存在什么与生俱来的固有关系</p><ul><li>这里意指如果以带有 base-derived 关系的 B，D 两类型<strong>分别具现化某个 template</strong>，产生出来的两个具现&#x3D;&#x3D;<strong>并不带有 base-derived 关系</strong>&#x3D;&#x3D;</li></ul></li><li><p>使用 member function templates（<strong>成员函数模板</strong>）生成 “可接受所有兼容类型” 的函数——这里用倾向使用 class</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T *realPtr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SmartPtr&lt;Top&gt; pt1 = </span><br><span class="line"><span class="built_in">SmartPtr</span>&lt;middle&gt;(<span class="keyword">new</span> Middle); <span class="comment">//将smartPtr&lt;middle&gt;转换成SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = </span><br><span class="line"><span class="built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);</span><br><span class="line">SmartPtr&lt;<span class="type">const</span> Top&gt; pct2 = pt1;</span><br></pre></td></tr></table></figure><ul><li>解决方案</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">   <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt; &amp;other)</span></span></span><br><span class="line"><span class="function">    : heldPtr(other.get()) &#123;</span>...&#125;</span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> heldPtr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T *heldPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>使用成员初值列来初始化 SmartPtr 之内类型为 T* 的成员变量，并以类型为 U* 的指针作为初值，这个行为只有当 “存在某个隐式转换<strong>可将一个U<em>指针转换成一个T</em>指针</strong>” 才能通过编译。</p></li><li><p>运用成员函数模板接受所有兼容类型——这里是构造函数的示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">//构造,来自任何类型的</span></span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(Y* p)</span></span>;<span class="comment">//内置指针</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function"> <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp;r)</span></span>;<span class="comment">//或shared—_ptr</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line"> <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>&lt;Y&gt;(weak_ptr&lt;Y&gt; <span class="type">const</span>&amp;r);<span class="comment">//或weak_ptr</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line"> <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>&lt;Y&gt;(auto_ptr&lt;Y&gt;&amp; r);<span class="comment">//或auto_ptr</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;<span class="comment">//赋值,来自任何兼容的</span></span><br><span class="line"> shared_ptr&amp; <span class="keyword">operator</span>== (shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);<span class="comment">//shared_ptr</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line"> shared_ptr&amp; <span class="keyword">operator</span>== (auto_ptr&lt;Y&gt; &amp;r);<span class="comment">//或auto_ptr</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在 class 内声明泛化 copy 构造函数，并<strong>不会阻止编译器生成自己的 copy 构造函数</strong>，所以，如果你想要控制 copy 构造的方方面面，你必须<strong>同时声明泛化 copy 构造函数</strong>和<strong>正常的 copy 构造函数</strong>。相同规则也适用于赋值操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr <span class="type">const</span>&amp;r);<span class="comment">//copy构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp;r)</span></span>;<span class="comment">//泛化copy构造函数</span></span><br><span class="line">    </span><br><span class="line">shared_ptr&amp; <span class="keyword">operator</span>== (shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);<span class="comment">//copy assignment</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">shared_ptr&amp; <span class="keyword">operator</span>== (shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);<span class="comment">//泛化copy assignment</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款46：需要类型转换时请为模板定义非成员函数</h2><ul><li>与条款24中的不同：加入了模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>, <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="type">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span><span class="comment">//错误，无法通过编译</span></span><br></pre></td></tr></table></figure><ul><li><p>oneHalf 可以推导出类型为 Rational&lt;int&gt;</p></li><li><p>而 2 不能推出Rational&lt;int&gt;，因为首先要用临时对象并调用 Rational 的构造函数来构建，然而此时 Rational&lt;T&gt; 还未具现化，因此无法通过编译</p></li><li><p>解决方法是让<code>const Rational&lt;T&gt; operator* (const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)</code>这个函数成为类的 friend，当 <strong>onehalf 具现化类</strong>的时候<strong>这个函数也被具现化</strong>，上述的 2 可以转化为 创建临时对象并调用 Rational 的构造函数 (2) 来构建</p><ul><li><p>这个 friend 函数要在类中将定义式也附上，不然连接器找不到它，而外部加上作用域的定义是行不通的</p></li><li><p>如果定义比较复杂，可以调用外部辅助实现——&gt;接口和实现分离，在接口函数中调用实现函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rational.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Rational</span>;<span class="comment">//声明Rational template</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenaem T&gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"> <span class="keyword">friend</span></span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">doMultiply</span>(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>一些</strong>编译器要求把所有 template 的定义式放进头文件内——需要的话就将 doMultiply() 定义式也写在头文件</p><ul><li>operator* 的定义式就是 doMultiply()</li></ul></li></ul></li><li><p>在一个class template 内，template 名称可以省略</p></li></ul><h2 id="条款47：请使用-traits-classes-表现类型信息"><a href="#条款47：请使用-traits-classes-表现类型信息" class="headerlink" title="条款47：请使用 &#x3D;&#x3D;traits classes 表现类型信息&#x3D;&#x3D;"></a>条款47：请使用 &#x3D;&#x3D;traits classes 表现类型信息&#x3D;&#x3D;</h2><ul><li>Traits classes 使得“类型相关信息”在编译期可用。它们以 templates 和 “templates 特化” 完成实现</li></ul><p>STL迭代器分类：</p><ul><li>Input迭代器：只能向前移动，一次一步，客户只可读取它们所指的东西，而且只能读取一次。</li><li>Output迭代器：只能向前移动，一次一步，客户只可涂写它们所指的东西，而且只能涂写一次。</li><li>forward迭代器：这种迭代器可以做前述两种分类能做的每件事情，而且可以读或写其所指物一次以上。</li><li>bidirectional迭代器：它除了可以向前移动，还可以向后移动。STL的list迭代器就属于这一分类，set，multiset，map和multimap的迭代器也都是这一分类。</li><li>random access迭代器：可以在常量时间内向前或向后跳跃任意距离。vector，deque和string提供的迭代器都是这一分类。</li></ul><p>在STL中有advance函数，可以把迭代器按照某个距离进行移动，声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterI &amp;iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (iter is a random access iterator)</span><br><span class="line">  &#123;</span><br><span class="line">    iter += d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123;<span class="keyword">while</span>(d--) ++iter;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">while</span> (d++) --iter;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++中实现相关原理如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterI&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;...&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">    &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;...&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">    &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">对于iterator_traits</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">对于内置指针，需要特化一个版本出来</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;IterT *&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>if <strong>在运行期才确定</strong>，而<strong>模板需要在编译阶段具现</strong>，所以下面 if 语句不能通过编译</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT &amp;iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">typeid</span>(<span class="keyword">typename</span> std::iterator_traits&lt;IterI&gt;::iterator_category) == <span class="built_in">typeid</span>(std::random_access_iterator_tag))</span><br><span class="line">&#125;;<span class="comment">//if 在运行期才确定，而模板需要在编译阶段具现，所以下面 if 语句不能通过编译</span></span><br></pre></td></tr></table></figure><ul><li>建立一组重载函数或函数模板，彼此间的差异只在于各自的traits参数。</li><li>建立一个控制函数或函数模板，它调用上述那些劳工函数并传递traits class所提供的信息。</li><li>整合重载技术后，**&#x3D;&#x3D;traits classes 有可能在编译器对类型执行 if…else 测试&#x3D;&#x3D;** ——&gt; 模板元（TMP：Template metaprogramming）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d,</span></span></span><br><span class="line"><span class="params"><span class="function">std::random_access_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  iter += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d, std::bidirectional_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123;<span class="keyword">while</span> (d--) ++iter;&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="keyword">while</span>(d++) --iter;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d, std::input_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(d--) ++iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT &amp;iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">doAdvance</span>(iter, d, <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款48：认识-template-元编程"><a href="#条款48：认识-template-元编程" class="headerlink" title="条款48：认识 template 元编程"></a>条款48：认识 template 元编程</h2><ul><li>Template metaprogramming (TMP，模板元编程)可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率</li><li>TMP可被用来生成“基于政策选择组合”的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码</li></ul><h1 id="8-定制-new-和-delete"><a href="#8-定制-new-和-delete" class="headerlink" title="8. 定制 new 和 delete"></a>8. 定制 new 和 delete</h1><h2 id="条款49：了解-new-handler-的行为"><a href="#条款49：了解-new-handler-的行为" class="headerlink" title="条款49：了解 &#x3D;&#x3D;new-handler&#x3D;&#x3D; 的行为"></a>条款49：了解 &#x3D;&#x3D;new-handler&#x3D;&#x3D; 的行为</h2><ul><li>set_new_handler 允许客户指定一个函数，在<strong>内存分配无法获得满足时被调用</strong><ul><li>operator new 可能不止一次分配内存，并在每次失败后调用 new-handling 函数</li></ul></li><li>Nothrow new 是一个颇为局限的工具，因为它只适用于内存分配；<strong>后继</strong>的构造函数调用<strong>还是可能抛出异常</strong></li></ul><ul><li><p>如果父类里面有 static 成员变量，想要子类继承时都有一份独有的 static 成员变量，可以让父类变成模板（实际上没有地方用到），子类在继承的时候将模板参数设定为本身，<strong>Template 机制会自动为每一个 T 生成一份 static 成员</strong></p></li><li><p>设计良好的 new-handler 函数可以有以下选择：</p><ul><li>让更多内存可被使用</li><li>安装另一个 new-handler</li><li>卸除 new-handler</li><li>抛出 bad_alloc</li><li>不返回</li></ul></li></ul><h2 id="条款50：了解-new-和-delete-的合理替换时机"><a href="#条款50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款50：了解 new 和 delete 的合理替换时机"></a>条款50：了解 new 和 delete 的合理替换时机</h2><ul><li>有许多理由需要写个自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息<ul><li>用来检测运用上的错误</li><li>为了强化效能</li><li>为了收集使用上的统计数据</li><li>为了增加分配和归还的速度</li><li>为了降低缺省内存管理器带来的空间额外开销</li><li>为了弥补缺省内存分配器中的非最佳**&#x3D;&#x3D;齐位&#x3D;&#x3D;**</li><li>为了将相关对象成簇集中</li><li>为了获得非传统行为</li></ul></li></ul><h2 id="条款51：编写-new-和-delete-时需固守常规"><a href="#条款51：编写-new-和-delete-时需固守常规" class="headerlink" title="条款51：编写 new 和 delete 时需固守常规"></a>条款51：编写 new 和 delete 时需固守常规</h2><ul><li><p>operator new 应该<strong>内含一个无穷循环</strong>，并在其中尝试分配内存，如果它<strong>无法满足内存需求</strong>，就应该<strong>调用new-handler</strong>。它也应该有能力处理任何<strong>0 bytes申请</strong>。Class专属版本则还应该处理“比正确大小更大的（错误）申请” ——&gt; 调用标准 operator new</p></li><li><p>operator delete应该在<strong>收到null指针时不做任何事</strong>。Class专属版本则还应该处理“比正确大小更大的（错误）申请” ——&gt; 调用标准operator delete</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory, std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* Base::oeprator <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Base))<span class="comment">//如果大小错误</span></span><br><span class="line"><span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);<span class="comment">//令标准的operator new起而处理</span></span><br><span class="line">...<span class="comment">//否则在这里处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory, std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//检查null指针</span></span><br><span class="line"><span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Base))<span class="comment">//如果大小错误</span></span><br><span class="line">&#123;</span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(size)</span></span>;<span class="comment">//operator delete处理此以申请</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">现在，归还rawMemory所指内存</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="条款52：写了-placement-new-也要写-placement-delete"><a href="#条款52：写了-placement-new-也要写-placement-delete" class="headerlink" title="条款52：写了 placement new 也要写 placement delete"></a>条款52：写了 placement new 也要写 placement delete</h2><ul><li><p>当你写一个 <strong>placement</strong> operator new，请确定也写出了对应的 <strong>placement</strong> operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏</p></li><li><p>当你声明 placement new 和 placement delete，请确定<strong>不要无意识（非故意）地遮盖它们的正常版本</strong></p><ul><li><p>对于撰写内存分配函数，你需要记住的是，缺省的情况下 C++ 在 global 作用域下提供以下形式的 operator new、</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;<span class="comment">//normal new</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//placement new</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//nothrow new</span></span><br></pre></td></tr></table></figure></li><li><p>一个简单的做法是，建立一个 base class，内含所有正常形式的 new 和 delete</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StandardNewDeleteForms</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//normal new/delete</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size); &#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//placement new/delete</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size, ptr); &#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory, ptr)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//nothrow new/delete</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp; nt)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size, nt); &#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>:<span class="keyword">public</span> StandardNewDeleteForms &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">new</span>;<span class="comment">//让这些形式可见</span></span><br><span class="line"><span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="comment">//添加一个自定的placemet new</span></span></span></span><br><span class="line"><span class="params"><span class="function"> std::ostream&amp; logStream)</span></span></span><br><span class="line"><span class="function"><span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory,<span class="comment">//添加一个自定的placemet delete</span></span></span></span><br><span class="line"><span class="params"><span class="function">std::ostream&amp; logStream)</span></span></span><br><span class="line"><span class="function"><span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="9-杂项讨论"><a href="#9-杂项讨论" class="headerlink" title="9. 杂项讨论"></a>9. 杂项讨论</h1><h2 id="条款53：不要忽略编译器的警告"><a href="#条款53：不要忽略编译器的警告" class="headerlink" title="条款53：不要忽略编译器的警告"></a>条款53：不要忽略编译器的警告</h2><ul><li>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取 “无任何警告” 的荣誉</li><li>不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失</li></ul><h2 id="条款54：让自己熟悉包括-TR1-在内的标准程序库"><a href="#条款54：让自己熟悉包括-TR1-在内的标准程序库" class="headerlink" title="条款54：让自己熟悉包括 TR1 在内的标准程序库"></a>条款54：让自己熟悉包括 TR1 在内的标准程序库</h2><blockquote><p>TR1：Technical Report 1</p></blockquote><ul><li>STL</li><li>Iostreams</li><li>国际化支持</li><li>数值处理</li><li>异常阶层体系</li><li>C89标准程序库</li></ul><p>上面的分类应该是比较老的分类了，最新的应该包含C++11和C++14的标准程序库了。</p><ul><li>TR1 自身知识一份规范。为获得 TR1 提供的好处，你需要一份实物。一个好的实物来源是 Boost</li></ul><h2 id="条款55：让自己熟悉-Boost"><a href="#条款55：让自己熟悉-Boost" class="headerlink" title="条款55：让自己熟悉 Boost"></a>条款55：让自己熟悉 Boost</h2><ul><li><p>Boost 是一个社群，也是一个网站。致力于免费、源码开放、同僚复查的 C++ 程序库开发。Boost 在 C++ 标准化过程中扮演深具影响力的角色</p></li><li><p>Boost 提供许多 TR1 组件实现品，以及其他许多程序库</p></li><li><p>Boost 是否需要熟悉？看 google 代码规范是推荐使用其中一部分的，觉得还是有必要看看。</p></li></ul><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记</title>
      <link href="/2023/07/25/MySQL%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/25/MySQL%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="—-基础篇-—"><a href="#—-基础篇-—" class="headerlink" title="—&#x3D;&#x3D;基础篇&#x3D;&#x3D;—"></a>—&#x3D;&#x3D;基础篇&#x3D;&#x3D;—</h1><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="DDL-数据库操作"><a href="#DDL-数据库操作" class="headerlink" title="DDL-数据库操作"></a>DDL-数据库操作</h3><ul><li>语句后+ \G变成每行</li></ul><p><img src="/MySQL.assets/image-20230324203357741.png" alt="image-20230324203357741"></p><h3 id="DDL-表操作"><a href="#DDL-表操作" class="headerlink" title="DDL-表操作"></a>DDL-表操作</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><img src="/MySQL.assets/image-20230324204748362.png" alt="image-20230324204748362"></p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><img src="/MySQL.assets/image-20230324204833583.png" alt="image-20230324204833583"></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><p><img src="/MySQL.assets/image-20230324205913537.png" alt="image-20230324205913537"></p><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><p><img src="/MySQL.assets/image-20230324205926638.png" alt="image-20230324205926638"></p><h5 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h5><p><img src="/MySQL.assets/image-20230324210001434.png" alt="image-20230324210001434"></p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p><img src="/MySQL.assets/image-20230324211528869.png" alt="image-20230324211528869"></p><p><img src="/MySQL.assets/image-20230324211756557.png" alt="image-20230324211756557"></p><p><img src="/MySQL.assets/image-20230324211915357.png" alt="image-20230324211915357"></p><p><img src="/MySQL.assets/image-20230324212106254.png" alt="image-20230324212106254"></p><p><img src="/MySQL.assets/image-20230324212531120.png" alt="image-20230324212531120"></p><h3 id="MySQL图形化界面"><a href="#MySQL图形化界面" class="headerlink" title="MySQL图形化界面"></a>MySQL图形化界面</h3><p><img src="/MySQL.assets/image-20230324212917885.png" alt="image-20230324212917885"></p><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="添加数据-insert"><a href="#添加数据-insert" class="headerlink" title="添加数据-insert"></a>添加数据-insert</h3><p><img src="/MySQL.assets/image-20230327211719068.png" alt="image-20230327211719068"></p><h3 id="修改数据-update"><a href="#修改数据-update" class="headerlink" title="修改数据-update"></a>修改数据-update</h3><p><img src="/MySQL.assets/image-20230327213615300.png" alt="image-20230327213615300"></p><h3 id="删除数据-delete"><a href="#删除数据-delete" class="headerlink" title="删除数据-delete"></a>删除数据-delete</h3><p><img src="/MySQL.assets/image-20230327214340341.png" alt="image-20230327214340341"></p><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>编写顺序</li></ul><p><img src="/MySQL.assets/image-20230327220100801.png" alt="image-20230327220100801"></p><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p><img src="/MySQL.assets/image-20230327220228434.png" alt="image-20230327220228434"></p><h3 id="条件查询-WHERE"><a href="#条件查询-WHERE" class="headerlink" title="条件查询-WHERE"></a>条件查询-WHERE</h3><p><img src="/MySQL.assets/image-20230327220751570.png" alt="image-20230327220751570"></p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><img src="/MySQL.assets/image-20230327221704196.png" alt="image-20230327221704196"></p><h3 id="分组查询-GROUP-BY"><a href="#分组查询-GROUP-BY" class="headerlink" title="分组查询-GROUP BY"></a>分组查询-GROUP BY</h3><p><img src="/MySQL.assets/image-20230327222641299.png" alt="image-20230327222641299"></p><h3 id="排序查询-ORDER-BY"><a href="#排序查询-ORDER-BY" class="headerlink" title="排序查询-ORDER BY"></a>排序查询-ORDER BY</h3><p><img src="/MySQL.assets/image-20230327223053789.png" alt="image-20230327223053789"></p><h3 id="分页查询-LIMIT"><a href="#分页查询-LIMIT" class="headerlink" title="分页查询-LIMIT"></a>分页查询-LIMIT</h3><p><img src="/MySQL.assets/image-20230327223356396.png" alt="image-20230327223356396"></p><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p><img src="/MySQL.assets/image-20230327224835996.png" alt="image-20230327224835996"></p><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><p><img src="/MySQL.assets/image-20230327230625451.png" alt="image-20230327230625451"></p><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p><img src="/MySQL.assets/image-20230327230940761.png" alt="image-20230327230940761"></p><p><img src="/MySQL.assets/image-20230327231519634.png" alt="image-20230327231519634"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p><img src="/MySQL.assets/image-20230328215307860.png" alt="image-20230328215307860"></p><p><img src="/MySQL.assets/image-20230328221057895.png" alt="image-20230328221057895"></p><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><p><img src="/MySQL.assets/image-20230328221015308.png" alt="image-20230328221015308"></p><p><img src="/MySQL.assets/image-20230328221028802.png" alt="image-20230328221028802"></p><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><p><img src="/MySQL.assets/image-20230328220958080.png" alt="image-20230328220958080"></p><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><p><img src="/MySQL.assets/image-20230328222238644.png" alt="image-20230328222238644"></p><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/MySQL.assets/image-20230328223655749.png" alt="image-20230328223655749"></p><p>主键约束，唯一约束，外键约束，默认约束，非空约束</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ul><li>auto_increment</li></ul><p><img src="/MySQL.assets/image-20230328224819845.png" alt="image-20230328224819845"></p><p><img src="/MySQL.assets/image-20230328230139349.png" alt="image-20230328230139349"></p><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p><img src="/MySQL.assets/image-20230328230321365.png" alt="image-20230328230321365"></p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><img src="/MySQL.assets/image-20230328231207378.png" alt="image-20230328231207378"></p><h3 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除&#x2F;更新行为"></a>删除&#x2F;更新行为</h3><p><img src="/MySQL.assets/image-20230328231728965.png" alt="image-20230328231728965"></p><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><img src="/MySQL.assets/image-20230329193608908.png" alt="image-20230329193608908"></p><h3 id="一对多（多对一）"><a href="#一对多（多对一）" class="headerlink" title="一对多（多对一）"></a>一对多（多对一）</h3><p><img src="/MySQL.assets/image-20230329193701288.png" alt="image-20230329193701288"></p><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p><img src="/MySQL.assets/image-20230329193807535.png" alt="image-20230329193807535"></p><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><ul><li>单表拆分</li></ul><p><img src="/MySQL.assets/image-20230329194148240.png" alt="image-20230329194148240"></p><h2 id="多表查询概述"><a href="#多表查询概述" class="headerlink" title="多表查询概述"></a>多表查询概述</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><img src="/MySQL.assets/image-20230329194735019.png" alt="image-20230329194735019"></p><h3 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h3><p><img src="/MySQL.assets/image-20230329195037622.png" alt="image-20230329195037622"></p><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p><img src="/MySQL.assets/image-20230329195559376.png" alt="image-20230329195559376"></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><img src="/MySQL.assets/image-20230329200702073.png" alt="image-20230329200702073"></p><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><ul><li>连接起来的数据就是交集</li></ul><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p><img src="/MySQL.assets/image-20230329200030067.png" alt="image-20230329200030067"></p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p><img src="/MySQL.assets/image-20230329200831573.png" alt="image-20230329200831573"></p><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p><img src="/MySQL.assets/image-20230329200311395.png" alt="image-20230329200311395"></p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><ul><li>起别名<ul><li>+内连接查询</li><li>+外连接查询</li></ul></li></ul><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p><img src="/MySQL.assets/image-20230329200610400.png" alt="image-20230329200610400"></p><h2 id="联合查询-union，union-all"><a href="#联合查询-union，union-all" class="headerlink" title="联合查询-union，union all"></a>联合查询-union，union all</h2><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><p><img src="/MySQL.assets/image-20230329201554934.png" alt="image-20230329201554934"></p><ul><li>放到where and？？</li></ul><h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><p><img src="/MySQL.assets/image-20230329201458450.png" alt="image-20230329201458450"></p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="/MySQL.assets/image-20230329201828624.png" alt="image-20230329201828624"></p><h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><p><img src="/MySQL.assets/image-20230329202325650.png" alt="image-20230329202325650"></p><h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><p><img src="/MySQL.assets/image-20230329203143199.png" alt="image-20230329203143199"></p><h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><p><img src="/MySQL.assets/image-20230329203640797.png" alt="image-20230329203640797"></p><p><img src="/MySQL.assets/image-20230329203529712.png" alt="image-20230329203529712"></p><h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><p><img src="/MySQL.assets/image-20230329204413278.png" alt="image-20230329204413278"></p><p><img src="/MySQL.assets/image-20230329204355526.png" alt="image-20230329204355526"></p><h2 id="多表查询案例"><a href="#多表查询案例" class="headerlink" title="多表查询案例"></a>多表查询案例</h2><p><img src="/MySQL.assets/image-20230329214333364.png" alt="image-20230329214333364"></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><p><img src="/MySQL.assets/image-20230330215832010.png" alt="image-20230330215832010"></p><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p><img src="/MySQL.assets/image-20230330220750338.png" alt="image-20230330220750338"></p><img src="MySQL.assets/image-20230330220816287.png" alt="image-20230330220816287" style="zoom:50%;" /><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p><img src="/MySQL.assets/image-20230330221103526.png" alt="image-20230330221103526"></p><img src="MySQL.assets/image-20230330221046516.png" alt="image-20230330221046516" style="zoom:50%;" /><h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><ul><li>原子性、一致性、隔离性、持久性(ACID)</li></ul><p><img src="/MySQL.assets/image-20230330221706198.png" alt="image-20230330221706198"></p><h2 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><img src="/MySQL.assets/image-20230330222314014.png" alt="image-20230330222314014"></p><p><img src="/MySQL.assets/image-20230330222324250.png" alt="image-20230330222324250"></p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><img src="/MySQL.assets/image-20230330222347442.png" alt="image-20230330222347442"></p><p><img src="/MySQL.assets/image-20230330222412802.png" alt="image-20230330222412802"></p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p><img src="/MySQL.assets/image-20230330222429085.png" alt="image-20230330222429085"></p><p><img src="/MySQL.assets/image-20230330222450329.png" alt="image-20230330222450329"></p><h2 id="事务的隔离级别-解决上述问题"><a href="#事务的隔离级别-解决上述问题" class="headerlink" title="事务的隔离级别-解决上述问题"></a>事务的隔离级别-解决上述问题</h2><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><img src="/MySQL.assets/image-20230330223911400.png" alt="image-20230330223911400"></p><ul><li>Repeatable Read<ul><li>可重复读</li></ul></li><li>Serializable<ul><li>串行化</li></ul></li></ul><h1 id="—-进阶篇-—"><a href="#—-进阶篇-—" class="headerlink" title="—&#x3D;&#x3D;进阶篇&#x3D;&#x3D;—"></a>—&#x3D;&#x3D;进阶篇&#x3D;&#x3D;—</h1><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><p><img src="/MySQL.assets/image-20230410155215672.png" alt="image-20230410155215672"></p><h2 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h2><p><img src="/MySQL.assets/image-20230410160113704.png" alt="image-20230410160113704"></p><ul><li>指定存储引擎</li></ul><p><img src="/MySQL.assets/image-20230410160400489.png" alt="image-20230410160400489"></p><h2 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h2><p><img src="/MySQL.assets/image-20230410160822162.png" alt="image-20230410160822162"></p><ul><li>MyISAM</li></ul><p><img src="/MySQL.assets/image-20230410161543279.png" alt="image-20230410161543279"></p><ul><li>Memory</li></ul><p><img src="/MySQL.assets/image-20230410161639930.png" alt="image-20230410161639930"></p><ul><li>区别<ul><li>InnoDB与MyISAM的区别：&#x3D;&#x3D;<strong>事务，外键，行级锁</strong>&#x3D;&#x3D;</li></ul></li></ul><p><img src="/MySQL.assets/image-20230410161818780.png" alt="image-20230410161818780"></p><h2 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h2><p><img src="/MySQL.assets/image-20230410161325634.png" alt="image-20230410161325634"></p><h2 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h2><p><img src="/MySQL.assets/image-20230410162057561.png" alt="image-20230410162057561"></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><p><img src="/MySQL.assets/image-20230410175748776.png" alt="image-20230410175748776"></p><ul><li>优缺点</li></ul><p><img src="/MySQL.assets/image-20230410180358440.png" alt="image-20230410180358440"></p><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><h3 id="索引结构-1"><a href="#索引结构-1" class="headerlink" title="索引结构"></a>索引结构</h3><p><img src="/MySQL.assets/image-20230410180601877.png" alt="image-20230410180601877"></p><h3 id="数据库支持"><a href="#数据库支持" class="headerlink" title="数据库支持"></a>数据库支持</h3><p><img src="/MySQL.assets/image-20230410180721301.png" alt="image-20230410180721301"></p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><img src="/MySQL.assets/image-20230410185103158.png" alt="image-20230410185103158"></p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="/MySQL.assets/image-20230410185525020.png" alt="image-20230410185525020"></p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+-Tree"></a>B+-Tree</h3><p><img src="/MySQL.assets/image-20230410190020819.png" alt="image-20230410190020819"></p><p><img src="/MySQL.assets/image-20230410190158988.png" alt="image-20230410190158988"></p><ul><li><h3 id="mysql中的B-Tree"><a href="#mysql中的B-Tree" class="headerlink" title="mysql中的B+Tree"></a>mysql中的B+Tree</h3></li></ul><p><img src="/MySQL.assets/image-20230410190411492.png" alt="image-20230410190411492"></p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><img src="/MySQL.assets/image-20230410190630228.png" alt="image-20230410190630228"></p><p><img src="/MySQL.assets/image-20230410190736737.png" alt="image-20230410190736737"></p><h3 id="思考：为什么InnoDB存储引擎选择使用B-tree"><a href="#思考：为什么InnoDB存储引擎选择使用B-tree" class="headerlink" title="思考：为什么InnoDB存储引擎选择使用B+tree"></a>思考：为什么InnoDB存储引擎选择使用B+tree</h3><p><img src="/MySQL.assets/image-20230410191007889.png" alt="image-20230410191007889"></p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="/MySQL.assets/image-20230410191432748.png" alt="image-20230410191432748"></p><h3 id="在InnoDB存储引擎中"><a href="#在InnoDB存储引擎中" class="headerlink" title="在InnoDB存储引擎中"></a>在InnoDB存储引擎中</h3><ul><li>聚集索引</li><li>二级索引</li></ul><p><img src="/MySQL.assets/image-20230410191644407.png" alt="image-20230410191644407"></p><p><img src="/MySQL.assets/image-20230410191818338.png" alt="image-20230410191818338"></p><h3 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h3><p><img src="/MySQL.assets/image-20230410191958651.png" alt="image-20230410191958651"></p><h3 id="思考：InnoDB主键索引的B-tree高度为多高"><a href="#思考：InnoDB主键索引的B-tree高度为多高" class="headerlink" title="思考：InnoDB主键索引的B+tree高度为多高"></a>思考：InnoDB主键索引的B+tree高度为多高</h3><img src="MySQL.assets/image-20230410192752339.png" alt="image-20230410192752339" style="zoom:50%;" /><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p><img src="/MySQL.assets/image-20230410192945873.png" alt="image-20230410192945873"></p><h3 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h3><p><img src="/MySQL.assets/image-20230410194327256.png" alt="image-20230410194327256"></p><h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><h3 id="查看SQL的执行频次"><a href="#查看SQL的执行频次" class="headerlink" title="查看SQL的执行频次"></a>查看SQL的执行频次</h3><p><img src="/MySQL.assets/image-20230411110849997.png" alt="image-20230411110849997"></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p><img src="/MySQL.assets/image-20230411112105822.png" alt="image-20230411112105822"></p><h3 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h3><p><img src="/MySQL.assets/image-20230411121014460.png" alt="image-20230411121014460"></p><h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3><p><img src="/MySQL.assets/image-20230411121220855.png" alt="image-20230411121220855"></p><p><img src="/MySQL.assets/image-20230411122717210.png" alt="image-20230411122717210"></p><p><img src="/MySQL.assets/image-20230411123021066.png" alt="image-20230411123021066"></p><h2 id="索引使用规则"><a href="#索引使用规则" class="headerlink" title="索引使用规则"></a>索引使用规则</h2><h3 id="验证索引效率"><a href="#验证索引效率" class="headerlink" title="验证索引效率"></a>验证索引效率</h3><p><img src="/MySQL.assets/image-20230411164240186.png" alt="image-20230411164240186"></p><h3 id="最左前缀法则-联合索引"><a href="#最左前缀法则-联合索引" class="headerlink" title="最左前缀法则-联合索引"></a>最左前缀法则-联合索引</h3><p><img src="/MySQL.assets/image-20230411164813456.png" alt="image-20230411164813456"></p><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p><img src="/MySQL.assets/image-20230411165007433.png" alt="image-20230411165007433"></p><h3 id="索引失效情况一"><a href="#索引失效情况一" class="headerlink" title="索引失效情况一"></a>索引失效情况一</h3><h4 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h4><p><img src="/MySQL.assets/image-20230411165355974.png" alt="image-20230411165355974"></p><h4 id="字符串不加单引号"><a href="#字符串不加单引号" class="headerlink" title="字符串不加单引号"></a>字符串不加单引号</h4><p><img src="/MySQL.assets/image-20230411165549374.png" alt="image-20230411165549374"></p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p><img src="/MySQL.assets/image-20230411165732292.png" alt="image-20230411165732292"></p><h3 id="索引失效情况二"><a href="#索引失效情况二" class="headerlink" title="索引失效情况二"></a>索引失效情况二</h3><h4 id="or连接的条件"><a href="#or连接的条件" class="headerlink" title="or连接的条件"></a>or连接的条件</h4><p><img src="/MySQL.assets/image-20230411170046513.png" alt="image-20230411170046513"></p><h4 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h4><p><img src="/MySQL.assets/image-20230411170533306.png" alt="image-20230411170533306"></p><h3 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h3><p><img src="/MySQL.assets/image-20230411171143472.png" alt="image-20230411171143472"></p><h3 id="覆盖索引-回表查询"><a href="#覆盖索引-回表查询" class="headerlink" title="覆盖索引&amp;回表查询"></a>覆盖索引&amp;回表查询</h3><ul><li>查询展示的字段在二级索引中都有不需要回表查询</li></ul><p><img src="/MySQL.assets/image-20230411172510183.png" alt="image-20230411172510183"></p><p><img src="/MySQL.assets/image-20230411172536552.png" alt="image-20230411172536552"></p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p><img src="/MySQL.assets/image-20230411172620811.png" alt="image-20230411172620811"></p><ul><li>对username，password建立联合索引</li></ul><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul><li>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</li><li>使用前缀索引<strong>就用不上覆盖索</strong>引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素</li></ul><p><img src="/MySQL.assets/image-20230411181458443.png" alt="image-20230411181458443"></p><p><img src="/MySQL.assets/image-20230411181755951.png" alt="image-20230411181755951"></p><h3 id="单列-联合索引"><a href="#单列-联合索引" class="headerlink" title="单列&amp;联合索引"></a>单列&amp;联合索引</h3><p><img src="/MySQL.assets/image-20230411182147455.png" alt="image-20230411182147455"></p><p><img src="/MySQL.assets/image-20230411182303760.png" alt="image-20230411182303760"></p><h2 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h2><p><img src="/MySQL.assets/image-20230411183120771.png" alt="image-20230411183120771"></p><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="insert优化-批量插入"><a href="#insert优化-批量插入" class="headerlink" title="insert优化-批量插入"></a>insert优化-批量插入</h3><ul><li>批量插入、手动提交事务、主键顺序插入</li></ul><p><img src="/MySQL.assets/image-20230412192852718.png" alt="image-20230412192852718"></p><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><p><img src="/MySQL.assets/image-20230412194111435.png" alt="image-20230412194111435"></p><h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><h3 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h3><p><img src="/MySQL.assets/image-20230412194347795.png" alt="image-20230412194347795"></p><p><img src="/MySQL.assets/image-20230412194410128.png" alt="image-20230412194410128"></p><h3 id="主键乱序-插入-会出先-页分裂"><a href="#主键乱序-插入-会出先-页分裂" class="headerlink" title="主键乱序&#x3D;&#x3D;插入&#x3D;&#x3D;会出先&#x3D;&#x3D;页分裂&#x3D;&#x3D;"></a>主键乱序&#x3D;&#x3D;插入&#x3D;&#x3D;会出先&#x3D;&#x3D;页分裂&#x3D;&#x3D;</h3><p><img src="/MySQL.assets/image-20230412194650226.png" alt="image-20230412194650226"></p><h3 id="删除-时会出现-页合并"><a href="#删除-时会出现-页合并" class="headerlink" title="&#x3D;&#x3D;删除&#x3D;&#x3D;时会出现&#x3D;&#x3D;页合并&#x3D;&#x3D;"></a>&#x3D;&#x3D;删除&#x3D;&#x3D;时会出现&#x3D;&#x3D;页合并&#x3D;&#x3D;</h3><p><img src="/MySQL.assets/image-20230412194848674.png" alt="image-20230412194848674"></p><h3 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h3><p><img src="/MySQL.assets/image-20230412195231586.png" alt="image-20230412195231586"></p><h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><p><img src="/MySQL.assets/image-20230412200056847.png" alt="image-20230412200056847"></p><p><img src="/MySQL.assets/image-20230412200212488.png" alt="image-20230412200212488"></p><h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><p><img src="/MySQL.assets/image-20230412200656094.png" alt="image-20230412200656094"></p><h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p><img src="/MySQL.assets/image-20230412201442068.png" alt="image-20230412201442068"></p><h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p><img src="/MySQL.assets/image-20230412201708895.png" alt="image-20230412201708895"></p><h3 id="count的几种用法及效率"><a href="#count的几种用法及效率" class="headerlink" title="count的几种用法及效率"></a>count的几种用法及效率</h3><p><img src="/MySQL.assets/image-20230412202143012.png" alt="image-20230412202143012"></p><p><img src="/MySQL.assets/image-20230412202325761.png" alt="image-20230412202325761"></p><h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><ul><li>InooDB中用索引行级锁，反之表锁</li></ul><p><img src="/MySQL.assets/image-20230412203322640.png" alt="image-20230412203322640"></p><h1 id="视图-view"><a href="#视图-view" class="headerlink" title="视图-view"></a>视图-view</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/MySQL.assets/image-20230412210803820.png" alt="image-20230412210803820"></p><h2 id="视图创建，查询，修改，删除"><a href="#视图创建，查询，修改，删除" class="headerlink" title="视图创建，查询，修改，删除"></a>视图创建，查询，修改，删除</h2><p><img src="/MySQL.assets/image-20230412211534987.png" alt="image-20230412211534987"></p><h2 id="视图的检查选项-cascaded-local"><a href="#视图的检查选项-cascaded-local" class="headerlink" title="视图的检查选项 cascaded&#x2F;local"></a>视图的检查选项 cascaded&#x2F;local</h2><ul><li>cascaded：<strong>级联</strong><ul><li>会将上层依赖的视图都加上with cascaded check option；</li></ul></li></ul><p><img src="/MySQL.assets/image-20230412212525743.png" alt="image-20230412212525743"></p><ul><li>local<ul><li>不会将上层依赖的视图加with local check option; 但是会检查上层（是否有选择选项等）</li></ul></li></ul><p><img src="/MySQL.assets/image-20230412212710748.png" alt="image-20230412212710748"></p><h2 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h2><p><img src="/MySQL.assets/image-20230412213322542.png" alt="image-20230412213322542"></p><h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><p><img src="/MySQL.assets/image-20230412213614608.png" alt="image-20230412213614608"></p><ul><li>数据独立<ul><li>若基表中列改名了，可以如下图保证视图的列名不变</li></ul></li></ul><p><img src="/MySQL.assets/image-20230412213722313.png" alt="image-20230412213722313"></p><h2 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h2><p><img src="/MySQL.assets/image-20230412213941942.png" alt="image-20230412213941942"></p><h1 id="存储过程-procedure"><a href="#存储过程-procedure" class="headerlink" title="存储过程-procedure"></a>存储过程-procedure</h1><h2 id="介绍-特点-基本语法"><a href="#介绍-特点-基本语法" class="headerlink" title="介绍&amp;特点&amp;基本语法"></a>介绍&amp;特点&amp;基本语法</h2><ul><li>事先定义并存储在数据库中的一段SQL逻辑</li></ul><p><img src="/MySQL.assets/image-20230413100655318.png" alt="image-20230413100655318"></p><ul><li>特点<ul><li>封装，复用</li><li>可以接收参数，也可以返回数据</li><li>减少网络交互，效率提升</li></ul></li></ul><p><img src="/MySQL.assets/image-20230413101339267.png" alt="image-20230413101339267"></p><p><img src="/MySQL.assets/image-20230413102738514.png" alt="image-20230413102738514"></p><ul><li>delimiter<ul><li>告诉mysql解释器，该段命令是否已经结束了</li></ul></li></ul><p><img src="/MySQL.assets/image-20230413102942830.png" alt="image-20230413102942830"></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p><img src="/MySQL.assets/image-20230413105239386.png" alt="image-20230413105239386"></p><h4 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h4><p><img src="/MySQL.assets/image-20230413105631063.png" alt="image-20230413105631063"></p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p><img src="/MySQL.assets/image-20230413110116909.png" alt="image-20230413110116909"></p><ul><li><h4 id="用-赋值"><a href="#用-赋值" class="headerlink" title="用 :&#x3D; 赋值"></a>用 :&#x3D; 赋值</h4></li></ul><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p><img src="/MySQL.assets/image-20230413110524209.png" alt="image-20230413110524209"></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><img src="/MySQL.assets/image-20230413110703856.png" alt="image-20230413110703856"></p><p><img src="/MySQL.assets/image-20230413111625637.png" alt="image-20230413111625637"></p><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><ul><li>与流程控制中的函数类似</li><li>语法一和switch类似</li><li>语法二和if else类似</li></ul><p><img src="/MySQL.assets/image-20230413112220372.png" alt="image-20230413112220372"></p><ul><li><strong>练习</strong></li></ul><p><img src="/MySQL.assets/image-20230413113346975.png" alt="image-20230413113346975"></p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p><img src="/MySQL.assets/image-20230413162245968.png" alt="image-20230413162245968"></p><p><img src="/MySQL.assets/image-20230413163953316.png" alt="image-20230413163953316"></p><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><ul><li><p>满足条件则退出循环</p></li><li><p>先判断一次在进行循环</p></li></ul><p><img src="/MySQL.assets/image-20230413162327031.png" alt="image-20230413162327031"></p><p><img src="/MySQL.assets/image-20230413163951475.png" alt="image-20230413163951475"></p><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p><img src="/MySQL.assets/image-20230413163019711.png" alt="image-20230413163019711"></p><p><img src="/MySQL.assets/image-20230413163944328.png" alt="image-20230413163944328"></p><h3 id="游标cursor"><a href="#游标cursor" class="headerlink" title="游标cursor"></a>游标cursor</h3><ul><li>局部变量不能接收一个表的内容</li><li>游标可以存储查询结果集</li></ul><p><img src="/MySQL.assets/image-20230413164250669.png" alt="image-20230413164250669"></p><p><img src="/MySQL.assets/image-20230413165004949.png" alt="image-20230413165004949"></p><img src="MySQL.assets/image-20230413165244102.png" alt="image-20230413165244102" style="zoom:50%;" /><h4 id="条件处理程序handler"><a href="#条件处理程序handler" class="headerlink" title="条件处理程序handler"></a>条件处理程序handler</h4><ul><li>配合游标cursor使用</li></ul><p><img src="/MySQL.assets/image-20230413165444349.png" alt="image-20230413165444349"></p><img src="MySQL.assets/image-20230413165832243.png" alt="image-20230413165832243" style="zoom:50%;" /><img src="MySQL.assets/image-20230413165905165.png" alt="image-20230413165905165" style="zoom:50%;" /><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><blockquote><p>有返回的存储过程，参数类型只能是in</p></blockquote><ul><li>比较少用<ul><li>因为存储函数能做的事情存储过程也能做，而且存储函数需要返回值</li></ul></li></ul><p><img src="/MySQL.assets/image-20230413170133512.png" alt="image-20230413170133512"></p><h1 id="触发器-trigger"><a href="#触发器-trigger" class="headerlink" title="触发器-trigger"></a>触发器-trigger</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul><li>可以确保数据完整性、日志记录、数据检验</li></ul><img src="MySQL.assets/image-20230413171240665.png" alt="image-20230413171240665" style="zoom:67%;" /><ul><li>行级触发器表示操作了某行而触发</li><li>语句触发器表示执行了某条语句，例如update而触发</li></ul><h2 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h2><p><img src="/MySQL.assets/image-20230413171557581.png" alt="image-20230413171557581"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_name</span><br><span class="line">after<span class="operator">/</span>before <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">delete</span><span class="operator">/</span><span class="keyword">update</span> <span class="keyword">on</span> table_name <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">...;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="案例-日志记录"><a href="#案例-日志记录" class="headerlink" title="案例-日志记录"></a>案例-日志记录</h2><ul><li><strong>通过触发器记录表的变更日志</strong></li></ul><p><img src="/MySQL.assets/image-20230413172217154.png" alt="image-20230413172217154"></p><h3 id="插入触发器"><a href="#插入触发器" class="headerlink" title="插入触发器"></a>插入触发器</h3><p><img src="/MySQL.assets/image-20230413172626101.png" alt="image-20230413172626101"></p><h3 id="修改触发器"><a href="#修改触发器" class="headerlink" title="修改触发器"></a>修改触发器</h3><p><img src="/MySQL.assets/image-20230413172928603.png" alt="image-20230413172928603"></p><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p><img src="/MySQL.assets/image-20230413173259613.png" alt="image-20230413173259613"></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="介绍和分类"><a href="#介绍和分类" class="headerlink" title="介绍和分类"></a>介绍和分类</h2><p><img src="/MySQL.assets/image-20230415110143532.png" alt="image-20230415110143532"></p><p><img src="/MySQL.assets/image-20230415110233907.png" alt="image-20230415110233907"></p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ul><li>获取一致性视图，保证数据的完整性</li></ul><p></p><p><img src="/MySQL.assets/image-20230415110607810.png" alt="image-20230415110607810"></p><ul><li><strong>加了全局锁后</strong></li></ul><p><img src="/MySQL.assets/image-20230415110814525.png" alt="image-20230415110814525"></p><h3 id="语法和演示"><a href="#语法和演示" class="headerlink" title="语法和演示"></a>语法和演示</h3><ul><li>mysqldump是MySQL提供的命令，在命令行使用</li><li>flush tables with read lock</li></ul><p><img src="/MySQL.assets/image-20230415110925175.png" alt="image-20230415110925175"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><img src="/MySQL.assets/image-20230415111618492.png" alt="image-20230415111618492"></p><h3 id="不加锁实现一致性数据备份"><a href="#不加锁实现一致性数据备份" class="headerlink" title="不加锁实现一致性数据备份"></a>不加锁实现一致性数据备份</h3><ul><li>加上选项<ul><li><strong>–single transcation</strong></li></ul></li></ul><p><img src="/MySQL.assets/image-20230415111648911.png" alt="image-20230415111648911"></p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="介绍和分类-1"><a href="#介绍和分类-1" class="headerlink" title="介绍和分类"></a>介绍和分类</h3><p><img src="/MySQL.assets/image-20230415150247883.png" alt="image-20230415150247883"></p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul><li>read lock<ul><li>自己和其他客户端都不可以write，但都可以read</li></ul></li><li>write lock<ul><li>自己可以read和write，其他客户端都不可以</li></ul></li></ul><p><img src="/MySQL.assets/image-20230415151540175.png" alt="image-20230415151540175"></p><h3 id="元数据锁-解决DML和DDL的冲突"><a href="#元数据锁-解决DML和DDL的冲突" class="headerlink" title="元数据锁-解决DML和DDL的冲突"></a>元数据锁-<del>解决DML和DDL的冲突</del></h3><ul><li><p>存在没有提交的事务时候，不可以对元数据进行写入操作</p></li><li><p>为了<strong>避免DML与DDL冲突</strong>，保证读写的正确性</p></li><li><p>SHAREAD_READ,与SHAREAD_WRITE 共享</p></li><li><p>EXCLUSIVE与SHAREAD_READ, SHAREAD_WRITE 互斥</p></li></ul><p><img src="/MySQL.assets/image-20230415153217488.png" alt="image-20230415153217488"></p><h3 id="意向锁-解决行锁和表锁的冲突"><a href="#意向锁-解决行锁和表锁的冲突" class="headerlink" title="意向锁-解决行锁和表锁的冲突"></a>意向锁-<del>解决行锁和表锁的冲突</del></h3><ul><li><p>行锁出现时同时出现、自动加的</p></li><li><p>为了解决<strong>行锁和表锁</strong>的冲突</p></li><li><p>为了避免DML在执行时，加的<strong>行锁和表锁</strong>的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</p></li></ul><p><img src="/MySQL.assets/image-20230415154219324.png" alt="image-20230415154219324"></p><p><img src="/MySQL.assets/image-20230415154519479.png" alt="image-20230415154519479"></p><ul><li>意向锁和表锁的兼容情况</li></ul><p><img src="/MySQL.assets/image-20230415154001270.png" alt="image-20230415154001270"></p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><ul><li>行级锁<ul><li>不给update、delete该行</li></ul></li><li>间隙锁<ul><li>不给在改行前insert</li></ul></li><li>临建锁<ul><li>行级锁和间隙锁组合</li></ul></li></ul><p><img src="/MySQL.assets/image-20230415155926954.png" alt="image-20230415155926954"></p><h3 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h3><ul><li>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议</li></ul><h3 id="行锁的两种类型-共享锁和排他锁"><a href="#行锁的两种类型-共享锁和排他锁" class="headerlink" title="行锁的两种类型-共享锁和排他锁"></a>行锁的两种类型-共享锁和排他锁</h3><p><img src="/MySQL.assets/image-20230415160155508.png" alt="image-20230415160155508"></p><h3 id="设置行级锁"><a href="#设置行级锁" class="headerlink" title="设置行级锁"></a>设置行级锁</h3><p><img src="/MySQL.assets/image-20230415160355063.png" alt="image-20230415160355063"></p><ul><li><p>lock in share mode 是当前读</p></li><li><p>for update 是当前读</p></li></ul><h3 id="索引与行锁"><a href="#索引与行锁" class="headerlink" title="索引与行锁"></a>索引与行锁</h3><p><img src="/MySQL.assets/image-20230415161044831.png" alt="image-20230415161044831"></p><h3 id="间隙锁-临建锁"><a href="#间隙锁-临建锁" class="headerlink" title="间隙锁&#x2F;临建锁"></a>间隙锁&#x2F;临建锁</h3><ul><li><p>间隙锁-防止多个事务并发操作时出现幻读</p></li><li><p>next-key锁：临建锁</p></li></ul><p><img src="/MySQL.assets/image-20230415162028221.png" alt="image-20230415162028221"></p><h1 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h1><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><ul><li>每个区的大小为1M，默认情况下，InnoDB存储引擎页大小为16k，即一个区中一共有64个连续的页</li><li>为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区</li></ul><p><img src="/MySQL.assets/image-20230416122627023.png" alt="image-20230416122627023"></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="总架构"><a href="#总架构" class="headerlink" title="总架构"></a>总架构</h3><p><img src="/MySQL.assets/image-20230416122742269.png" alt="image-20230416122742269"></p><h3 id="内存架构-In-Memory-Structures"><a href="#内存架构-In-Memory-Structures" class="headerlink" title="内存架构 In-Memory Structures"></a>内存架构 In-Memory Structures</h3><blockquote><p>减小磁盘I&#x2F;O</p></blockquote><p><img src="/MySQL.assets/IMG_20230520_172812-1684574935349-2.jpg" alt="IMG_20230520_172812"></p><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><blockquote><p>缓冲区</p></blockquote><p><img src="/MySQL.assets/image-20230416123243887.png" alt="image-20230416123243887"></p><h4 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h4><blockquote><p>更改缓冲区</p><p>作用对象是非唯一辅助索引（二级索引）</p></blockquote><ul><li>insert buffer的升级</li></ul><p><img src="/MySQL.assets/image-20230416124116201.png" alt="image-20230416124116201"></p><h4 id="Adaptive-Hash-Index"><a href="#Adaptive-Hash-Index" class="headerlink" title="Adaptive Hash Index"></a>Adaptive Hash Index</h4><blockquote><p>自适应哈希</p><p>等值查询</p></blockquote><ul><li>如果观察到hash索引可以提升速度，则建立hash索引</li></ul><p><img src="/MySQL.assets/image-20230416123642720.png" alt="image-20230416123642720"></p><h4 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h4><blockquote><p>日志缓冲区</p></blockquote><p><img src="/MySQL.assets/image-20230416124201356.png" alt="image-20230416124201356"></p><h5 id="redo-log（重做日志缓冲区）"><a href="#redo-log（重做日志缓冲区）" class="headerlink" title="redo log（重做日志缓冲区）"></a>redo log（重做日志缓冲区）</h5><ul><li>由重做缓冲区（redo log buffer）以及重做日志文件（redo log）组成<ul><li>前者在内存中，后者在磁盘中</li><li>Master Thread 每一秒将重做日志缓冲刷新到重做日志文件中</li><li>当时<strong>事务被提交</strong>时将重做日志缓冲刷新到重做日志文件中</li><li>当重做日志缓冲池剩余空间小于1&#x2F;2时，将重做日志缓冲刷新到重做日志文件中</li></ul></li></ul><h3 id="磁盘架构-On-Disk-Structures"><a href="#磁盘架构-On-Disk-Structures" class="headerlink" title="磁盘架构 On-Disk Structures"></a>磁盘架构 On-Disk Structures</h3><h4 id="System-Tablespace-File-Per-Table-Tablespaces"><a href="#System-Tablespace-File-Per-Table-Tablespaces" class="headerlink" title="System Tablespace &#x3D;&#x3D;&amp;&#x3D;&#x3D; File-Per-Table Tablespaces"></a>System Tablespace &#x3D;&#x3D;&amp;&#x3D;&#x3D; File-Per-Table Tablespaces</h4><blockquote><p>系统表空间</p></blockquote><p><img src="/MySQL.assets/image-20230416124558192.png" alt="image-20230416124558192"></p><h4 id="General-Tablespaces-Undo-Tablespaces-Temporary-Tablespaces"><a href="#General-Tablespaces-Undo-Tablespaces-Temporary-Tablespaces" class="headerlink" title="General Tablespaces &#x3D;&#x3D;&amp;&#x3D;&#x3D; Undo Tablespaces &#x3D;&#x3D;&amp;&#x3D;&#x3D; Temporary Tablespaces"></a>General Tablespaces &#x3D;&#x3D;&amp;&#x3D;&#x3D; Undo Tablespaces &#x3D;&#x3D;&amp;&#x3D;&#x3D; Temporary Tablespaces</h4><blockquote><p>通用表空间 &amp; 撤销表空间 &amp; 临时表空间</p></blockquote><p><img src="/MySQL.assets/image-20230416125320433.png" alt="image-20230416125320433"></p><h4 id="Doublewrite-Buffer-Files-Redo-Log"><a href="#Doublewrite-Buffer-Files-Redo-Log" class="headerlink" title="Doublewrite Buffer Files &#x3D;&#x3D;&amp;&#x3D;&#x3D; Redo Log"></a>Doublewrite Buffer Files &#x3D;&#x3D;&amp;&#x3D;&#x3D; Redo Log</h4><blockquote><p>双写缓冲区 &amp; 重做日志</p></blockquote><p><img src="/MySQL.assets/image-20230416125708360.png" alt="image-20230416125708360"></p><h5 id="双写缓冲区"><a href="#双写缓冲区" class="headerlink" title="双写缓冲区"></a>双写缓冲区</h5><ul><li>两次写</li><li>innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入到双写缓冲区文件中，便于<strong>系统异常恢复数据</strong></li><li>修复页（例如修复表结构的错误）</li></ul><h5 id="redo-log（重做日志文件）"><a href="#redo-log（重做日志文件）" class="headerlink" title="redo log（重做日志文件）"></a>redo log（重做日志文件）</h5><ul><li><p>用于在<strong>刷新脏页的时候</strong>，发送错误时，进行数据恢复使用</p></li><li><p>由重做缓冲区（redo log buffer）以及重做日志文件（redo log）组成</p><ul><li>前者在内存中，后者在磁盘中</li><li>Master Thread 每一秒将重做日志缓冲刷新到重做日志文件中</li><li>当时<strong>事务被提交</strong>时将重做日志缓冲刷新到重做日志文件中</li><li>当重做日志缓冲池剩余空间小于1&#x2F;2时，将重做日志缓冲刷新到重做日志文件中</li></ul></li></ul><p><strong>系统异常恢复后，如果要写入的页损坏了，就用两次写的备份恢复这个页，在进行重做（redo）来恢复数据</strong></p><h3 id="内存与磁盘之间-数据的传输"><a href="#内存与磁盘之间-数据的传输" class="headerlink" title="内存与磁盘之间-数据的传输"></a>内存与磁盘之间-数据的传输</h3><p><img src="/MySQL.assets/image-20230416131135962.png" alt="image-20230416131135962"></p><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/MySQL.assets/image-20230416131819852.png" alt="image-20230416131819852"></p><p><img src="/MySQL.assets/image-20230416163344189.png" alt="image-20230416163344189"></p><ul><li>redo log + undo log保证事务一致性</li><li>MVCC+锁保证事务隔离性</li></ul><h3 id="redo-log—保证事务持久性"><a href="#redo-log—保证事务持久性" class="headerlink" title="redo log—保证事务持久性"></a>redo log—保证事务持久性</h3><blockquote><p> <strong>Write-ahead logging</strong></p></blockquote><p><img src="/MySQL.assets/image-20230421223207444.png" alt="image-20230421223207444"></p><h3 id="undo-log—保证事务原子性"><a href="#undo-log—保证事务原子性" class="headerlink" title="undo log—保证事务原子性"></a>undo log—保证事务原子性</h3><p><img src="/MySQL.assets/image-20230416133242441.png" alt="image-20230416133242441"></p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><ul><li>为了保证redo log 和 binlog 的逻辑一致</li><li>redo log 在 InnoDB引擎层，binlog 在Server层</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><blockquote><p>多版本并发控制</p></blockquote><h3 id="MVCC基本概念"><a href="#MVCC基本概念" class="headerlink" title="MVCC基本概念"></a>MVCC基本概念</h3><ul><li>当前读、快照读、MVCC<ul><li>使用当前读的语句可以在事务中直接读取当前数据，而不用看事务隔离级别</li></ul></li></ul><p><img src="/MySQL.assets/image-20230416134248033.png" alt="image-20230416134248033"></p><ul><li>所谓的MVCC(Multi-Version Concurrency Control ，多版本并发控制)指的就是在使用 READ COMMITTD 、REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</li></ul><h3 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h3><blockquote><p>三个隐藏字段+undo long版本链+readview</p></blockquote><h4 id="记录隐藏字段"><a href="#记录隐藏字段" class="headerlink" title="记录隐藏字段"></a>记录隐藏字段</h4><ul><li>事务ID</li><li>回滚指针</li></ul><p><img src="/MySQL.assets/image-20230416155128757.png" alt="image-20230416155128757"></p><ul><li>ibd2sdi 表名<ul><li>查看表空间文件</li></ul></li></ul><h4 id="undo-log-undo-log版本连"><a href="#undo-log-undo-log版本连" class="headerlink" title="undo log &amp; undo log版本连"></a>undo log &amp; undo log版本连</h4><p><img src="/MySQL.assets/image-20230416160039730.png" alt="image-20230416160039730"></p><p><img src="/MySQL.assets/image-20230416160514223.png" alt="image-20230416160514223"></p><h4 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h4><blockquote><p>用于&#x3D;&#x3D;当前快照读&#x3D;&#x3D;应该读取哪个版本</p></blockquote><h5 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h5><ul><li>max_trx_id 为当前最大事务ID+1</li></ul><p><img src="/MySQL.assets/image-20230416161400486.png" alt="image-20230416161400486"></p><h5 id="版本链数据访问规则"><a href="#版本链数据访问规则" class="headerlink" title="版本链数据访问规则"></a>版本链数据访问规则</h5><p><img src="/MySQL.assets/image-20230416162301488.png" alt="image-20230416162301488"></p><h5 id="RC-案例"><a href="#RC-案例" class="headerlink" title="RC-案例"></a>RC-案例</h5><blockquote><p>读已提交</p></blockquote><p><img src="/MySQL.assets/image-20230416162959432.png" alt="image-20230416162959432"></p><h5 id="RR-案例"><a href="#RR-案例" class="headerlink" title="RR-案例"></a>RR-案例</h5><blockquote><p>可重复读</p></blockquote><p><img src="/MySQL.assets/image-20230416163140678.png" alt="image-20230416163140678"></p><h1 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h1><h2 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h2><p><img src="/MySQL.assets/image-20230416171524670.png" alt="image-20230416171524670"></p><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ul><li>MySQL客户端工具，-e执行SQL并退出</li></ul><p><img src="/MySQL.assets/image-20230416171954328.png" alt="image-20230416171954328"></p><h3 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h3><blockquote><p>MySQL管理工具</p></blockquote><p><img src="/MySQL.assets/image-20230416172423313.png" alt="image-20230416172423313"></p><h3 id="mysqlbinlong"><a href="#mysqlbinlong" class="headerlink" title="mysqlbinlong"></a>mysqlbinlong</h3><blockquote><p>二进制日志查看工具</p></blockquote><p><img src="/MySQL.assets/image-20230416172944305.png" alt="image-20230416172944305"></p><h3 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a>mysqlshow</h3><ul><li>客户端对象查找工具，查看数据库、表、字段的统计信息和状态等</li></ul><p><img src="/MySQL.assets/image-20230416173411153.png" alt="image-20230416173411153"></p><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><blockquote><p>数据库备份工具</p></blockquote><p><img src="/MySQL.assets/image-20230416174055710.png" alt="image-20230416174055710"></p><p><img src="/MySQL.assets/image-20230416173956766.png" alt="image-20230416173956766"></p><p><img src="/MySQL.assets/image-20230416174718619.png" alt="image-20230416174718619"></p><h3 id="mysqlimprt-source"><a href="#mysqlimprt-source" class="headerlink" title="mysqlimprt&#x2F;source"></a>mysqlimprt&#x2F;source</h3><blockquote><p>数据导入工具</p></blockquote><blockquote><p>mysqlimport只能导入mysqldump -T 中备份的文本文件</p><p>source用于导入sql文件</p></blockquote><ul><li>source需要进入到mysql的命令行中进行</li></ul><p><img src="/MySQL.assets/image-20230416175104962.png" alt="image-20230416175104962"></p><p><img src="/MySQL.assets/image-20230416175327242.png" alt="image-20230416175327242"></p><h1 id="—-运维篇-—"><a href="#—-运维篇-—" class="headerlink" title="—&#x3D;&#x3D;运维篇&#x3D;&#x3D;—"></a>—&#x3D;&#x3D;运维篇&#x3D;&#x3D;—</h1><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p><img src="/MySQL.assets/image-20230419164335733.png" alt="image-20230419164335733"></p><h2 id="二进制日志-Binlog"><a href="#二进制日志-Binlog" class="headerlink" title="二进制日志(Binlog)"></a>二进制日志(Binlog)</h2><blockquote><p>binary log</p></blockquote><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/MySQL.assets/image-20230419164458088.png" alt="image-20230419164458088"></p><h3 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h3><p><img src="/MySQL.assets/image-20230419165139744.png" alt="image-20230419165139744"></p><h3 id="日志查看-mysqlbinlog"><a href="#日志查看-mysqlbinlog" class="headerlink" title="日志查看-mysqlbinlog"></a>日志查看-mysqlbinlog</h3><p><img src="/MySQL.assets/image-20230419165226072.png" alt="image-20230419165226072"></p><h3 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a>日志删除</h3><p><img src="/MySQL.assets/image-20230419165759792.png" alt="image-20230419165759792"></p><h2 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/MySQL.assets/image-20230419165935121.png" alt="image-20230419165935121"></p><h2 id="慢查询日志-1"><a href="#慢查询日志-1" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p><img src="/MySQL.assets/image-20230419170531181.png" alt="image-20230419170531181"></p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul><li>主要特点<ul><li>主库出现问题，可以快速切换到从库提供服务</li><li>读写分离，降低主库的压力</li><li>可以在从库中执行备份，以避免备份期间影响主库的服务<ul><li>在从库备份时会加全局锁，此时会出现<strong>主从延迟</strong></li></ul></li></ul></li></ul><p><img src="/MySQL.assets/image-20230419171035134.png" alt="image-20230419171035134"></p><p><img src="/MySQL.assets/image-20230419171642388.png" alt="image-20230419171642388"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="服务器主备"><a href="#服务器主备" class="headerlink" title="服务器主备"></a>服务器主备</h3><p><img src="/MySQL.assets/image-20230419171852420.png" alt="image-20230419171852420"></p><h3 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h3><p><img src="/MySQL.assets/image-20230419172046241.png" alt="image-20230419172046241"></p><p><img src="/MySQL.assets/image-20230419172438892.png" alt="image-20230419172438892"></p><h3 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h3><p><img src="/MySQL.assets/image-20230420205750167.png" alt="image-20230420205750167"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="/MySQL.assets/image-20230420210510988.png" alt="image-20230420210510988"></p><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><img src="/MySQL.assets/image-20230420211108885.png" alt="image-20230420211108885"></p><h3 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h3><p><img src="/MySQL.assets/image-20230420211208339.png" alt="image-20230420211208339"></p><h4 id="垂直拆分——拆分表-表结构"><a href="#垂直拆分——拆分表-表结构" class="headerlink" title="垂直拆分——拆分表&#x2F;表结构"></a>垂直拆分——拆分表&#x2F;表结构</h4><ul><li>垂直分库&amp;&amp;垂直分表</li></ul><p><img src="/MySQL.assets/image-20230420211431228.png" alt="image-20230420211431228"></p><h4 id="水平拆分——拆分数据"><a href="#水平拆分——拆分数据" class="headerlink" title="水平拆分——拆分数据"></a>水平拆分——拆分数据</h4><ul><li>水平分库和水平分表差不多</li></ul><p><img src="/MySQL.assets/image-20230420211820768.png" alt="image-20230420211820768"></p><h3 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h3><p><img src="/MySQL.assets/image-20230420212509539.png" alt="image-20230420212509539"></p><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><h2 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h2><h2 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="/MySQL.assets/image-20230420220701521.png" alt="image-20230420220701521"></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><img src="/MySQL.assets/image-20230420220724424.png" alt="image-20230420220724424"></p><h2 id="一主一从读写分离"><a href="#一主一从读写分离" class="headerlink" title="一主一从读写分离"></a>一主一从读写分离</h2><h3 id="Mycat配置"><a href="#Mycat配置" class="headerlink" title="Mycat配置"></a>Mycat配置</h3><p><img src="/MySQL.assets/image-20230420220923628.png" alt="image-20230420220923628"></p><p><img src="/MySQL.assets/image-20230420221104876.png" alt="image-20230420221104876"></p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p><img src="/MySQL.assets/image-20230420221602551.png" alt="image-20230420221602551"></p><h2 id="双主双从"><a href="#双主双从" class="headerlink" title="双主双从"></a>双主双从</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/MySQL.assets/image-20230420224132561.png" alt="image-20230420224132561"></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p><img src="/MySQL.assets/image-20230420224108141.png" alt="image-20230420224108141"></p><h2 id="双主双从读写分离"><a href="#双主双从读写分离" class="headerlink" title="双主双从读写分离"></a>双主双从读写分离</h2><h3 id="搭建-1"><a href="#搭建-1" class="headerlink" title="搭建"></a>搭建</h3><p><img src="/MySQL.assets/image-20230420224249854.png" alt="image-20230420224249854"></p><ul><li>对于第3台服务器一样，只不过server-id&#x3D;3</li></ul><p><img src="/MySQL.assets/image-20230420224634494.png" alt="image-20230420224634494"></p><p><img src="/MySQL.assets/image-20230420224738871.png" alt="image-20230420224738871"></p><ul><li>对于第4台服务器，只不过server-id&#x3D;2</li></ul><p><img src="/MySQL.assets/image-20230420225039252.png" alt="image-20230420225039252"></p><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p><img src="/MySQL.assets/image-20230420225423094.png" alt="image-20230420225423094"></p><h3 id="Mycat配置-1"><a href="#Mycat配置-1" class="headerlink" title="Mycat配置"></a>Mycat配置</h3><p><img src="/MySQL.assets/image-20230420225720188.png" alt="image-20230420225720188"></p><p><img src="/MySQL.assets/image-20230420225821276.png" alt="image-20230420225821276"></p><p><img src="/MySQL.assets/image-20230420230003745.png" alt="image-20230420230003745"></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++Primer查漏补缺</title>
      <link href="/2023/07/25/C++%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
      <url>/2023/07/25/C++%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="C-容易遗忘的点"><a href="#C-容易遗忘的点" class="headerlink" title="C++容易遗忘的点"></a>C++容易遗忘的点</h1><img src="C++容易遗忘的点.assets/image-20221027233950801.png" alt="image-20221027233950801" style="zoom: 50%;" /><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul><li><a href="https://blog.csdn.net/qq_40888863/article/details/119039003">https://blog.csdn.net/qq_40888863/article/details/119039003</a></li></ul><h2 id="头文件防卫式声明"><a href="#头文件防卫式声明" class="headerlink" title="头文件防卫式声明"></a>头文件防卫式声明</h2><img src="C++容易遗忘的点.assets/image-20220924201412121.png" alt="image-20220924201412121" style="zoom: 50%;" /><p><code>#Pragma once</code>也可以</p><h2 id="头文件布局"><a href="#头文件布局" class="headerlink" title="头文件布局"></a>头文件布局</h2><img src="C++容易遗忘的点.assets/image-20220924201547874.png" alt="image-20220924201547874" style="zoom:50%;" /><h2 id="位运算（二进制）的知识"><a href="#位运算（二进制）的知识" class="headerlink" title="位运算（二进制）的知识"></a>位运算（二进制）的知识</h2><ul><li><p>|或0：与1&#x3D;1，      &amp;与：1与1&#x3D;1，        ^异或（不相同为1）  （二进制对齐）</p></li><li><p>n&amp;0x1可以判断奇偶</p></li><li><p>&lt;&lt;左移 &gt;&gt;右移(二进制运算)</p></li></ul><h2 id="int-64"><a href="#int-64" class="headerlink" title="__int 64"></a>__int 64</h2><ul><li>扩大int范围（32-&gt;64）(前面有两个_ )</li></ul><h2 id="支持随机访问-迭代器-的容器"><a href="#支持随机访问-迭代器-的容器" class="headerlink" title="支持随机访问(迭代器)的容器"></a>支持随机访问(迭代器)的容器</h2><ul><li>vctor，deque，array</li></ul><h2 id="sort的第三个参数是static类型"><a href="#sort的第三个参数是static类型" class="headerlink" title="sort的第三个参数是static类型"></a>sort的第三个参数是static类型</h2><ul><li>非静态成员（non-static）函数是依赖于具体对象的，而std::sort这类函数是全局的，因此无法再sort中调用非静态成员函数。 静态成员函数或者全局函数是不依赖于具体对象的, 可以独立访问，无须创建任何对象实例就可以访问</li></ul><h2 id="当const在函数后面时"><a href="#当const在函数后面时" class="headerlink" title="当const在函数后面时"></a>当const在函数后面时</h2><ul><li>当const 在函数名前面的时候修饰的是函数返回值；在函数名后面表示是C++ 常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。 const 对象只能访问const 成员函数,而非const 对象可以访问任意的成员函数,包括const 成员函数.</li></ul><h2 id="顶层-const-和底层-const"><a href="#顶层-const-和底层-const" class="headerlink" title="顶层 const 和底层 const"></a>顶层 const 和底层 const</h2><p>从 const 指针开始说起。<code>const int* pInt;</code> 和 <code>int *const pInt = &amp;someInt;</code>，前者是 *pInt 不能改变，而后者是 pInt 不能改变。因此指针本身是不是常量和指针所指向的对象是不是常量就是两个互相独立的问题。用<strong>顶层</strong>表示指针本身是个常量，<strong>底层</strong>表示指针所指向的对象是个常量。</p><p>更一般的，顶层 const 可以表示任意的对象是常量，这一点对任何数据类型都适用；<strong>底层 const 则与指针和引用等复合类型有关</strong>，比较特殊的是，指针类型<strong>既可以是顶层</strong> const <strong>也可以是底层</strong> const 或者<strong>二者兼备</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;     <span class="comment">//  不能改变 p1 的值，这是一个顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;      <span class="comment">//  不能改变 ci 的值，这是一个顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci;    <span class="comment">//  允许改变 p2 的值，这是一个底层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2;   <span class="comment">//  靠右的 const 是顶层 const，靠左的是底层 const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci;      <span class="comment">//  所有的引用本身都是顶层 const，因为引用一旦初始化就不能再改为其他对象的引用，这里用于声明引用的 const 都是底层 const</span></span><br></pre></td></tr></table></figure><h2 id="在类内的static声明需要在类外定义"><a href="#在类内的static声明需要在类外定义" class="headerlink" title="在类内的static声明需要在类外定义"></a>在类内的static声明需要在类外定义</h2><ul><li>类内的static函数不会有this pointer</li><li>在内外定义才会为其分配内存</li></ul><h2 id="只有“const-static的整形成员”才可以在类定义体中进行初始化。"><a href="#只有“const-static的整形成员”才可以在类定义体中进行初始化。" class="headerlink" title="只有“const static的整形成员”才可以在类定义体中进行初始化。"></a>只有“const static的整形成员”才可以在类定义体中进行初始化。</h2><h2 id="exit-和-return-区别"><a href="#exit-和-return-区别" class="headerlink" title="exit() 和 return 区别"></a>exit() 和 return 区别</h2><ul><li>return 是语言级别的，表示调用堆栈的返回；而exit() 是系统调用级别的，表示进程的结束。 return 是退出(返回)函数，将控制权移交给递归的前一级；exit() 是直接退出进程。</li></ul><h2 id="menset"><a href="#menset" class="headerlink" title="menset"></a>menset</h2><ul><li><p>头文件在<cstring>？？</p></li><li><p>数组也可以直接进行初始化，但 memset 是对较大的数组或结构体进行清零初始化的最快方法，因为它是直接对内存进行操作的。</p></li></ul><h2 id="to-string-x"><a href="#to-string-x" class="headerlink" title="to_string(x)"></a>to_string(x)</h2><ul><li>将数字x转化为‘x’</li></ul><h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><ul><li><p>assert宏的原型定义在&lt;assert.h&gt;中，其作用是如果它的条件返回错误，则终止程序执行，原型定义：<br>#include &lt;assert.h&gt;<br>void assert( int expression );</p></li><li><p>assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，<br>然后通过调用 abort 来终止程序运行。</p></li></ul><p><strong>以下是使用断言的几个原则：</strong></p><ul><li>（1）使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。</li><li>（2）使用断言对函数的参数进行确认。</li><li>（3）在编写函数时，要进行反复的考查，并且自问：”我打算做哪些假定？”一旦确定了的假定，就要使用断言对假定进行检查。</li><li>（4）一般教科书都鼓励程序员们进行防错性的程序设计，但要记住这种编程风格会隐瞒错误。当进行防错性编程时，如果”不可能发生”的事情的确发生了，则要使用断言进行报警。</li></ul><p>ASSERT ()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。</p><p>ASSERT 只有在 Debug 版本中才有效，如果编译为 Release 版本则被忽略。</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><ul><li>名为remove()的STL函数（算法），它不是由对象调用，而是接受区间参数。因此，如果mylist是一个list<int>对象，则调用该函数的代码如下：remove(mylist.begin(), mylist.end(), 4);<br>然而，由于该remove()函数不是成员，因此不能调整链表的长度。它将没被删除的元素放在链表的开始位置，并返回一个指向新的超尾值的迭代器。</li></ul><h2 id="define用法"><a href="#define用法" class="headerlink" title="define用法"></a>define用法</h2><ul><li><p>#define 一般都写在函数外面，与 #include 写在一起。当然，写在函数里面也没有语法错误，但通常不那么写。#define 的作用域为自 #define 那一行起到源程序结束。如果要终止其作用域可以使用 #undef 命令，格式为：</p></li><li><p>define只是一种替换的形式，所以我们在宏定义的时候，养成一个良好的习惯，建议所有的层次都要加括号。</p></li><li><p>麻烦点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">define <span class="title">MACRO</span><span class="params">(arg1, arg2)</span> <span class="keyword">do</span> </span>&#123; /</span><br><span class="line">    <span class="comment">/* declarations / /</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">stmt1; /</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">stmt2; /</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/ … / /</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125; while(0) / (no trailing ; ) */</span></span><br><span class="line">关键是要在每一个换行的时候加上一个”/”</span><br></pre></td></tr></table></figure></li></ul><h2 id="auto（类型说明符）"><a href="#auto（类型说明符）" class="headerlink" title="auto（类型说明符）"></a>auto（类型说明符）</h2><ul><li><p>是一个类型说明符，通过变量的初始值来推断变量的类型</p><ul><li><strong>auto||map用法</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// member此处是引用类型，如果要限定语句块中不允许修改，可以使用类型修饰符const指定: const auto &amp;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;member : mapStudent)</span><br><span class="line">&#123;</span><br><span class="line">    member.second = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">&#125;                                                          </span><br><span class="line"><span class="comment">// 打印结果各成员已修改为&quot;x&quot; </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> member : mapStudent)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; member.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;======= auto test case =========&quot;</span> &lt;&lt; endl;</span><br><span class="line">mapStudent.<span class="built_in">clear</span>();</span><br><span class="line">mapStudent[<span class="number">1</span>] = <span class="string">&quot;lilei&quot;</span>;</span><br><span class="line">mapStudent[<span class="number">2</span>] = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"><span class="comment">// member此处是临时变量类型，语句块内赋值并不影响mapStudent原始成员值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> member : mapStudent)</span><br><span class="line">&#123;</span><br><span class="line">    member.second = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果各成员还是与之前一样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> member : mapStudent)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; member.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//another</span></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; symbolValues = &#123;</span><br><span class="line">    &#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="decltype（类型指示符）"><a href="#decltype（类型指示符）" class="headerlink" title="decltype（类型指示符）"></a>decltype（类型指示符）</h2><img src="C++容易遗忘的点.assets/image-20220826212738468.png" alt="image-20220826212738468" style="zoom:67%;" /><h2 id="setw-函数（头文件-iomanip-）"><a href="#setw-函数（头文件-iomanip-）" class="headerlink" title="setw() 函数（头文件&lt; iomanip &gt;）"></a>setw() 函数（头文件&lt; iomanip &gt;）</h2><ul><li><p><code>setw()</code> 函数可以控制输出流的<strong>下一个</strong>输出内容的场宽。</p></li><li><p>当包含了头文件<code>&lt;iomanip&gt;</code>，并运行以下语句时：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">114514</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="number">114514</span>;  <span class="comment">//设置场宽为10</span></span><br></pre></td></tr></table></figure><ul><li><p>当<strong>下一个</strong>输出的内容的宽度不足 <code>setw()</code> 函数中设置的参数时，输出流将自动在这个输出内容的<strong>前面</strong>添加字符（默认为空格）来补齐宽度。</p></li><li><p>当下一个输出的内容超过 <code>setw()</code> 函数中设置的参数时，将不会产生任何效果</p></li><li><p><strong>需要特别注意， <code>setw()</code> 函数只会对下一个输出内容有效，对于多个输出内容，需要重新设置</strong></p></li></ul><h2 id="setfill-函数"><a href="#setfill-函数" class="headerlink" title="setfill() 函数"></a>setfill() 函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">114514</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>)&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;a;  <span class="comment">//将补齐宽度时使用的字符设置为&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p>输出结果将为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">****114514</span><br></pre></td></tr></table></figure><p><code>setfill()</code> 函数将对<strong>设置之后</strong>输出流的所有内容有效，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">114</span>,b=<span class="number">514</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>)&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;b;</span><br></pre></td></tr></table></figure><p>输出结果将为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*******114 *******514</span><br></pre></td></tr></table></figure><h2 id="setprecision-x-函数"><a href="#setprecision-x-函数" class="headerlink" title="setprecision(x)函数"></a>setprecision(x)函数</h2><ul><li>要求保留x位小数，可以用到 <code>cout&lt;&lt;fixed&lt;&lt;setprecision(x)&lt;&lt;a&lt;&lt;endl;</code>，意思是输出 a<em>a</em>，保留 x<em>x</em> 位小数。</li><li>配合<strong>fixed</strong>使用</li></ul><h2 id="int64"><a href="#int64" class="headerlink" title="_int64"></a>_int64</h2><ul><li>64位整数</li></ul><h2 id="getline-——读取一整行"><a href="#getline-——读取一整行" class="headerlink" title="getline()——读取一整行"></a>getline()——读取一整行</h2><ul><li><strong>Ctrl+z 退出</strong></li></ul><img src="C++容易遗忘的点.assets/image-20220826211545934.png" alt="image-20220826211545934" style="zoom:67%;" /><h2 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a>比较string对象</h2><img src="C++容易遗忘的点.assets/image-20220826215043418.png" alt="image-20220826215043418" style="zoom:67%;" /><h2 id="使用C-版本的C标准库头文件"><a href="#使用C-版本的C标准库头文件" class="headerlink" title="使用C++版本的C标准库头文件"></a>使用C++版本的C标准库头文件</h2><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20220826222409762.png" alt="image-20220826222409762"></p><h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符[]"></a>下标运算符[]</h2><ul><li>其下标是unsigned int型，所以如果传入下标小于0，会被转化位无符号整型</li></ul><h2 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h2><ul><li><p>要取得 [a,b) 的随机整数，使用 (rand() % (b-a))+ a;</p></li><li><p>要取得 [a,b] 的随机整数，使用 (rand() % (b-a+1))+ a;</p></li><li><p>要取得 (a,b] 的随机整数，使用 (rand() % (b-a))+ a + 1;</p></li><li><p>通用公式: a + rand() % n；其中的 a 是起始值，n 是整数的范围。</p></li><li><p>要取得 a 到 b 之间的随机整数，另一种表示：a + (int)b * rand() &#x2F; (RAND_MAX + 1)。</p></li><li><p>要取得 0～1 之间的浮点数，可以使用 rand() &#x2F; double(RAND_MAX)。</p></li></ul><h2 id="构造函数为什么不能是虚函数"><a href="#构造函数为什么不能是虚函数" class="headerlink" title="构造函数为什么不能是虚函数"></a>构造函数为什么不能是虚函数</h2><ol><li><p>创建对象时，需要确定对象的类型，而虚函数是在运行时动态确定其类型的。在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型；</p></li><li><p>虚函数的调用需要通过vptr虚函数表指针，而该指针是存放在对象的内存空间中的，若构造函数声明为虚函数，那么由于对象尚未创建，还没有内存空间，也就没有对应虚函数表来调用虚构造函数了；</p></li><li><p>虚函数的作用在于通过父类的指针或者引用，在调用它的时候能够通过动态链编调用子类重写的虚成员函数。而构造函数是在创建对象时是系统自动调用的，不可能通过父类或者引用去调用，因此就规定构造函数不能是虚函数。</p></li></ol><h2 id="for语句体内不应改变其所遍历序列的大小"><a href="#for语句体内不应改变其所遍历序列的大小" class="headerlink" title="for语句体内不应改变其所遍历序列的大小"></a>for语句体内不应改变其所遍历序列的大小</h2><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20220829091907743.png" alt="image-20220829091907743"></p><h2 id="养成-的习惯"><a href="#养成-的习惯" class="headerlink" title="养成 !&#x3D; 的习惯"></a>养成 !&#x3D; 的习惯</h2><img src="C++容易遗忘的点.assets/image-20220829095312095.png" alt="image-20220829095312095" style="zoom:50%;" /><h2 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h2><ul><li>全局的默认为0，局部的未知。</li></ul><h2 id="inline和define的区别"><a href="#inline和define的区别" class="headerlink" title="inline和define的区别"></a>inline和define的区别</h2><p><strong>define</strong>：定义预编译时处理的宏，只是简单的字符串替换，无类型检查。</p><p><strong>inline</strong>：关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义，编译阶段完成。</p><ul><li>在类body内定义的函数时inline（但编译器要根据简易程度来认定是否inline）</li><li>用来写函数编译会更快</li></ul><h2 id="string-size-type"><a href="#string-size-type" class="headerlink" title="string::size_type"></a>string::size_type</h2><ul><li>它定义为与unsigned型（unsigned int或unsigned long）具有相同的含义，而且可以保证足够大可存储任意string对象的长度。</li><li>任何存储string的size操作结果的变量必须为string::size_type类型。特别重要的是，不要把size的返回值赋给一个int变量。</li></ul><h2 id="default"><a href="#default" class="headerlink" title="&#x3D;default"></a>&#x3D;default</h2><p><code>sales_data() = default;</code></p><ul><li><code>=default</code>要求编译器合成默认的构造函数。(<code>C++11</code>)</li></ul><h2 id="类之间的友元："><a href="#类之间的友元：" class="headerlink" title="类之间的友元："></a>类之间的友元：</h2><ul><li>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</li></ul><h2 id="封装的益处"><a href="#封装的益处" class="headerlink" title="封装的益处"></a>封装的益处</h2><ul><li>确保用户的代码不会无意间破坏封装对象的状态。</li><li>被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。</li></ul><h2 id="成员函数作为内联函数"><a href="#成员函数作为内联函数" class="headerlink" title="成员函数作为内联函数"></a>成员函数作为内联函数</h2><ul><li>成员函数作为内联函数<code>inline</code>：<ul><li>在类的内部，常有一些规模较小的函数适合于被声明成内联函数。</li><li><strong>定义</strong>在类内部的函数是<strong>自动内联</strong>的。</li><li>在类外部定义的成员函数，也可以在声明时显式地加上 <code>inline</code>。</li></ul></li></ul><h2 id="可变数据成员（mutable-data-member）："><a href="#可变数据成员（mutable-data-member）：" class="headerlink" title="可变数据成员（mutable data member）："></a>可变数据成员（mutable data member）：</h2><ul><li><code>mutable size_t access_ctr;</code></li><li>永远不会是<code>const</code>，即使它是<code>const</code>对象的成员。</li></ul><h2 id="如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。"><a href="#如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。" class="headerlink" title="如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。"></a>如果成员使用了外层作用域中的某个名字，而该名字代表一种<strong>类型</strong>，则类不能在之后重新定义该名字。</h2><ul><li><img src="C++容易遗忘的点.assets/image-20220903213248686.png" alt="image-20220903213248686" style="zoom:50%;" /></li></ul><h2 id="类成员初始化——const、引用……"><a href="#类成员初始化——const、引用……" class="headerlink" title="类成员初始化——const、引用……"></a>类成员初始化——const、引用……</h2><img src="C++容易遗忘的点.assets/image-20220903213741160.png" alt="image-20220903213741160" style="zoom:50%;" /><h2 id="抑制构造函数（explicit）定义的隐式转换："><a href="#抑制构造函数（explicit）定义的隐式转换：" class="headerlink" title="抑制构造函数（explicit）定义的隐式转换："></a>抑制构造函数（explicit）定义的隐式转换：</h2><ul><li>将构造函数声明为<code>explicit</code>加以阻止。</li><li><code>explicit</code>构造函数只能用于直接初始化，不能用于拷贝形式的初始化。</li></ul><h2 id="如果程序崩溃，输出缓冲区不会被刷新"><a href="#如果程序崩溃，输出缓冲区不会被刷新" class="headerlink" title="如果程序崩溃，输出缓冲区不会被刷新"></a>如果程序崩溃，输出缓冲区不会被刷新</h2><img src="C++容易遗忘的点.assets/image-20220904230011338.png" alt="image-20220904230011338" style="zoom: 50%;" /><h2 id="管理迭代器"><a href="#管理迭代器" class="headerlink" title="管理迭代器"></a>管理迭代器</h2><img src="C++容易遗忘的点.assets/image-20220905221512950.png" alt="image-20220905221512950" style="zoom: 67%;" /><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20220906221227582.png"></p><h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><ul><li><p>&#x3D;&#x3D;<strong>将函数包装为一元谓词</strong>&#x3D;&#x3D;</p></li><li><p><code>lambda</code>表达式更适合在一两个地方使用的简单操作。</p></li><li><p>如果是很多地方使用相同的操作，还是需要定义函数。</p></li><li><p>函数如何包装成一元谓词？使用参数绑定。</p></li><li><p>标准库bind函数：</p><ul><li>定义在头文件<code>functional</code>中，可以看做为一个通用的函数适配器。</li><li><code>auto newCallable = bind(callable, arg_list);</code></li><li>我们再调用<code>newCallable</code>的时候，<code>newCallable</code>会调用<code>callable</code>并传递给它<code>arg_list</code>中的参数。</li><li><code>_n</code>代表第n个位置的参数。定义在<code>placeholders</code>的命名空间中。<code>using std::placeholder::_1;</code></li><li><code>auto g = bind(f, a, b, _2, c, _1);</code>，调用<code>g(_1, _2)</code>实际上调用<code>f(a, b, _2, c, _1)</code></li><li>非占位符的参数要使用引用传参，必须使用标准库<code>ref</code>函数或者<code>cref</code>函数。&#x3D;&#x3D;p357&#x3D;&#x3D;</li></ul></li><li><p>&#x3D;&#x3D;<strong>重排参数顺序</strong>&#x3D;&#x3D;</p></li><li><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20220906223608142.png" alt="image-20220906223608142"></p></li></ul><h2 id="map和unordered-map的下标操作"><a href="#map和unordered-map的下标操作" class="headerlink" title="map和unordered_map的下标操作"></a>map和unordered_map的下标操作</h2><table><thead><tr><th><code>c[k]</code></th><th>返回关键字为<code>k</code>的元素；如果<code>k</code>不在<code>c</code>中，添加一个关键字为<code>k</code>的元素，对其值初始化。</th></tr></thead><tbody><tr><td><code>c.at(k)</code></td><td>访问关键字为<code>k</code>的元素，带参数检查；若<code>k</code>不存在在<code>c</code>中，抛出一个<code>out_of_range</code>异常。</td></tr></tbody></table><ul><li>下标和<code>at</code>操作只适用于非<code>const</code>的<code>map</code>和<code>unordered_map</code>。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li>有些变量是用volatile 关键字声明的。 <strong>当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile 声明</strong>，该关键字的作用是<strong>防止优化编译器把变量从内存装入CPU 寄存器中</strong>。 <em>如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。</em></li></ul><h2 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h2><p>C 库函数 <strong>int atoi(const char *str)</strong> 把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）</p><h2 id="pragma-once-ifndef-define-endif"><a href="#pragma-once-ifndef-define-endif" class="headerlink" title="#pragma once | #ifndef,#define,#endif"></a>#pragma once | #ifndef,#define,#endif</h2><ul><li><p>#pragma once用来防止某个头文件被多次</p></li><li><p>include，#ifndef，#define，#endif用来防止某个宏被多次定义。</p></li><li><p>#pragma once是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差，不过现在基本上已经是每个编译器都有这个定义了。</p></li><li><p>#ifndef，#define，#endif这个是C++语言相关，这是C++语言中的宏定义，通过宏定义避免文件多次编译。所以在所有支持C++语言的编译器上都是有效的，如果写的程序要跨平台，最好使用这种方式</p></li><li><p><strong>作用</strong>：<br>为了避免同一个文件被include多次<br>　　1 #ifndef方式<br>　　2 #pragma once方式<br>　　在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。<br>　　方式一：</p><p>​        #ifndef  _<em>SOMEFILE_H</em>_</p><p>　　#define _<em>SOMEFILE_H</em>_<br>　　… … &#x2F;&#x2F; 一些声明语句<br>　　#endif<br>　　方式二：<br>　　#pragma once<br>　　… … &#x2F;&#x2F; 一些声明语句<br>　　#ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况<br>　　#pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。<br>　　方式一由语言支持所以移植性好，方式二 可以避免名字冲突</p></li></ul><h2 id="struct和typedef-struct"><a href="#struct和typedef-struct" class="headerlink" title="struct和typedef  struct"></a>struct和typedef  struct</h2><p><a href="https://www.cnblogs.com/qyaizs/articles/2039101.html">区别</a></p><h2 id="读文件1"><a href="#读文件1" class="headerlink" title="读文件1"></a>读文件1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;failed to open text.txt&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件——只会一个单词一个单词输出</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; buf) &#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一行一行输出</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (ifs.<span class="built_in">getline</span>(buf, <span class="built_in">sizeof</span>(buf))) &#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与第二种一样</span></span><br><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buf)) &#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个字符一个字符的读</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF) &#123;<span class="comment">//EOF end of file</span></span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h2 id="读文件2"><a href="#读文件2" class="headerlink" title="读文件2"></a>读文件2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_name[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">person p = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ofstream ofs;</span></span><br><span class="line"><span class="comment">//ofs.open(&quot;class_write_test.txt&quot;, ios::out|ios::binary);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ofs.write((const char*)&amp;p, sizeof(person));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ofs.close();</span></span><br><span class="line"></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;class_write_test.txt&quot;</span>, ios::in | ios::binary);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;failed to open txt&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(person));</span><br><span class="line">cout &lt;&lt; p.m_age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.m_name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数初始化类内数据"><a href="#构造函数初始化类内数据" class="headerlink" title="构造函数初始化类内数据"></a>构造函数初始化类内数据</h2><blockquote><p>之所以放在 ：后，是因为这样时初始化</p><p>如果放在{ }内相当于赋值，虽然效果都一样，但是效率不如第一种方式</p></blockquote><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20221027231917924.png" alt="image-20221027231917924"></p><h2 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h2><p>push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><h2 id="相同class的各个objects互为friends（友元）"><a href="#相同class的各个objects互为friends（友元）" class="headerlink" title="相同class的各个objects互为friends（友元）"></a>相同class的各个objects互为friends（友元）</h2><img src="C++容易遗忘的点.assets/image-20230309233921786.png" alt="image-20230309233921786" style="zoom:50%;" /><h2 id="临时对象-局部对象不得引用到外部"><a href="#临时对象-局部对象不得引用到外部" class="headerlink" title="临时对象&amp;局部对象不得引用到外部"></a>临时对象&amp;局部对象不得引用到外部</h2><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20230311235352696.png" alt="image-20230311235352696"></p><h2 id="int-p-5-与-int-p-5"><a href="#int-p-5-与-int-p-5" class="headerlink" title="int (*p)[5] 与 int *p[5]"></a>int (*p)[5] 与 int *p[5]</h2><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20230313165725412.png" alt="image-20230313165725412"></p><h2 id="深拷贝自我赋值检测"><a href="#深拷贝自我赋值检测" class="headerlink" title="深拷贝自我赋值检测"></a>深拷贝自我赋值检测</h2><img src="C++容易遗忘的点.assets/image-20230315000106058.png" alt="image-20230315000106058" style="zoom: 50%;" /><ul><li>why</li></ul><img src="C++容易遗忘的点.assets/image-20230315000453571.png" alt="image-20230315000453571" style="zoom: 33%;" /><h2 id="创建唯一的对象"><a href="#创建唯一的对象" class="headerlink" title="创建唯一的对象"></a>创建唯一的对象</h2><ul><li>将构造函数都放到了private里</li><li>外界通过getInstance获取唯一的对象<ul><li>A::getInstance()</li></ul></li><li>调用该对象函数<ul><li>A::getInstance().setup();</li></ul></li><li>Singleton<ul><li>单例设计模式</li></ul></li><li>缺点<ul><li>A没被使用就被创建</li></ul></li></ul><img src="C++容易遗忘的点.assets/image-20230415232646279.png" alt="image-20230415232646279" style="zoom:50%;" /><ul><li>优化</li></ul><img src="C++容易遗忘的点.assets/image-20230415233249772.png" alt="image-20230415233249772" style="zoom:50%;" /><h2 id="函数模板自动推导，类模板需指定"><a href="#函数模板自动推导，类模板需指定" class="headerlink" title="函数模板自动推导，类模板需指定"></a>函数模板自动推导，类模板需指定</h2><h2 id="namespace命名空间"><a href="#namespace命名空间" class="headerlink" title="namespace命名空间"></a>namespace命名空间</h2><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20230415234943589.png" alt="image-20230415234943589"></p><h2 id="类和类之间的关系"><a href="#类和类之间的关系" class="headerlink" title="类和类之间的关系"></a>类和类之间的关系</h2><h3 id="Composition-复合"><a href="#Composition-复合" class="headerlink" title="Composition-复合"></a>Composition-复合</h3><ul><li>实心起步箭头，是指有了箭头指向的东西</li><li>两边会一起出现</li></ul><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20230416225210185.png" alt="image-20230416225210185"></p><h3 id="Delegation-委托或Composition-by-reference"><a href="#Delegation-委托或Composition-by-reference" class="headerlink" title="Delegation-委托或Composition by reference"></a>Delegation-委托或Composition by reference</h3><ul><li>空间起步箭头，是指尚未用于箭头指向的东西，想要的时候再<strong>委托</strong>箭头指向东西去做</li><li>两边出现不同步</li></ul><img src="C++容易遗忘的点.assets/image-20230416230655046.png" alt="image-20230416230655046" style="zoom: 50%;" /><ul><li><p>这种设计右边给外界提供接口，左边实现——pimpl</p><ul><li><p><strong>pointer to implementation</strong>(执行)，即一个指针指向的对象包含真正的数据</p></li><li><h1 id="编译防火墙"><a href="#编译防火墙" class="headerlink" title="编译防火墙"></a>编译防火墙</h1></li></ul></li></ul><h3 id="inheritance-继承"><a href="#inheritance-继承" class="headerlink" title="inheritance-继承"></a>inheritance-继承</h3><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20230416233505197.png" alt="image-20230416233505197"></p><h2 id="inheritance搭配virtual-functions达到最强有力的效果"><a href="#inheritance搭配virtual-functions达到最强有力的效果" class="headerlink" title="inheritance搭配virtual functions达到最强有力的效果"></a>inheritance搭配virtual functions达到最强有力的效果</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20230416234226797.png" alt="image-20230416234226797"></p><h3 id="案例—设计模式—Template-Method"><a href="#案例—设计模式—Template-Method" class="headerlink" title="案例—设计模式—Template Method"></a>案例—设计模式—Template Method</h3><ul><li><h4 id="应用框架——Application-framework"><a href="#应用框架——Application-framework" class="headerlink" title="应用框架——Application framework"></a>应用框架——Application framework</h4></li></ul><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20230416234743347.png" alt="image-20230416234743347"></p><h2 id="构造由内而外，析构由外而内"><a href="#构造由内而外，析构由外而内" class="headerlink" title="构造由内而外，析构由外而内"></a>构造由内而外，析构由外而内</h2><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20230416225700787.png" alt="image-20230416225700787"></p><p><img src="/C++%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E7%9A%84%E7%82%B9.assets/image-20230416232757575.png" alt="image-20230416232757575"></p><h2 id="如果一个类将要成为base类，那么其析构函数dtor必须是virtual-？"><a href="#如果一个类将要成为base类，那么其析构函数dtor必须是virtual-？" class="headerlink" title="如果一个类将要成为base类，那么其析构函数dtor必须是virtual&#x3D;&#x3D;？&#x3D;&#x3D;"></a>如果一个类将要成为base类，那么其析构函数dtor必须是virtual&#x3D;&#x3D;？&#x3D;&#x3D;</h2><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++Primer笔记</title>
      <link href="/2023/07/25/C++Primer%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/25/C++Primer%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="代码编译过程"><a href="#代码编译过程" class="headerlink" title="代码编译过程"></a>代码编译过程</h1><p><a href="https://zhuanlan.zhihu.com/p/476697014">编译过程</a></p><ul><li>gcc编译的4个步骤</li></ul><ol><li>将C语言源程序预处理，生成 .i 文件。</li><li>预处理后的.i文件编译成为汇编语言，生成 .s 文件。</li><li>将汇编语言文件经过汇编，生成目标文件 .o 文件。</li><li>将各个模块的 .o 文件链接起来生成一个可执行程序文件。</li></ol><img src="c++primer查漏补缺笔记整理.assets/image-20230422175100111.png" alt="image-20230422175100111" style="zoom:50%;" /><h1 id="动态链接和静态链接"><a href="#动态链接和静态链接" class="headerlink" title="动态链接和静态链接"></a>动态链接和静态链接</h1><ul><li>静态链接是main.o文件和.lib文件生成可执行文件<ul><li>main.o文件是main.cpp编译的目标文件</li><li>.lib\libxxx.a是main.cpp需要的函数编译的目标文件集合</li></ul></li><li>动态链接是.o问件生成可执行文件，然后.lid和.dll链接可执行文件<ul><li>main.o文件是main.cpp编译的目标文件</li><li>.lib是main.cpp需要的函数编译的目标文件的索引</li><li>真正的目标文件(.o)在.dll\.so中</li></ul></li></ul><h1 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章 开始"></a>第1章 开始</h1><h2 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h2><table><thead><tr><th>类型</th><th>代码</th></tr></thead><tbody><tr><td>标准输入</td><td>cin</td></tr><tr><td>标准输出</td><td>cout</td></tr><tr><td>输出警告和错误信息</td><td>cerr</td></tr><tr><td>输出程序运行时的一般信息</td><td>clog</td></tr></tbody></table><h1 id="第2章-变量和基本类型"><a href="#第2章-变量和基本类型" class="headerlink" title="第2章 变量和基本类型"></a>第2章 变量和基本类型</h1><h2 id="指针与引用的区别"><a href="#指针与引用的区别" class="headerlink" title="指针与引用的区别"></a>指针与引用的区别</h2><ol><li>指针是存储变量地址的变量；引用是变量的别名。</li><li>指针变量定义时不必初始化；引用定义时必须初始化，不然会报错。</li></ol><h2 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p;</span><br></pre></td></tr></table></figure><h2 id="让const常量多文件共享——extern"><a href="#让const常量多文件共享——extern" class="headerlink" title="让const常量多文件共享——extern"></a>让const常量多文件共享——extern</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_1.cc 定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">// file_1.h 头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;<span class="comment">//与file_1.cc中定义的bufSize是同一个</span></span><br></pre></td></tr></table></figure><h2 id="const-引用和指针"><a href="#const-引用和指针" class="headerlink" title="const 引用和指针"></a>const 引用和指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果引用对象或指针指向对象是const，则自身也要是const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a = i; <span class="comment">//正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *b = &amp;i; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = i; <span class="comment">//错误</span></span><br><span class="line"><span class="type">int</span> *d = i; <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果引用的类型是const或指针是常量指针,指向的对象是不是常量多可以</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;i = a;<span class="comment">//此时不允许通过引用或指针修改a的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *j = &amp;a;</span><br></pre></td></tr></table></figure><h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;<span class="comment">//不能改变p1的值，这是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;<span class="comment">//不能改变ci的值，这是一个顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci;<span class="comment">//可以修改p2的值，这是一个底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2;<span class="comment">//靠右的是顶层const，靠左的是底层const</span></span><br></pre></td></tr></table></figure><h2 id="常量表达式——constexpr"><a href="#常量表达式——constexpr" class="headerlink" title="常量表达式——constexpr"></a>常量表达式——constexpr</h2><ul><li>常量表达式是指值不会改变并且在<strong>编译过程就能得到计算结果的表达式</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>;<span class="comment">//max_files是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>;<span class="comment">//limit是常量表达式</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;<span class="comment">//尽管27是字面值常量，但staff_size不是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();<span class="comment">//sz不是常量表达式</span></span><br></pre></td></tr></table></figure><ul><li>**&#x3D;&#x3D;C++11&#x3D;&#x3D;**新新标准规定，允许变量声明为constexpr类型以便编译器来验证变量值是否是一个常量表达式</li><li>constexpr必须由常量表达式来初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;<span class="comment">// 20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>;<span class="comment">// mf + 1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>();<span class="comment">// 只有当size是一个constexpr函数的时候才是一条正确的声明语句</span></span><br></pre></td></tr></table></figure><ul><li>constexpr函数需要足够简单以使得编译时就可以计算其结果</li><li>constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象</li><li>constexpr指针&#x2F;引用<strong>不能指向函数体内声明的变量</strong>，除非是static类型</li><li>constexpr<strong>只对指针有效</strong>，对指针指向的对象无关</li></ul><h2 id="auto-decltype"><a href="#auto-decltype" class="headerlink" title="auto &amp; decltype"></a>auto &amp; decltype</h2><ul><li>auto一般会忽略掉顶层const</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i， &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;<span class="comment">//b是一个整数</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;<span class="comment">//c是一个整数</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;<span class="comment">//d是一个整型指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;<span class="comment">//e是一个指向整数常量的指针（是一种底层const——&gt;e可以改变指向）</span></span><br></pre></td></tr></table></figure><ul><li>如要获取到指针、引用、const需要自己加</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;<span class="comment">//通过推演ci的类型为int，f为const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci;<span class="comment">//g是一个整型常量的引用——&gt;const int &amp;g</span></span><br><span class="line"><span class="keyword">auto</span> *p = &amp;ci;<span class="comment">//p是一个常量指针——&gt;const int *p;</span></span><br></pre></td></tr></table></figure><ul><li><p>decltype</p><ul><li>从表达式中的类型判断出要定义的变量的类型</li></ul></li><li><p>decltype处理顶层const和引用的方式和auto**&#x3D;&#x3D;不同点&#x3D;&#x3D;**</p><ul><li>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（<strong>包括顶层const</strong>）</li><li>如果是引用，则返回引用类型，此时变量必须初始化</li></ul></li><li><p>引用从来都是作为其所指对象的同义词出现，只有用在decltype处是个例外</p><ul><li>指需要引用的引用类型，比如<code>int &amp;a = b; decltype(a) c = d; </code>decltype(a)——&gt;int &amp;</li></ul></li><li><p>指针</p><ul><li><code>int *p = a; decltype(p) b = c</code>decltype(p)——&gt;int &amp;</li></ul></li><li><p>decltype((i)) 返回i的类型的引用，<code>int i = 1; decltype((i)) b = c;</code>decltype((i))——&gt;int &amp;</p></li></ul><h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><ul><li><p>sturct，class都是类，唯一的区别是前者默认访问类型是public，后者默认访问类型是private</p></li><li><p>最好不要包对象的定义和类的定义放在一起</p></li><li><p>类定义后要放 ;</p></li></ul><h2 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Sales_data.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li><p>生命周期长：static 变量的生命周期与程序运行期间一致，即使函数返回或者调用结束，它的值也会一直保存在内存中，直到程序结束。</p></li><li><p>作用域小：static 变量的作用域仅限于声明它的函数内部，即使在函数外部定义了同名的变量，也不会产生命名冲突。</p></li><li><p>初值保持：第一次声明 static 变量时，它会被初始化为 0 或者空指针。随后，每次函数调用结束后，static 变量的值会被保留下来，不会被重置为初始值。</p></li><li><p>只能在函数内部访问：由于作用域的限制，只有在声明 static 变量的函数内部才能访问该变量，外部无法访问。</p></li><li><p>使用 static 变量可以在函数之间（相同的函数调用）共享数据，同时又能够避免变量名冲突的问题。它也常用于在函数内部存储需要保持状态的数据，例如计数器、缓存等。</p></li></ul><h1 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h1><h2 id="头文件不应包含using声明"><a href="#头文件不应包含using声明" class="headerlink" title="头文件不应包含using声明"></a>头文件不应包含using声明</h2><ul><li>这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件都会有这个声明，对于某些程序来说，由于不经意间包含了些名字，反而可能产生始料未及的<strong>名字冲突</strong></li></ul><h2 id="getline输出一整行"><a href="#getline输出一整行" class="headerlink" title="getline输出一整行"></a>getline输出一整行</h2><ul><li>geline(cin, line)</li><li>会保留空白符</li><li>getline会读取到换行符，只不过传给(string)line的时候丢弃了</li></ul><h2 id="size-返回无符号整型数"><a href="#size-返回无符号整型数" class="headerlink" title="size()返回无符号整型数"></a>size()返回无符号整型数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&#x27;sfasf&#x27;</span>;</span><br><span class="line"><span class="keyword">auto</span> len = s.<span class="built_in">size</span>();<span class="comment">//len的类型为string::size_type——&gt;是一个unsigned</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line">s.<span class="built_in">size</span>()&lt;i; <span class="comment">//这条结果一定是true，这是因为负值i会自动转换成一个比较大的无符号值</span></span><br></pre></td></tr></table></figure><ul><li>所以如果表达式中已经有了 size() 函数就不要再使用 int 了，这样可以避免混用 int 和 unsigned 可能带来的问题</li></ul><h2 id="string比较规则"><a href="#string比较规则" class="headerlink" title="string比较规则"></a>string比较规则</h2><ul><li>如果两个string长度不同，但是短的是长的的子集，则长的比短的要长</li><li>相反，则第一个不同的字符比较结果就是string对象的比较结果</li></ul><h2 id="字面值和string相加"><a href="#字面值和string相加" class="headerlink" title="字面值和string相加"></a>字面值和string相加</h2><ul><li>字面值不能直接相加，错误例子<ul><li><code>string s5 = &quot;hello&quot;+&#39;,&#39;+s4;</code></li><li><code>string s7 = (&quot;hello&quot;+&quot;,&quot;)+s6; </code></li></ul></li></ul><h2 id="vector为元素的vector初始化——老式编译器"><a href="#vector为元素的vector初始化——老式编译器" class="headerlink" title="vector为元素的vector初始化——老式编译器"></a>vector为元素的vector初始化——老式编译器</h2><p><code>vector&lt;vector&lt;int&gt; &gt;</code>多了空格</p><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//v1有10个元素，每个的值都是0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;<span class="comment">//v2有1个元素，该元素值为10</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span><span class="comment">//v3有10个元素，每个的值都是1</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; v4</span>&#123;<span class="number">10</span>,<span class="number">1</span>&#125;<span class="comment">//v4有2个元素，值分别是10，1</span></span><br></pre></td></tr></table></figure><ul><li>如果花括号提供的值不能用来列表初始化，则考虑用这些值来构造vector对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v5</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;<span class="comment">//错误：不能使用字符串字面值来构造vector对象</span></span><br><span class="line">vector&lt;string&gt; v6&#123;<span class="string">&quot;hi&quot;</span>&#125;;<span class="comment">//列表初始化，v6有一个元素</span></span><br><span class="line">vector&lt;string&gt; v7&#123;<span class="number">10</span>&#125;;<span class="comment">//v7有10个默认初始化的元素</span></span><br><span class="line">vector&lt;string&gt; v8&#123;<span class="number">10</span>,<span class="string">&quot;hi&quot;</span>&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>不能使用字符串字面值</strong>构造vector对象</li></ul><h2 id="for循环内不应改变所遍历序列的大小，比如插入数据等"><a href="#for循环内不应改变所遍历序列的大小，比如插入数据等" class="headerlink" title="for循环内不应改变所遍历序列的大小，比如插入数据等"></a>for循环内不应改变所遍历序列的大小，比如插入数据等</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = ...</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a : v1)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>();it!=v1.<span class="built_in">end</span>();it++)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果序列大小改变，for循环预存了end(),end()就可能无效</span></span><br></pre></td></tr></table></figure><h2 id="对vector使用size-type"><a href="#对vector使用size-type" class="headerlink" title="对vector使用size_type"></a>对vector使用size_type</h2><p><code>vector&lt;int&gt;::size_type</code></p><p><code>vector::size_type 错误</code></p><h2 id="vector不能使用下标添加元素"><a href="#vector不能使用下标添加元素" class="headerlink" title="vector不能使用下标添加元素"></a>vector不能使用下标添加元素</h2><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li>迭代器像指针</li></ul><p><code>vector&lt;int&gt;::iterator it;//it能读写vector&lt;int&gt;中的元素</code></p><p><code>vector&lt;int&gt;::const_iterator it;//it只能读vector&lt;int&gt;中的元素，不能写元素</code></p><ul><li><p>迭代器这个名词有三种不同的含义</p><ul><li>迭代器概念本身</li><li>指定容器定义的迭代器类型</li><li>迭代器对象</li></ul></li><li><p>begin()，end() 根据对象的类型而确定</p><ul><li>​<code>vector&lt;int&gt; v1; const vector&lt;int&gt; v2</code><ul><li><code>auto it1 = v1.begin();//it1是vector&lt;int&gt;::iterator</code></li><li><code>auto it2 = v2.begin();//it2是vector&lt;int&gt;::const_iterator</code></li></ul></li></ul></li></ul><h2 id="相对于vector来说数组有什么缺点"><a href="#相对于vector来说数组有什么缺点" class="headerlink" title="相对于vector来说数组有什么缺点"></a>相对于vector来说数组有什么缺点</h2><ul><li>数组不够灵活</li><li>数组的容量固定</li><li>数组不允许拷贝和赋值</li><li>数组容易越界</li><li>获取数组长度不方便</li></ul><h2 id="标准库begin，end"><a href="#标准库begin，end" class="headerlink" title="标准库begin，end"></a>标准库begin，end</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iap[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> *beg = <span class="built_in">begin</span>(iap);<span class="comment">//指向ia首元素的指针</span></span><br><span class="line"><span class="type">int</span> *beg = <span class="built_in">end</span>(iap);<span class="comment">//指向ia尾元素下一位置的指针</span></span><br></pre></td></tr></table></figure><h2 id="使用数组初始化vector"><a href="#使用数组初始化vector" class="headerlink" title="使用数组初始化vector"></a>使用数组初始化vector</h2><ul><li>不能使用vector初始化数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="范围for处理多维数据引用数组"><a href="#范围for处理多维数据引用数组" class="headerlink" title="范围for处理多维数据引用数组"></a>范围for处理多维数据<del>引用数组</del></h2><ul><li>要使用范围 for 语句处理多为数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia [<span class="number">3</span>][<span class="number">4</span>] = ...</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;row : ia)&#123;<span class="comment">//row引用了大小为4的数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> col : row)&#123;</span><br><span class="line">cout&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> row : ia)&#123;<span class="comment">//row是一个int*</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> : row)&#123;<span class="comment">//对指针遍历不合法</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><ul><li>没有多维数组，实际上是数组的数组</li></ul><h1 id="第4章-表达式"><a href="#第4章-表达式" class="headerlink" title="第4章 表达式"></a>第4章 表达式</h1><h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><ul><li>左值和右值有如下3个规则：</li></ul><ol><li><strong>左值和右值都是表达式。</strong></li><li><strong>左值是对象定位器，理论上左值指示指示一个对象。</strong></li><li><strong>右值是一个临时值，其他位置无法访问这个值，通常情况下在语句执行完成后右值就被丢弃。</strong></li></ol><ul><li><p>左值：<strong>可以进行取地址</strong>的称为左值。</p></li><li><p>右值：<strong>不能进行取地址</strong>的称为右值。右值包括：临时对象、匿名对象、临时变量、匿名变量、字面值常量（10）</p></li><li><p>传统的左值引用：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;  <span class="comment">// 定义一个左值引用变量</span></span><br><span class="line">b = <span class="number">20</span>;      <span class="comment">// 通过左值引用修改引用内存的值</span></span><br></pre></td></tr></table></figure><p><em>左值引用在汇编层面其实和普通的指针是一样的；</em>定义引用变量必须初始化，因为引用其实就是一个别名，需要告诉编译器定义的是谁的引用。</p><ul><li>错误的左值引用：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;val = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>10无法进行取地址操作，无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中，在这一行代码执行完毕后，就被丢弃了，可以通过下述方法（<strong>常引用</strong>）解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; val = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> temp = <span class="number">10</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;val = temp;</span><br></pre></td></tr></table></figure><p>小结：</p><ul><li><strong>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了。</strong></li></ul><p>由此可知，为什么很多情况下（自定义的拷贝构造函数，运算符重载等场景下）函数的参数需要用const修饰，因为为了增强代码的健壮性。如果不用const修饰，当我们在调用函数时传入一个右值就会出问题，即普通的左值引用无法绑定到右值上，**&#x3D;&#x3D;必须使用常左值引用才能绑定右值&#x3D;&#x3D;。**</p><h2 id="利用后置-简写"><a href="#利用后置-简写" class="headerlink" title="利用后置++简写"></a>利用后置++简写</h2><p>*it++ 和 *(it++)相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;*it++&lt;&lt;endl;</span><br><span class="line"><span class="comment">//代替</span></span><br><span class="line">cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">it++;</span><br></pre></td></tr></table></figure><h2 id="在输出表达式中使用条件运算符"><a href="#在输出表达式中使用条件运算符" class="headerlink" title="在输出表达式中使用条件运算符"></a>在输出表达式中使用条件运算符</h2><ul><li>移位运算符的优先级比算数运算符的优先级低，比关系运算符，条件运算符，赋值运算符优先级高</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt; ((grage&gt;<span class="number">60</span>)?<span class="string">&quot;true&quot;</span>:<span class="string">&quot;flase&quot;</span>);<span class="comment">//输出true或false</span></span><br><span class="line">cout&lt;&lt; (grade&gt;<span class="number">60</span>)?<span class="string">&quot;true&quot;</span>:<span class="string">&quot;false&quot;</span>;<span class="comment">//输出1或0</span></span><br><span class="line">cout&lt;&lt; grade&gt;<span class="number">60</span>?<span class="string">&quot;true&quot;</span>:<span class="string">&quot;false&quot;</span>;<span class="comment">//错误，试图比较cout和60，因为&gt;优先级小于移位运算符</span></span><br></pre></td></tr></table></figure><h2 id="sizeof返回的是常量表达式"><a href="#sizeof返回的是常量表达式" class="headerlink" title="sizeof返回的是常量表达式"></a>sizeof返回的是常量表达式</h2><ul><li>返回的类型为constexpr size_t</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr size_t sz = sizeof(ia)/sizeof(*a);</span><br><span class="line">int arr2[sz];</span><br></pre></td></tr></table></figure><h2 id="算数转换"><a href="#算数转换" class="headerlink" title="算数转换"></a>算数转换</h2><ul><li>整型提升<ul><li>把小整数类型转换成大整型类型</li></ul></li><li>无符号类型的运算对象<ul><li>如果一个运算对象是无符号类型，另一个是带符号类型</li><li>谁能容纳谁，谁就转成谁</li><li>当带符号类型为负数，转换成无符号类型时，会有副作用</li></ul></li></ul><h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><ul><li><p>虽然有时候不得不使用强制转换，但这种方法本质上是非常危险的</p></li><li><p>statci_cast</p><ul><li>任何具有明确定义的类型转换只要不包含顶层const，都可以使用static_cast</li><li>用于将较大的算术类型赋值给较小的类型时，告诉读者或编译器我们不在乎精度损失</li><li>使用static_cast找回存在于void*指针</li></ul></li><li><p>dynamic_cast</p><ul><li>运行时识别</li></ul></li><li><p>const_cast</p><ul><li>只有使用const_cast能改变表达式的常量属性</li><li>const_cast的小问题<ul><li>const_cast可以去除一个常量的const属性，去除const属性后应该可以对“常量”进行修改，通过调试器发现内存中的值是被改变的，可是再传递这个“常量”的时候，值却一直保持原状<ul><li>因为输出这个常量的时候，<strong>预处理器</strong>会用其值替换掉该常量</li></ul></li></ul></li><li>const_cast常用于函数重载的上下文中</li></ul></li><li><p>reinterpret_cast</p><ul><li><p>reinterpret：重新解释</p></li><li><p>为运算对像的位模式提供较低层次上的重新解释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">reinterpret_cast</span>(ip);</span><br><span class="line"><span class="comment">//pc不是一个普通的char指针，其指向的数据变成了int型</span></span><br></pre></td></tr></table></figure></li><li><p>reinterpret_cast本质上依赖于机器。要想安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换过程都非常了解</p></li></ul></li><li><p>旧式的显示类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> (expr);<span class="comment">//函数类型的强制类型转换</span></span><br><span class="line">(type) expr;;<span class="comment">//C语言风格的强制类型转换</span></span><br></pre></td></tr></table></figure><ul><li>根据所涉及的类型不同，旧式的强制类型转换分别具有于const_cast、static_cast或reinterpret_cast相似的行为</li><li>在执行旧式转换成，如果换成const_cast，static_cast也合法，则其行为与对应的命名转换一致</li><li>如果替换后不合法，则旧式强制类型转换将使用reinterpret_cast类似的功能</li><li>使用旧式类型强制转换，出现问题时<strong>难追踪</strong></li></ul></li></ul><h2 id="void-指针的典型属性"><a href="#void-指针的典型属性" class="headerlink" title="void*指针的典型属性"></a>void*指针的典型属性</h2><ul><li>void的指针大小和int<em>，float</em>一样，都是4字节</li><li>void* 指针并不指向任何确切的类型（但不可理解为void* 指向任何类型），当指向的地址上的内存的类型被指定时，void* 指针在调用时被强制转型为该类型的指针。</li><li>void指针的操作比其他指针要少，只能和另一个指针比较，主要用于向函数传递或者被函数返回，给同类型的指针赋值，</li><li>void* 指针不能操作它所指向的对象，不能对void 类型进行解引用，不能对它进行算数操作。</li><li>可以将一些结构体指针变成void*,在函数参数列表中可以隐藏结构体信息</li></ul><h1 id="第5章-语句"><a href="#第5章-语句" class="headerlink" title="第5章 语句"></a>第5章 语句</h1><h2 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;s &amp;&amp; s != sought)<span class="comment">//重复读入数据直到文件末尾或者某次输入的值等于sought</span></span><br><span class="line">;<span class="comment">//空语句</span></span><br></pre></td></tr></table></figure><ul><li>使用空语句时要加上注释，从而令读代码的人能够直到该语句是有意省略的</li></ul><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><ul><li><p>标签必须是整型常量表达式</p></li><li><p>一般不要注释case分支最后的break语句。如果没写break语句，最好加一段注释说清楚程序的逻辑</p></li><li><p>即使不准备再default标签下做任何工作，定义一个default标签也是有用的。其目的是告诉读者，我们已经考虑了默认的情况，只是目前什么都没做</p></li></ul><h2 id="switch内部的定义"><a href="#switch内部的定义" class="headerlink" title="switch内部的定义"></a>switch内部的定义</h2><ul><li>case语句如果没有花括号的话，会绕过对变量的显示&#x2F;隐式初始化，但可以定义变量，然而该变量出现其他case语句中可能造成变量未定义就使用</li><li>如果要在case语句中定义并初始化变量的话，用块 {} ，这样可以将该变量限制在块作用域内，其他case语句不能使用</li></ul><h2 id="不要在程序中使用goto语句，因为它使得程序既难理解又难修改"><a href="#不要在程序中使用goto语句，因为它使得程序既难理解又难修改" class="headerlink" title="不要在程序中使用goto语句，因为它使得程序既难理解又难修改"></a>不要在程序中使用goto语句，因为它使得程序既难理解又难修改</h2><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>())</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to same ISBN&quot;</span>);</span><br><span class="line"><span class="comment">//如果程序执行到这一步，证明两个ISBN相等</span></span><br><span class="line">cout&lt;&lt;item1 + item2&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin &gt;&gt; item1 &gt;&gt; item2)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>())</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to same ISBN&quot;</span>);</span><br><span class="line"><span class="comment">//如果程序执行到这一步，证明两个ISBN相等</span></span><br><span class="line">cout&lt;&lt;item1 + item2&lt;&lt;endl;</span><br><span class="line">&#125;<span class="built_in">catch</span> (runtime_error err)&#123;</span><br><span class="line">cout&lt;&lt;err.<span class="built_in">what</span>()</span><br><span class="line">&lt;&lt;<span class="string">&quot;\nTry Again? Enter y or n&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line"><span class="keyword">if</span>(!cin||c==<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//退出while循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数在寻找处理代码的过程中退出<ul><li>当异常被throw出时，首先搜索抛出该异常的函数，如果没有找到匹配的catch语句，则终止该函数，并在调用该函数的函数中找，以此类推，如果还没找到，程序就会转到terminate的标准库函数。</li><li>terminate函数的行为与系统相关，一般情况下，执行该函数会导致程序非正常退出</li></ul></li><li>如果一段程序没有try catch语句，系统会直接调用terminate函数并终止当前程序的执行<ul><li>只有单独的throw</li></ul></li></ul><h1 id="第6章-函数"><a href="#第6章-函数" class="headerlink" title="第6章 函数"></a>第6章 函数</h1><h2 id="函数的返回类型"><a href="#函数的返回类型" class="headerlink" title="函数的返回类型"></a>函数的返回类型</h2><ul><li>函数不能返回数组或者函数类型</li><li>但是可以返回指向数组的指针（引用）、函数的指针</li></ul><h2 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h2><ul><li>熟悉C的程序员常常用指针类型的形参访问函数外部的对象，在C++语言中，建议使用引用类型的形参代替指针</li><li>如果函数无需改变引用形参的值，最好将其声明为常量引用（const type &amp;）</li></ul><h2 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h2><ul><li>数组指针形参同理</li><li>需要指定引用或者指向数组的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)&#123;</span><br><span class="line">cout &lt;&lt; elem &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp;arr两端的括号必不可少</span></span><br><span class="line"><span class="built_in">f</span>(<span class="type">int</span> &amp;arr[<span class="number">10</span>])<span class="comment">//错误：将arr声明成了引用的数组</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">int</span> (&amp;arr)[<span class="number">10</span>])<span class="comment">//正确：arr是一个含有10个整数的整型数组的引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> k[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);<span class="comment">//错误：实参不是含有10个整数的数组</span></span><br><span class="line"><span class="built_in">print</span>(j);<span class="comment">//错误：实参不是含有10个整数的数组</span></span><br><span class="line"><span class="built_in">print</span>(k);<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main：处理命令行选项"><a href="#main：处理命令行选项" class="headerlink" title="main：处理命令行选项"></a>main：处理命令行选项</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>;</span><br><span class="line">/</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令行下</span></span><br><span class="line"><span class="comment">//函数main位于可执行文件prog下</span></span><br><span class="line">$ prog -d -o ofile data0</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时argc为5，argv包含如下C风格字符串</span></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;prog&quot;</span>;<span class="comment">//或者argv[0]也可以指向一个空字符串</span></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;-d&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>]= <span class="string">&quot;-o&quot;</span>;</span><br><span class="line">argv[<span class="number">3</span>] = <span class="string">&quot;ofile&quot;</span>;</span><br><span class="line">argv[<span class="number">4</span>] = <span class="string">&quot;data0&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；</li><li>argv[0]保存程序的名字，而非用户输入</li></ul><h2 id="不要返回局部对象的引用和指针"><a href="#不要返回局部对象的引用和指针" class="headerlink" title="不要返回局部对象的引用和指针"></a>不要返回局部对象的引用和指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span>&#123;</span><br><span class="line">string ret;</span><br><span class="line"><span class="comment">//以某种方式改变了ret</span></span><br><span class="line"><span class="keyword">if</span>(!ret.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> ret;<span class="comment">//错误：返回局部对象的引用</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Empty&quot;</span>;<span class="comment">//错误：“Empty”是一个局部临时量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>要想保证返回值安全，我们不妨提问：引用所引的是在函数之前已经存在的那个对象</p></li><li><p><strong>当函数返回的是引用，对函数可以做为&#x3D;&#x3D;左值&#x3D;&#x3D;</strong></p></li></ul><h2 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// expected he actual 是string对象</span></span><br><span class="line"><span class="keyword">if</span>(expected.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;<span class="comment">// 返回一个空vector对象</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(expected == actual)<span class="comment">// 返回列表初始化的vector对象</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="string">&quot;functionx&quot;</span>, <span class="string">&quot;okay&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="string">&quot;functionx&quot;</span>, expected, actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主函数main的返回值"><a href="#主函数main的返回值" class="headerlink" title="主函数main的返回值"></a>主函数main的返回值</h2><ul><li>如果控制到达了main函数的尾处发现没有return语句，编译器将隐式地插入一条返回0的return语句</li><li>main函数的返回值可以看作状态指示器，返回0表示执行成功，返回其他值表示执行失败，这个非零值的具体含义依机器而定</li><li>在&lt;cstdlib&gt;头文件里定义了两个预处理变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(some_failure)</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h2><ul><li>使用类型别名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>];<span class="comment">//arrT是一个类型别名，它表示的类型是10个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arr = <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//等价声明</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//func返回一个指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure><ul><li>定义一个返回数组指针的函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Type</span> (*<span class="built_in">func</span>(parameter_list))[dimension]</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//func(int i)表示调用func函数需要一个int类型的实参</span></span><br><span class="line"><span class="comment">//*func(int i)意味着我们可以对函数调用的结果进行解引用</span></span><br><span class="line"><span class="comment">//(*func(int i))[10]表示解引用func的调用将得到一个大小为10的数组</span></span><br></pre></td></tr></table></figure><ul><li>使用尾置返回类型(auto)<strong>&#x3D;&#x3D;c++11&#x3D;&#x3D;</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="type">int</span>*[10]</span></span><br></pre></td></tr></table></figure><ul><li>使用decltype</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">func</span>(<span class="type">int</span> i)&#123;</span><br><span class="line"><span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//decltype的结果是个数组，所以要加上*</span></span><br></pre></td></tr></table></figure><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul><li>声明一个名为pf的函数指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);<span class="comment">//未初始化</span></span><br><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp;lengthCompare;<span class="comment">//一样效果</span></span><br></pre></td></tr></table></figure><ul><li>函数指针做形参</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个形参为函数类型，他会自动转化成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">//显示指出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br></pre></td></tr></table></figure><ul><li>返回指向函数的指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span>*, <span class="type">int</span>);<span class="comment">//F是函数类型</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span>(*)(<span class="type">int</span>*, <span class="type">int</span>);<span class="comment">//PF是函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//错误</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接声明</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">int</span>*, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span><span class="params">(<span class="type">int</span>* ,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sumlength</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span>；</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(sumlength)</span> *<span class="title">getFun</span><span class="params">(<span class="type">const</span> string &amp;)</span>；</span></span><br></pre></td></tr></table></figure><h2 id="const-cast和重载"><a href="#const-cast和重载" class="headerlink" title="const_cast和重载"></a>const_cast和重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),</span><br><span class="line"><span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要一种新的函数，传入的不是常量，得到的结果是一个普通的引用</li></ul><h2 id="重载和作用域"><a href="#重载和作用域" class="headerlink" title="重载和作用域"></a>重载和作用域</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fooBar</span><span class="params">(<span class="type">int</span> ival)</span></span>&#123;</span><br><span class="line"><span class="type">bool</span> read = <span class="literal">false</span>;<span class="comment">//新作用域：隐藏了外部的read</span></span><br><span class="line">string s = <span class="built_in">read</span>();<span class="comment">//错误：read是一个bool值，而非一个函数</span></span><br><span class="line"><span class="comment">//不好的习惯：通常来说，在局部作用域声明函数是一个不好的习惯</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//新作用域：隐藏了之前的print</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Value: &quot;</span>);<span class="comment">//错误，没有这个函数，虽然之前声明了void print(const string &amp;);</span></span><br><span class="line"><span class="built_in">print</span>(ival);<span class="comment">//正确，当前print可见</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3.14</span>);<span class="comment">//调用的还是print(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><ul><li>只能省略尾部的实参</li><li>默认实参声明</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>;<span class="comment">//错误：重复声明</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>, sz = <span class="number">80</span>, <span class="type">char</span>)</span></span>;<span class="comment">//正确：添加默认实参</span></span><br></pre></td></tr></table></figure><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul><li>可以避免函数调用的开销</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp;</span></span><br><span class="line"><span class="function"><span class="title">shorterString</span><span class="params">( <span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1, s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内联说明只是向编译器发送一个请求，编译器可以选择忽略这个请求</li></ul><h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><ul><li>函数的形参和返回类型都得是字面值类型，而且函数中有且只有一条return语句</li><li>constexpr函数中允许空语句，类型别名，using声明</li><li>constexpr返回的不一定是常量表达式，只有满足上诉要求的才会返回返回常量表达式</li><li>如果将constexpr函数用在需要常量表达式的地方，且不满足上述要求，编译器在检查过后会报错</li></ul><h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><ul><li>程序可以包含一些用于调试的代码，但是这些代码只在调试的时候使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码，这种方法用到两项预处理功能：assert和NDEBUG</li><li>c++primer：p216</li></ul><h1 id="第7章-类"><a href="#第7章-类" class="headerlink" title="第7章 类"></a>第7章 类</h1><h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><ul><li>常量对象，以及常量对象的引用或指针都只能调用常量成员函数</li></ul><h2 id="class和struct的唯一区别就是访问权限"><a href="#class和struct的唯一区别就是访问权限" class="headerlink" title="class和struct的唯一区别就是访问权限"></a>class和struct的唯一区别就是访问权限</h2><ul><li>class默认是private的，struct默认是public</li></ul><h2 id="一般来说，最好在类定义一开始或结束前的位置集中声明友元"><a href="#一般来说，最好在类定义一开始或结束前的位置集中声明友元" class="headerlink" title="一般来说，最好在类定义一开始或结束前的位置集中声明友元"></a>一般来说，最好在类定义一开始或结束前的位置集中声明友元</h2><ul><li>友元的声明仅仅只是指定了访问权限，而非一个通用意义上的声明，如果希望类的用户能够调用某个友元函数，我们必须在对友元函数的声明之外再对函数进行一次声明。我们通常吧友元的声明和类本身放置在一个头文件中</li></ul><h2 id="封装的益处"><a href="#封装的益处" class="headerlink" title="封装的益处"></a>封装的益处</h2><ul><li>确保用户不会无意间破坏封装对象的状态</li><li>被封装的类的具体实现细节可以随时更改，而无需调整用户级别的代码</li></ul><h2 id="inline成员函数应该与头文件放在同一个头文件中"><a href="#inline成员函数应该与头文件放在同一个头文件中" class="headerlink" title="inline成员函数应该与头文件放在同一个头文件中"></a>inline成员函数应该与头文件放在同一个头文件中</h2><h2 id="可变数据成员mutable"><a href="#可变数据成员mutable" class="headerlink" title="可变数据成员mutable"></a>可变数据成员mutable</h2><ul><li>如果需要修改一个数据成员，即使是在一个const成员函数中，就将加上mutable关键字</li></ul><h2 id="当我们提供一个类内初始值时，必须以符号-或者花括号表示"><a href="#当我们提供一个类内初始值时，必须以符号-或者花括号表示" class="headerlink" title="当我们提供一个类内初始值时，必须以符号&#x3D;或者花括号表示"></a>当我们提供一个类内初始值时，必须以符号&#x3D;或者花括号表示</h2><ul><li>不能使用()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class name&#123;</span><br><span class="line">public:</span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">int cur = 0</span><br><span class="line">int pre&#123;0&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="友元关系不存在传递性"><a href="#友元关系不存在传递性" class="headerlink" title="友元关系不存在传递性"></a>友元关系不存在传递性</h2><h2 id="类型名的特殊处理"><a href="#类型名的特殊处理" class="headerlink" title="类型名的特殊处理"></a>类型名的特殊处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> bal;&#125;<span class="comment">//使用外层作用域的Money</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;<span class="comment">//错误：不能重新定义Money</span></span><br><span class="line">Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>尽管重新定义数据类型名字是一种错误的行为，但是编译器并不为此负责。一些编译器任将顺利通过这样的代码，而忽略代码有错的实事</li><li>类型别名的定义通常出现在类的开始处，这样确保所有使用该类型的成员都出现在类型名定义之后</li></ul><h2 id="通常情况下，不建议参数和成员的名字一样"><a href="#通常情况下，不建议参数和成员的名字一样" class="headerlink" title="通常情况下，不建议参数和成员的名字一样"></a>通常情况下，不建议参数和成员的名字一样</h2><h2 id="令构造函数初始值的顺序与成员函数的声明顺序保持一致"><a href="#令构造函数初始值的顺序与成员函数的声明顺序保持一致" class="headerlink" title="令构造函数初始值的顺序与成员函数的声明顺序保持一致"></a>令构造函数初始值的顺序与成员函数的声明顺序保持一致</h2><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><ul><li>目的是<strong>简化构造函数的书写，提高代码的可维护性，避免代码冗余膨胀</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//dtor1</span></span><br><span class="line"><span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> prices):</span><br><span class="line"><span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(cnt*price)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托构造</span></span><br><span class="line"><span class="built_in">Sales_data</span>(): <span class="built_in">Sales_data</span>(<span class="string">&#x27;&#x27;, 0, 0);//dtor2//委托dtor1</span></span><br><span class="line"><span class="string">Sales_data(std::string s): Sales_data(s, 0, 0);//委托dtor1</span></span><br><span class="line"><span class="string">Sales_data(std::istream &amp;is): Sales_data()//委托dtor2，dtor2再委托dtor1</span></span><br><span class="line"><span class="string">&#123; read(is, &amp;istream); &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数"><a href="#在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数" class="headerlink" title="在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数"></a>在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数</h2><h2 id="explicit构造函数"><a href="#explicit构造函数" class="headerlink" title="explicit构造函数"></a>explicit构造函数</h2><ul><li><p>该构造函数不支持需要隐式转换来初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">className a = <span class="string">&quot;asdasd&quot;</span><span class="comment">//像这种字面值的，需要借助临时对象，不允许调用explicit构成函数</span></span><br></pre></td></tr></table></figure></li><li><p>只允许出现再类内的构造函数处</p></li><li><p>这个构造函数只能用于初始化</p></li></ul><h1 id="第8章-IO类"><a href="#第8章-IO类" class="headerlink" title="第8章 IO类"></a>第8章 IO类</h1><h2 id="宽字符"><a href="#宽字符" class="headerlink" title="宽字符"></a>宽字符</h2><ul><li>wchar_t 16位</li><li>应用例子：可以报汉字变成一个字符</li></ul><ol><li>多字节字符集 (窄字符)</li><li>Unicode字符集（用来解决国际化）（宽字符）</li><li>宽字符有一个宏指令 L(常量宽字符的标识符)，加上它就代表宽字符。</li></ol><p><code>wchar_r ch1 = L‘A’;</code></p><h2 id="IO库设施"><a href="#IO库设施" class="headerlink" title="IO库设施"></a>IO库设施</h2><ul><li><strong>istream</strong>：输入流类型，提供输入操作。</li><li><strong>ostream</strong>：输出流类型，提供输出操作</li><li><strong>cin</strong>：一个<code>istream</code>对象，从标准输入读取数据。</li><li><strong>cout</strong>：一个<code>ostream</code>对象，向标准输出写入数据。</li><li><strong>cerr</strong>：一个<code>ostream</code>对象，向标准错误写入消息。</li><li><strong>&gt;&gt;运算符</strong>：用来从一个<code>istream</code>对象中读取输入数据。</li><li><strong>&lt;&lt;运算符</strong>：用来向一个<code>ostream</code>对象中写入输出数据。</li><li><strong>getline函数</strong>：从一个给定的<code>istream</code>对象中读取一行数据，存入到一个给定的<code>string</code>对象中。</li></ul><h2 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2;<span class="comment">//错误：不能为流对象赋值</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;<span class="comment">//错误：不能初始化ofstream参数</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2);<span class="comment">//错误：不能拷贝流对象</span></span><br></pre></td></tr></table></figure><ul><li>1.IO对象不能存在容器里.</li><li>2.形参和返回类型也不能是流类型。</li><li>3.形参和返回类型一般是流的<strong>引用</strong>。</li><li>4.读写一个IO对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的。</li></ul><h2 id="IO条件状态"><a href="#IO条件状态" class="headerlink" title="IO条件状态"></a>IO条件状态</h2><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td><code>strm:iostate</code></td><td>是一种机器无关的<strong>类型</strong>，提供了表达条件状态的完整功能</td></tr><tr><td><code>strm:badbit</code></td><td>用来指出流已经崩溃</td></tr><tr><td><code>strm:failbit</code></td><td>用来指出一个IO操作失败了</td></tr><tr><td><code>strm:eofbit</code></td><td>用来指出流到达了文件结束</td></tr><tr><td><code>strm:goodbit</code></td><td>用来指出流未处于错误状态，此值保证为零</td></tr><tr><td><code>s.eof()</code></td><td>若流<code>s</code>的<code>eofbit</code>置位，则返回<code>true</code></td></tr><tr><td><code>s.fail()</code></td><td>若流<code>s</code>的<code>failbit</code>置位，则返回<code>true</code></td></tr><tr><td><code>s.bad()</code></td><td>若流<code>s</code>的<code>badbit</code>置位，则返回<code>true</code></td></tr><tr><td><code>s.good()</code></td><td>若流<code>s</code>处于有效状态，则返回<code>true</code></td></tr><tr><td><code>s.clear()</code></td><td>将流<code>s</code>中所有条件状态位复位，将流的状态设置成有效，返回<code>void</code></td></tr><tr><td><code>s.clear(flags)</code></td><td>将流<code>s</code>中指定的条件状态位复位，返回<code>void</code></td></tr><tr><td><code>s.setstate(flags)</code></td><td>根据给定的标志位，将流<code>s</code>中对应的条件状态位置位，返回<code>void</code></td></tr><tr><td><code>s.rdstate()</code></td><td>返回流<code>s</code>的当前条件状态，返回值类型为<code>strm::iostate</code></td></tr></tbody></table><ul><li>上表中，<code>strm</code>是一种IO类型，（如<code>istream</code>）， <code>s</code>是一个流对象。</li></ul><h2 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h2><ul><li>每个输出流都管理一个缓冲区，执行输出的代码，文本串可能立即打印出来，也可能被操作系统保存在缓冲区内，随后再打印。</li><li>刷新缓冲区，可以使用如下IO操纵符：<ul><li><code>endl</code>：输出一个换行符并刷新缓冲区。</li><li><code>flush</code>：刷新流，单不添加任何字符。</li><li><code>ends</code>：在缓冲区插入空字符<code>null</code>，然后刷新。</li><li><code>unitbuf</code>：告诉流接下来每次操作之后都要进行一次<code>flush</code>操作。</li><li><code>nounitbuf</code>：回到正常的缓冲方式。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hi&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi&quot;</span> &lt;&lt; flush;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi&quot;</span> &lt;&lt; ends;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; unitbuf;</span><br><span class="line"><span class="comment">//每次操作之后都要进行一次`flush`操作</span></span><br><span class="line">cout &lt;&lt; nounitbuf;</span><br></pre></td></tr></table></figure><ul><li><p>关联输入和输出流</p><ul><li><p>任何试图从输入流中读取数据的操作都会先刷新关联的输出流</p></li><li><p>标准的cout和cin关联到了一起</p><p><code>in.tie( &amp;out );</code></p></li></ul></li><li><p>每个流同时最多关联到一个流</p></li><li><p>但多个流可以关联到一个ostream</p></li></ul><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><ul><li><p>头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fstream</span><br></pre></td></tr></table></figure><p>定义了三个类型来支持文件IO：</p><ul><li><code>ifstream</code>从一个给定文件读取数据。</li><li><code>ofstream</code>向一个给定文件写入数据。</li><li><code>fstream</code>可以读写给定文件。</li></ul></li><li><p><strong>文件流</strong>：需要读写文件时，必须定义自己的文件流对象，并绑定在需要的文件上。</p></li></ul><h3 id="fstream特有的操作"><a href="#fstream特有的操作" class="headerlink" title="fstream特有的操作"></a>fstream特有的操作</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>fstream fstrm;</code></td><td>创建一个未绑定的文件流。</td></tr><tr><td><code>fstream fstrm(s);</code></td><td>创建一个文件流，并打开名为<code>s</code>的文件，<code>s</code>可以是<code>string</code>也可以是<code>char</code>指针</td></tr><tr><td><code>fstream fstrm(s, mode);</code></td><td>与前一个构造函数类似，但按指定<code>mode</code>打开文件</td></tr><tr><td><code>fstrm.open(s)</code></td><td>打开名为<code>s</code>的文件，并和<code>fstrm</code>绑定</td></tr><tr><td><code>fstrm.close()</code></td><td>关闭和<code>fstrm</code>绑定的文件</td></tr><tr><td><code>fstrm.is_open()</code></td><td>返回一个<code>bool</code>值，指出与<code>fstrm</code>关联的文件是否成功打开且尚未关闭</td></tr></tbody></table><p>上表中，<code>fstream</code>是头文件<code>fstream</code>中定义的一个类型，<code>fstrm</code>是一个文件流对象。</p><ul><li>用read，print函数来读写文件</li><li>fstream代替<strong>iostream&#x3D;&#x3D;&amp;&#x3D;&#x3D;</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>])</span></span>;<span class="comment">//打开销售文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">output</span><span class="params">(argv[<span class="number">2</span>])</span></span>;<span class="comment">//打开输出文件</span></span><br><span class="line">Sales_data total;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(intput, total))&#123;<span class="comment">//读取第一条销售记录</span></span><br><span class="line">Sales_data trans;<span class="comment">//保存下一条销售记录的数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">read</span>(intput, trans))&#123;</span><br><span class="line"><span class="keyword">if</span>(total.<span class="built_in">isbn</span>() == trans.<span class="built_in">isbn</span>())</span><br><span class="line">total.<span class="built_in">combine</span>(trans);<span class="comment">//更新销售总额</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">print</span>(output, total) &lt;&lt;endl;<span class="comment">//打印结果到输出文件</span></span><br><span class="line">total = trans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">cerr &lt;&lt; <span class="string">&quot;No data?!&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>成员函数open和close</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifstream in(ifile);//构筑一个ifstream并打开指定文件</span><br><span class="line">ofstream out;//输出文件流并未与任何文件关联</span><br><span class="line">out.open(ifile + &quot;.copy&quot;)//打开指定文件，调用失败，filebit会置位</span><br><span class="line">if(out)//检查open是否成功</span><br></pre></td></tr></table></figure><ul><li>进行open是否成功的检测通常是一个好习惯</li><li>每个fstream对象被销毁时，close会自动调用</li></ul><h2 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h2><table><thead><tr><th>文件模式</th><th>解释</th></tr></thead><tbody><tr><td><code>in</code></td><td>以读的方式打开</td></tr><tr><td><code>out</code></td><td>以写的方式打开</td></tr><tr><td><code>app</code></td><td>每次写操作前均定位到文件末尾</td></tr><tr><td><code>ate</code></td><td>打开文件后立即定位到文件末尾</td></tr><tr><td><code>trunc</code></td><td>截断文件</td></tr><tr><td><code>binary</code></td><td>以二进制方式进行IO操作。</td></tr></tbody></table><h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><ul><li><p>头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sstream</span><br></pre></td></tr></table></figure><p>定义了三个类型来支持内存IO：</p><ul><li><code>istringstream</code>从<code>string</code>读取数据。</li><li><code>ostringstream</code>向<code>string</code>写入数据。</li><li><code>stringstream</code>可以读写给定<code>string</code>。</li></ul></li></ul><h3 id="stringstream特有的操作"><a href="#stringstream特有的操作" class="headerlink" title="stringstream特有的操作"></a>stringstream特有的操作</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>sstream strm</code></td><td>定义一个未绑定的<code>stringstream</code>对象</td></tr><tr><td><code>sstream strm(s)</code></td><td>用<code>s</code>初始化对象</td></tr><tr><td><code>strm.str()</code></td><td>返回<code>strm</code>所保存的<code>string</code>的拷贝</td></tr><tr><td><code>strm.str(s)</code></td><td>将<code>s</code>拷贝到<code>strm</code>中，返回<code>void</code></td></tr></tbody></table><p>上表中<code>sstream</code>是头文件<code>sstream</code>中任意一个类型。<code>s</code>是一个<code>string</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//ostringstream 用于执行C风格字符串的输出操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ostringstream_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//ostringstream 只支持 &lt;&lt; 操作符</span></span><br><span class="line">std::ostringstream oss;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;this is test&quot;</span> &lt;&lt; <span class="number">123456</span>;</span><br><span class="line"> std::cout&lt;&lt;oss.<span class="built_in">str</span>()&lt;&lt;std::endl;</span><br><span class="line">oss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//清空之前的内容</span></span><br><span class="line"><span class="comment">//oss.clear();//并不能清空内存</span></span><br><span class="line"><span class="comment">//浮点数转换限制</span></span><br><span class="line"><span class="type">double</span> tmp = <span class="number">123.1234567890123</span>;</span><br><span class="line">oss.<span class="built_in">precision</span>(<span class="number">12</span>);</span><br><span class="line">oss.<span class="built_in">setf</span>(std::ios::fixed);<span class="comment">//将浮点数的位数限定为小数点之后的位数</span></span><br><span class="line">oss &lt;&lt; tmp;</span><br><span class="line"> </span><br><span class="line">std::cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot;\r\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//istringstream 用于执行C风格字符串的输入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">istringstream_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//istringstream 只支持 &gt;&gt; 操作符</span></span><br><span class="line">std::string str = <span class="string">&quot;welcome to china&quot;</span>;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//把字符串中以空格隔开的内容提取出来</span></span><br><span class="line">std::string out;</span><br><span class="line"><span class="keyword">while</span>(iss &gt;&gt; out)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; out &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\r\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//stringstream 同时支持C风格字符串的输入输出操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stringstream_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;hello this is kandy &quot;</span> &lt;&lt; <span class="number">123</span>;</span><br><span class="line">std::cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot;\r\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">std::string out;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; out)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; out.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\r\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ostringstream_test</span>();</span><br><span class="line"><span class="built_in">istringstream_test</span>();</span><br><span class="line"><span class="built_in">stringstream_test</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第9章-顺序容器"><a href="#第9章-顺序容器" class="headerlink" title="第9章 顺序容器"></a>第9章 顺序容器</h1><h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><ul><li><strong>顺序容器</strong>（sequential container）：为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</li></ul><h3 id="顺序容器类型"><a href="#顺序容器类型" class="headerlink" title="顺序容器类型"></a>顺序容器类型</h3><table><thead><tr><th>容器类型</th><th>介绍</th></tr></thead><tbody><tr><td><code>vector</code></td><td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。</td></tr><tr><td><code>deque</code></td><td>双端队列。支持快速随机访问。在头尾位置插入&#x2F;删除速度很快。</td></tr><tr><td><code>list</code></td><td>双向链表。只支持双向顺序访问。在<code>list</code>中任何位置进行插入&#x2F;删除操作速度都很快。</td></tr><tr><td><code>forward_list</code></td><td>单向链表。只支持单向顺序访问。在链表任何位置进行插入&#x2F;删除操作速度都很快。</td></tr><tr><td><code>array</code></td><td>固定大小数组。支持快速随机访问。不能添加或者删除元素。</td></tr><tr><td><code>string</code></td><td>与<code>vector</code>相似的容器，但专门用于保存字符。随机访问块。在尾部插入&#x2F;删除速度快。</td></tr></tbody></table><ul><li>除了固定大小的<code>array</code>外，其他容器都提供高效、灵活的内存管理。</li><li><code>forward_list</code>和<code>array</code>是新C++标准增加的类型。</li><li>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。</li><li>新标准库的容器比旧版的快得多。</li></ul><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>iterator</code></td><td>此容器类型的迭代器类型</td></tr><tr><td><code>const_iterator</code></td><td>可以读取元素但不能修改元素的迭代器类型</td></tr><tr><td><code>size_type</code></td><td>无符号整数类型，足够保存此种容器类型最大可能的大小</td></tr><tr><td><code>difference_type</code></td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td><code>value_type</code></td><td>元素类型</td></tr><tr><td><code>reference</code></td><td>元素的左值类型；和<code>value_type &amp;</code>含义相同</td></tr><tr><td><code>const_reference</code></td><td>元素的<code>const</code>左值类型，即<code>const value_type &amp;</code></td></tr></tbody></table><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>C c;</code></td><td>默认构造函数，构造空容器</td></tr><tr><td><code>C c1(c2);</code>或<code>C c1 = c2;</code></td><td>构造<code>c2</code>的拷贝<code>c1</code></td></tr><tr><td><code>C c(b, e)</code></td><td>构造<code>c</code>，将迭代器<code>b</code>和<code>e</code>指定范围内的所有元素拷贝到<code>c</code></td></tr><tr><td><code>C c(a, b, c...)</code></td><td>列表初始化<code>c</code></td></tr><tr><td><code>C c(n)</code></td><td>只支持顺序容器，且不包括<code>array</code>，包含<code>n</code>个元素，这些元素进行了值初始化</td></tr><tr><td><code>C c(n, t)</code></td><td>包含<code>n</code>个初始值为<code>t</code>的元素</td></tr></tbody></table><ul><li>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</li><li><code>array</code>具有固定大小。</li><li>和其他容器不同，默认构造的<code>array</code>是非空的。</li><li>直接复制：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。</li><li>使用迭代器复制：不要求容器类型相同，容器内的元素类型也可以不同。</li></ul><h3 id="当将容器初始化为另一个容器的拷贝时，两个容器类型和元素类型都必须一致"><a href="#当将容器初始化为另一个容器的拷贝时，两个容器类型和元素类型都必须一致" class="headerlink" title="当将容器初始化为另一个容器的拷贝时，两个容器类型和元素类型都必须一致"></a>当将容器初始化为另一个容器的拷贝时，两个容器类型和元素类型都必须一致</h3><h3 id="array支持拷贝和赋值，内置数组不行"><a href="#array支持拷贝和赋值，内置数组不行" class="headerlink" title="array支持拷贝和赋值，内置数组不行"></a>array支持拷贝和赋值，内置数组不行</h3><h3 id="容器之间容器类型和元素类型不一致的时候，如果可以转换，-assign方式用于赋值-，-迭代器方式用于初始化"><a href="#容器之间容器类型和元素类型不一致的时候，如果可以转换，-assign方式用于赋值-，-迭代器方式用于初始化" class="headerlink" title="容器之间容器类型和元素类型不一致的时候，如果可以转换，&#x3D;&#x3D;assign方式用于赋值&#x3D;&#x3D;，&#x3D;&#x3D;迭代器方式用于初始化&#x3D;&#x3D;"></a>容器之间容器类型和元素类型不一致的时候，如果可以转换，&#x3D;&#x3D;assign方式用于赋值&#x3D;&#x3D;，&#x3D;&#x3D;迭代器方式用于初始化&#x3D;&#x3D;</h3><h3 id="向一个vector，string或deque插入元素会使所有指向容器的迭代器、引用和指针失效"><a href="#向一个vector，string或deque插入元素会使所有指向容器的迭代器、引用和指针失效" class="headerlink" title="向一个vector，string或deque插入元素会使所有指向容器的迭代器、引用和指针失效"></a>向一个vector，string或deque插入元素会使所有指向容器的迭代器、引用和指针失效</h3><h3 id="emplace函数在容器中直接构造函数，所以要传递给emplace函数的参数必须与元素类型的构造函数相同"><a href="#emplace函数在容器中直接构造函数，所以要传递给emplace函数的参数必须与元素类型的构造函数相同" class="headerlink" title="emplace函数在容器中直接构造函数，所以要传递给emplace函数的参数必须与元素类型的构造函数相同"></a>emplace函数在容器中直接构造函数，所以要传递给emplace函数的参数必须与元素类型的构造函数相同</h3><h3 id="对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误"><a href="#对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误" class="headerlink" title="对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误"></a>对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误</h3><ul><li>所以要先判断容器是否为空</li></ul><h3 id="如果我们希望确保下标是合法的，可以使用-at成员函数，at成员函数类似下标运算符，但如果下标越界，-at会抛出一个-out-of-range-异常"><a href="#如果我们希望确保下标是合法的，可以使用-at成员函数，at成员函数类似下标运算符，但如果下标越界，-at会抛出一个-out-of-range-异常" class="headerlink" title="如果我们希望确保下标是合法的，可以使用.at成员函数，at成员函数类似下标运算符，但如果下标越界，.at会抛出一个&#x3D;&#x3D;out_of_range&#x3D;&#x3D;异常"></a>如果我们希望确保下标是合法的，可以使用.at成员函数，at成员函数类似下标运算符，但如果下标越界，.at会抛出一个&#x3D;&#x3D;out_of_range&#x3D;&#x3D;异常</h3><h3 id="如果在一个循环中插入-删除deque、string或vector中的元素，不要缓存end-迭代器"><a href="#如果在一个循环中插入-删除deque、string或vector中的元素，不要缓存end-迭代器" class="headerlink" title="如果在一个循环中插入&#x2F;删除deque、string或vector中的元素，不要缓存end()迭代器"></a>如果在一个循环中插入&#x2F;删除deque、string或vector中的元素，不要缓存end()迭代器</h3><h1 id="第10章-泛型算法"><a href="#第10章-泛型算法" class="headerlink" title="第10章 泛型算法"></a>第10章 泛型算法</h1><h2 id="对于只读取而不改变元素的算法，通常最好使用-cbegin-和-cend"><a href="#对于只读取而不改变元素的算法，通常最好使用-cbegin-和-cend" class="headerlink" title="对于只读取而不改变元素的算法，通常最好使用 cbegin() 和 cend()"></a>对于只读取而不改变元素的算法，通常最好使用 cbegin() 和 cend()</h2><h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="&#x3D;&#x3D;lambda&#x3D;&#x3D;表达式"></a>&#x3D;&#x3D;lambda&#x3D;&#x3D;表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; return type&#123; function body &#125;;</span><br></pre></td></tr></table></figure><h2 id="捕获列表只用于局部非-static-变量，lambda-可以直接使用-static-局部变量和在它所在函数之外声明的变量"><a href="#捕获列表只用于局部非-static-变量，lambda-可以直接使用-static-局部变量和在它所在函数之外声明的变量" class="headerlink" title="捕获列表只用于局部非 static 变量，lambda 可以直接使用 static 局部变量和在它所在函数之外声明的变量"></a>捕获列表只用于局部非 static 变量，lambda 可以直接使用 static 局部变量和在它所在函数之外声明的变量</h2><ul><li>函数传递lambda以及auto定义一个用lambda初始的变量时，定义了一个从lambda生成大的类型的对象</li></ul><h2 id="如果函数返回一个lambda，lambda不能包含引用捕获"><a href="#如果函数返回一个lambda，lambda不能包含引用捕获" class="headerlink" title="如果函数返回一个lambda，lambda不能包含引用捕获"></a>如果函数返回一个lambda，lambda不能包含引用捕获</h2><h2 id="默认情况下，对于一个值被拷贝的变量，lambda不会改变其值，如果我们希望改变，-mutable"><a href="#默认情况下，对于一个值被拷贝的变量，lambda不会改变其值，如果我们希望改变，-mutable" class="headerlink" title="默认情况下，对于一个值被拷贝的变量，lambda不会改变其值，如果我们希望改变，+&#x3D;&#x3D;mutable&#x3D;&#x3D;"></a>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值，如果我们希望改变，+&#x3D;&#x3D;mutable&#x3D;&#x3D;</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123;v1++;&#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>();<span class="comment">//j=43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="何时需要指定lambda的返回类型"><a href="#何时需要指定lambda的返回类型" class="headerlink" title="何时需要指定lambda的返回类型"></a>何时需要指定lambda的返回类型</h2><ul><li>如果一个lambda体包含return之外的任何语句，则编译器假定lambda返回void，此时需要指定返回值类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v1,<span class="built_in">begin</span>(), [](<span class="type">int</span> i)-&gt;<span class="type">int</span>&#123;<span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i;<span class="keyword">else</span> <span class="keyword">return</span> i;&#125;);</span><br></pre></td></tr></table></figure><h2 id="bind函数-函数体-替换lambda表达式-解决有时可能希望操作可以接受更多的参数。"><a href="#bind函数-函数体-替换lambda表达式-解决有时可能希望操作可以接受更多的参数。" class="headerlink" title="&#x3D;&#x3D;bind函数+函数体&#x3D;&#x3D;替换lambda表达式-解决有时可能希望操作可以接受更多的参数。"></a>&#x3D;&#x3D;bind函数+函数体&#x3D;&#x3D;替换lambda表达式-解决有时可能希望操作可以接受更多的参数。</h2><ul><li>bind函数在&lt;functional&gt;中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(Callable, arg_list);</span><br></pre></td></tr></table></figure><ul><li>callable-可调用对象</li><li>find_if 的第三个参数只接受一元谓词</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_size</span><span class="params">(<span class="type">const</span> std::string &amp;a, std::string::size_type sz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; sz;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; words = &#123;<span class="string">&quot;hell&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;helloworld&quot;</span>, <span class="string">&quot;fpic&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> end_f = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(check_size, std::placeholders::_1, <span class="number">6</span>));</span><br><span class="line">    std::cout &lt;&lt; *end_f &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bind参数-修改绑定的可调用对象的参数调用顺序"><a href="#bind参数-修改绑定的可调用对象的参数调用顺序" class="headerlink" title="bind参数-修改绑定的可调用对象的参数调用顺序"></a>bind参数-修改绑定的可调用对象的参数调用顺序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = (f, a, b, _2, c, _1);</span><br><span class="line"><span class="built_in">g</span>(X, Y);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="built_in">f</span>(a, b, Y, c, X);</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用案例</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(isShorter, std::placeholders::_2, std::placeholders::_1));</span><br></pre></td></tr></table></figure><h2 id="bind绑定引用参数-ostream"><a href="#bind绑定引用参数-ostream" class="headerlink" title="bind绑定引用参数-ostream"></a>bind绑定引用参数-ostream</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda</span></span><br><span class="line">functino&#123;</span><br><span class="line">ostream os;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [&amp;os, c](<span class="type">const</span> string &amp;a)&#123; os &lt;&lt; a &lt;&lt; c; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bind - bind只能拷贝参数给可调用对象-但os不能被拷贝-就要用到ref</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> string &amp;a, <span class="type">char</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> os &lt;&lt; a &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), worde,<span class="built_in">end</span>(), <span class="built_in">bind</span>(print, <span class="built_in">ref</span>(os), std::placeholders::_1, <span class="string">&#x27; &#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>ref(os)<ul><li>函数ref返回一个对象(类)，包含给定的引用，此对象时&#x3D;&#x3D;可以拷贝&#x3D;&#x3D;的。</li></ul></li><li>cref( object )<ul><li>生成一个保存const引用的类</li></ul></li></ul><h2 id="插入迭代器-用于-持续插入"><a href="#插入迭代器-用于-持续插入" class="headerlink" title="插入迭代器-用于&#x3D;&#x3D;持续插入&#x3D;&#x3D;"></a>插入迭代器-用于&#x3D;&#x3D;持续插入&#x3D;&#x3D;</h2><ul><li>back_inserter<ul><li>创建一个使用push_back() 的迭代器</li></ul></li><li>front_inserter <ul><li>创建一个push_front() 迭代器</li></ul></li><li>inserter<ul><li>创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指定给容器的迭代器。元素将被插入到给定迭代器所表示的元素之前</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)<span class="comment">//排序-为了去重</span></span><br><span class="line">         &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; lis;</span><br><span class="line">    <span class="built_in">unique_copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(lis));<span class="comment">//back_inserter</span></span><br><span class="line">    <span class="built_in">unique_copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">front_inserter</span>(lis));<span class="comment">//front_inserter</span></span><br><span class="line">    <span class="built_in">unique_copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(lis, lis.<span class="built_in">begin</span>()));<span class="comment">//inserter:此处与back_inserter类似</span></span><br><span class="line">    for_each(lis.<span class="built_in">begin</span>(), lis.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;a)</span><br><span class="line">             &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iostream迭代器-流迭代器"><a href="#iostream迭代器-流迭代器" class="headerlink" title="iostream迭代器-流迭代器"></a>iostream迭代器-流迭代器</h2><ul><li><p>*和++不会对ostream_iterator做任何事情</p></li><li><p>向输入迭代器写入数据的算法都假定目标空间足够容纳写入的数据</p></li><li><p>从标准输入中读取数据，存入vector的例子，再从vector中读取数据到标准输出中</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">it</span><span class="params">(cin)</span></span>;</span><br><span class="line">    istream_iterator&lt;<span class="type">int</span>&gt; eof;<span class="comment">//不初始化时，默认初始为尾后迭代器</span></span><br><span class="line">    <span class="comment">//————1————</span></span><br><span class="line">    <span class="comment">//vector&lt;int&gt; vec;</span></span><br><span class="line">    <span class="comment">// while(it != eof)&#123;</span></span><br><span class="line">    <span class="comment">//     vec.push_back(*it++);    //可以读多个数，ctrl+z输入结束</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//————2————</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(it, eof)</span></span>;</span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">os</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;<span class="comment">//第三个参数指的是在每个cout后都加字符串</span></span><br><span class="line">    <span class="comment">//必须是C风格指针，即字面值或者指向以空字符结尾的字符数组的指针</span></span><br><span class="line">    <span class="comment">//for(const auto vec_it : vec)&#123;</span></span><br><span class="line">    <span class="comment">//    //*os++ = vec_it;//*和++不会对ostream_iterator做任何事情</span></span><br><span class="line">   <span class="comment">//  os = vec_it;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), os);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写程序，接受三个参数：一个输入文件和两个输出文件的文件名。输入文件保存的应该是整数。使用 <code>istream_iterator</code> 读取输入文件。使用 <code>ostream_iterator</code> 将奇数写入第一个输入文件，每个值后面都跟一个空格。将偶数写入第二个输出文件，每个值都独占一行。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;./file.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">os1</span><span class="params">(<span class="string">&quot;./jishu.txt&quot;</span>)</span>, <span class="title">os2</span><span class="params">(<span class="string">&quot;./oushu.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(ifs)</span>, eof</span>;</span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out1</span><span class="params">(os1, <span class="string">&quot; &quot;</span>)</span>, <span class="title">out2</span><span class="params">(os2, <span class="string">&quot;\n&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(in!=eof)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*in%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            out2 = *in++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            out1 = *in++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用算法操作流迭代器-accumulate"><a href="#使用算法操作流迭代器-accumulate" class="headerlink" title="使用算法操作流迭代器-accumulate-&lt;numeric&gt;"></a>使用算法操作流迭代器-accumulate-&lt;numeric&gt;</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">it</span><span class="params">(cin)</span>, eof</span>;<span class="comment">//不初始化时，默认初始为尾后迭代器</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">accumulate</span>(it, eof, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reverse-iterator（反向迭代器）"><a href="#reverse-iterator（反向迭代器）" class="headerlink" title="reverse_iterator（反向迭代器）"></a>reverse_iterator（反向迭代器）</h2><ul><li>反向迭代器转换为普通迭代器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello, welcome to my channel, end&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> rcomma = <span class="built_in">find</span>(s.<span class="built_in">crbegin</span>(), s.<span class="built_in">crend</span>(), <span class="string">&#x27;,&#x27;</span>);<span class="comment">//逆向找第一个逗号,commma是一个反向迭代器</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">string</span>(rcomma.<span class="built_in">base</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//rcomma.base()会跳到rcomma下一位，并且方向改为正向</span></span><br></pre></td></tr></table></figure><h2 id="接受单独beg2的算法假定从beg2开始的序列与beg-和-end-所表示的范围至少一样大"><a href="#接受单独beg2的算法假定从beg2开始的序列与beg-和-end-所表示的范围至少一样大" class="headerlink" title="接受单独beg2的算法假定从beg2开始的序列与beg 和 end 所表示的范围至少一样大"></a>接受单独beg2的算法假定从beg2开始的序列与beg 和 end 所表示的范围至少一样大</h2><h2 id="对于-list-和-forward-list，应该优先使用成员函数版本的算法而不是通用算法"><a href="#对于-list-和-forward-list，应该优先使用成员函数版本的算法而不是通用算法" class="headerlink" title="对于 list 和 forward_list，应该优先使用成员函数版本的算法而不是通用算法"></a>对于 list 和 forward_list，应该优先使用成员函数版本的算法而不是通用算法</h2><h1 id="第11章-关联容器"><a href="#第11章-关联容器" class="headerlink" title="第11章 关联容器"></a>第11章 关联容器</h1><h2 id="set、map不可重复，multiset、multimap可重复"><a href="#set、map不可重复，multiset、multimap可重复" class="headerlink" title="set、map不可重复，multiset、multimap可重复"></a>set、map不可重复，multiset、multimap可重复</h2><h2 id="set、map、multimap、multiset底层是红黑树实现的，所以是有序的"><a href="#set、map、multimap、multiset底层是红黑树实现的，所以是有序的" class="headerlink" title="set、map、multimap、multiset底层是红黑树实现的，所以是有序的"></a>set、map、multimap、multiset底层是红黑树实现的，所以是有序的</h2><h2 id="map的value-type-是一个pair类型"><a href="#map的value-type-是一个pair类型" class="headerlink" title="map的value_type 是一个pair类型"></a>map的value_type 是一个pair类型</h2><ul><li>key_type -&gt; pair.first</li><li>mapped_type -&gt; pair.second</li></ul><h2 id="set的迭代器是const的"><a href="#set的迭代器是const的" class="headerlink" title="set的迭代器是const的"></a>set的迭代器是const的</h2><ul><li>尽管是iterator，还是const_iterator</li></ul><h2 id="创建一个pair最简单的方法是用花括号"><a href="#创建一个pair最简单的方法是用花括号" class="headerlink" title="创建一个pair最简单的方法是用花括号"></a>创建一个pair最简单的方法是用花括号</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word_count.<span class="built_in">intsert</span>(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.<span class="built_in">intsert</span>(<span class="built_in">make_pair</span>(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">intsert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">intsert</span>(std::map&lt;string, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h2 id="由于下标运算符会插入一个新元素，我们只可以对非const的map使用下标操作"><a href="#由于下标运算符会插入一个新元素，我们只可以对非const的map使用下标操作" class="headerlink" title="由于下标运算符会插入一个新元素，我们只可以对非const的map使用下标操作"></a>由于下标运算符会插入一个新元素，我们只可以对非const的map使用下标操作</h2><h2 id="访问元素-find-和-count"><a href="#访问元素-find-和-count" class="headerlink" title="访问元素 find() 和 count()"></a>访问元素 find() 和 count()</h2><h2 id="在multiset和multimap中查找元素"><a href="#在multiset和multimap中查找元素" class="headerlink" title="在multiset和multimap中查找元素"></a>在multiset和multimap中查找元素</h2><ul><li>cout() + find()</li><li>.upper_bound 和 .lower_bound</li><li>.equal_range</li></ul><h2 id="map插入元素-下标和insert的区别"><a href="#map插入元素-下标和insert的区别" class="headerlink" title="map插入元素-下标和insert的区别"></a>map插入元素-下标和insert的区别</h2><ul><li>如果key重复<ul><li>下标运算符会保留最后一次添加的mapped_type</li><li>insert保留第一次添加的mapped_type</li></ul></li></ul><h2 id="如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希奇数解决，就可以使用无序容器"><a href="#如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希奇数解决，就可以使用无序容器" class="headerlink" title="如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希奇数解决，就可以使用无序容器"></a>如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希奇数解决，就可以使用无序容器</h2><h1 id="第12章-动态内存"><a href="#第12章-动态内存" class="headerlink" title="第12章 动态内存"></a>第12章 动态内存</h1><h2 id="make-shared-函数"><a href="#make-shared-函数" class="headerlink" title="make_shared 函数"></a>make_shared 函数</h2><ul><li><p>在头文件&lt;memory&gt;中</p></li><li><p>最安全的分配和使用动态内存的方法是调用make_shared 的标准库函数。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p5 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();<span class="comment">//值初始化</span></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;vector&lt;<span class="type">int</span>&gt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="shared-ptr-的拷贝和赋值"><a href="#shared-ptr-的拷贝和赋值" class="headerlink" title="shared_ptr 的拷贝和赋值"></a>shared_ptr 的拷贝和赋值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">r = q;<span class="comment">//给r赋值，令它指向另一个地址</span></span><br><span class="line"><span class="comment">//递增q指向的对象的额引用计数</span></span><br><span class="line"><span class="comment">//递减r原来指向的对象的引用计数</span></span><br><span class="line"><span class="comment">//r原来指向的对象已没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure><h2 id="如果你将shared-ptr-存放于一个容器中，而后不再需要全部元素，而只是用其中一部分，要记得用erase-删除不在需要的那些元素"><a href="#如果你将shared-ptr-存放于一个容器中，而后不再需要全部元素，而只是用其中一部分，要记得用erase-删除不在需要的那些元素" class="headerlink" title="如果你将shared_ptr 存放于一个容器中，而后不再需要全部元素，而只是用其中一部分，要记得用erase 删除不在需要的那些元素"></a>如果你将shared_ptr 存放于一个容器中，而后不再需要全部元素，而只是用其中一部分，要记得用erase 删除不在需要的那些元素</h2><h2 id="使用了-动态生存期的资源-的类"><a href="#使用了-动态生存期的资源-的类" class="headerlink" title="使用了&#x3D;&#x3D;动态生存期的资源&#x3D;&#x3D;的类"></a>使用了&#x3D;&#x3D;动态生存期的资源&#x3D;&#x3D;的类</h2><ul><li>程序使用动态内存处于一下三种原因之一：<ul><li>程序不知道自己需要多少对象<ul><li>容器类就是出于这个原因使用动态内存</li></ul></li><li>程序不知道所需对象的准确类型</li><li>程序需要多个对象共享内存</li></ul></li></ul><h2 id="使用动态内存的一个常见原因是允许多个对象共享相同的状态"><a href="#使用动态内存的一个常见原因是允许多个对象共享相同的状态" class="headerlink" title="使用动态内存的一个常见原因是允许多个对象共享相同的状态"></a>使用动态内存的一个常见原因是允许多个对象共享相同的状态</h2><h2 id="出于与变量初始化相同的原因，对动态分配的对象进行初始化通常是一个好主意"><a href="#出于与变量初始化相同的原因，对动态分配的对象进行初始化通常是一个好主意" class="headerlink" title="出于与变量初始化相同的原因，对动态分配的对象进行初始化通常是一个好主意"></a>出于与变量初始化相同的原因，对动态分配的对象进行初始化通常是一个好主意</h2><h2 id="直接管理内存-内存耗尽"><a href="#直接管理内存-内存耗尽" class="headerlink" title="直接管理内存-内存耗尽"></a>直接管理内存-内存耗尽</h2><ul><li>balloc和nothrow都定义在&lt;new&gt;中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//如果分配失败，new返回一个空指针</span><br><span class="line">int *p1 = new int;//如果分配失败，new抛出 std::bad_alloc</span><br><span class="line">int *p2 = new (nothrow) int;</span><br></pre></td></tr></table></figure><h2 id="有内置指针（而不是智能指针）管理的动态内存在被显示释放前一直都会存在"><a href="#有内置指针（而不是智能指针）管理的动态内存在被显示释放前一直都会存在" class="headerlink" title="有内置指针（而不是智能指针）管理的动态内存在被显示释放前一直都会存在"></a>有内置指针（而不是智能指针）管理的动态内存在被显示释放前一直都会存在</h2><h2 id="空悬指针"><a href="#空悬指针" class="headerlink" title="空悬指针"></a>空悬指针</h2><ul><li>当我们delete一个指针之后，指针值就会变为无效。虽然指针已经无效，但在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变成了空悬指针</li></ul><h2 id="接受指针参数的智能指针构造函数时explicit的"><a href="#接受指针参数的智能指针构造函数时explicit的" class="headerlink" title="接受指针参数的智能指针构造函数时explicit的"></a>接受指针参数的智能指针构造函数时explicit的</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);<span class="comment">//错误：必须使用直接初始化的形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;<span class="comment">//正确：使用了直接初始化</span></span><br></pre></td></tr></table></figure><h2 id="使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁"><a href="#使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁" class="headerlink" title="使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁"></a>使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁</h2><h2 id="智能指针——get-函数，用于向不能使用智能指针的代码传递一个内置指针，使用get返回的指针的代码-不能delete此指针"><a href="#智能指针——get-函数，用于向不能使用智能指针的代码传递一个内置指针，使用get返回的指针的代码-不能delete此指针" class="headerlink" title="智能指针——get()函数，用于向不能使用智能指针的代码传递一个内置指针，使用get返回的指针的代码&#x3D;&#x3D;不能delete此指针&#x3D;&#x3D;"></a>智能指针——get()函数，用于向不能使用智能指针的代码传递一个内置指针，使用get返回的指针的代码&#x3D;&#x3D;不能delete此指针&#x3D;&#x3D;</h2><h2 id="智能指针——reset-函数配合unique-函数"><a href="#智能指针——reset-函数配合unique-函数" class="headerlink" title="智能指针——reset()函数配合unique()函数"></a>智能指针——reset()函数配合unique()函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = new int[1024];//错误：不能用指针赋予shared_ptr——和shared_ptr初始化一样</span><br><span class="line">p.reset(new int(1024));//正确：p指向一个新对象</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.unique)</span><br><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));<span class="comment">//我们不是唯一用户；分配新的拷贝</span></span><br><span class="line">*p += newValue;<span class="comment">//现在我们知道自己是唯一的用户，可以改变对象的值</span></span><br></pre></td></tr></table></figure><h2 id="注意：智能指针陷阱"><a href="#注意：智能指针陷阱" class="headerlink" title="注意：智能指针陷阱"></a>注意：智能指针陷阱</h2><ul><li>不使用相同的内置指针值初始化（或reset）多个智能指针</li><li>不delete get() 返回的指针</li><li>不适用get() 或reset另一个智能指针</li><li>如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就无效了</li><li>如果你使用智能指针管理的资源不是new分配的内存，记得传入一个删除器</li></ul><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><ul><li>某一个时刻只能有一个<code>unique_ptr</code>指向一个给定的对象。</li><li>不支持拷贝或者赋值操作。</li><li>向后兼容：<code>auto_ptr</code>：老版本，具有<code>unique_ptr</code>的部分特性。特别是，不能在容器中保存<code>auto_ptr</code>，也不能从函数返回<code>auto_ptr</code>。</li></ul><p><strong>unique_ptr操作</strong>:</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>unique_ptr&lt;T&gt; u1</code></td><td>空<code>unique_ptr</code>，可以指向类型是<code>T</code>的对象。<code>u1</code>会使用<code>delete</code>来是释放它的指针。</td></tr><tr><td><code>unique_ptr&lt;T, D&gt; u2</code></td><td><code>u2</code>会使用一个类型为<code>D</code>的可调用对象来释放它的指针。</td></tr><tr><td><code>unique_ptr&lt;T, D&gt; u(d)</code></td><td>空<code>unique_ptr</code>，指向类型为<code>T</code>的对象，用类型为<code>D</code>的对象<code>d</code>代替<code>delete</code></td></tr><tr><td><code>u = nullptr</code></td><td>释放<code>u</code>指向的对象，将<code>u</code>置为空。</td></tr><tr><td><code>u.release()</code></td><td><code>u</code>放弃对指针的控制权，返回指针，并将<code>u</code>置空。</td></tr><tr><td><code>u.reset()</code></td><td>释放<code>u</code>指向的对象</td></tr><tr><td><code>u.reset(q)</code></td><td>令<code>u</code>指向<code>q</code>指向的对象</td></tr><tr><td><code>u.reset(nullptr)</code></td><td>将<code>u</code>置空</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="built_in">release</span>();<span class="comment">//错误：p不会释放内存，而且我们丢失了指针</span></span><br><span class="line"><span class="keyword">auto</span> p2 = p.<span class="built_in">release</span>()<span class="comment">//正确：但我们必须记得delete(p);</span></span><br></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><ul><li><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针。</li><li>指向一个由<code>shared_ptr</code>管理的对象，不改变<code>shared_ptr</code>的引用计数。</li><li>一旦最后一个指向对象的<code>shared_ptr</code>被销毁，对象就会被释放，不管有没有<code>weak_ptr</code>指向该对象。</li></ul><p><strong>weak_ptr操作</strong>:</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>weak_ptr&lt;T&gt; w</code></td><td>空<code>weak_ptr</code>可以指向类型为<code>T</code>的对象</td></tr><tr><td><code>weak_ptr&lt;T&gt; w(sp)</code></td><td>与<code>shared_ptr</code>指向相同对象的<code>weak_ptr</code>。<code>T</code>必须能转换为<code>sp</code>指向的类型。</td></tr><tr><td><code>w = p</code></td><td><code>p</code>可以是<code>shared_ptr</code>或一个<code>weak_ptr</code>。赋值后<code>w</code>和<code>p</code>共享对象。</td></tr><tr><td><code>w.reset()</code></td><td>将<code>w</code>置为空。</td></tr><tr><td><code>w.use_count()</code></td><td>与<code>w</code>共享对象的<code>shared_ptr</code>的数量。</td></tr><tr><td><code>w.expired()</code></td><td>若<code>w.use_count()</code>为0，返回<code>true</code>，否则返回<code>false</code></td></tr><tr><td><code>w.lock()</code></td><td>如果<code>expired</code>为<code>true</code>，则返回一个空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code>。</td></tr></tbody></table><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><ul><li><code>new</code>一个动态数组：<ul><li>类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量）。</li><li>返回<strong>指向第一个对象的指针</strong>。</li><li><code>int *p = new int[size];</code></li></ul></li><li><code>delete</code>一个动态数组：<ul><li><code>delete [] p;</code></li></ul></li><li><code>unique_ptr</code>和数组：<ul><li>指向数组的<code>unique_ptr</code>不支持成员访问运算符（点和箭头）。</li></ul></li></ul><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>unique_ptr&lt;T[]&gt; u</code></td><td><code>u</code>可以指向一个动态分配的数组，整数元素类型为<code>T</code></td></tr><tr><td><code>unique_ptr&lt;T[]&gt; u(p)</code></td><td><code>u</code>指向内置指针<code>p</code>所指向的动态分配的数组。<code>p</code>必须能转换为类型<code>T*</code>。</td></tr><tr><td><code>u[i]</code></td><td>返回<code>u</code>拥有的数组中位置<code>i</code>处的对象。<code>u</code>必须指向一个数组。</td></tr></tbody></table><h3 id="allocator类——将内存分配和对象构造分离开"><a href="#allocator类——将内存分配和对象构造分离开" class="headerlink" title="allocator类——将内存分配和对象构造分离开"></a>allocator类——将内存分配和对象构造分离开</h3><ul><li>标准库<code>allocator</code>类定义在头文件<code>memory</code>中，帮助我们<strong>将内存分配和对象构造分离开</strong>。——<strong>new是将内存分配和对象构造绑定了</strong></li><li>分配的是原始的、未构造的内存。</li><li><code>allocator</code>是一个模板。</li><li><code>allocator&lt;string&gt; alloc;</code></li></ul><p><strong>标准库allocator类及其算法</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>allocator&lt;T&gt; a</code></td><td>定义了一个名为<code>a</code>的<code>allocator</code>对象，它可以为类型为<code>T</code>的对象分配内存</td></tr><tr><td><code>a.allocate(n)</code></td><td>分配一段原始的、未构造的内存，保存<code>n</code>个类型为<code>T</code>的对象。</td></tr><tr><td><code>a.deallocate(p, n)</code></td><td>释放从<code>T*</code>指针<code>p</code>中地址开始的内存，这块内存保存了<code>n</code>个类型为<code>T</code>的对象；<code>p</code>必须是一个先前由<code>allocate</code>返回的指针。且<code>n</code>必须是<code>p</code>创建时所要求的大小。在调用<code>deallocate</code>之前，用户必须对每个在这块内存中创建的对象调用<code>destroy</code>。</td></tr><tr><td><code>a.construct(p, args)</code></td><td><code>p</code>必须是一个类型是<code>T*</code>的指针，指向一块原始内存；<code>args</code>被传递给类型为<code>T</code>的构造函数，用来在<code>p</code>指向的内存中构造一个对象。</td></tr><tr><td><code>a.destroy(p)</code></td><td><code>p</code>为<code>T*</code>类型的指针，此算法对<code>p</code>指向的对象执行析构函数。</td></tr></tbody></table><p><strong>allocator伴随算法</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>uninitialized_copy(b, e, b2)</code></td><td>从迭代器<code>b</code>和<code>e</code>给定的输入范围中拷贝元素到迭代器<code>b2</code>指定的未构造的原始内存中。<code>b2</code>指向的内存必须足够大，能够容纳输入序列中元素的拷贝。</td></tr><tr><td><code>uninitialized_copy_n(b, n, b2)</code></td><td>从迭代器<code>b</code>指向的元素开始，拷贝<code>n</code>个元素到<code>b2</code>开始的内存中。</td></tr><tr><td><code>uninitialized_fill(b, e, t)</code></td><td>在迭代器<code>b</code>和<code>e</code>执行的原始内存范围中创建对象，对象的值均为<code>t</code>的拷贝。</td></tr><tr><td><code>uninitialized_fill_n(b, n, t)</code></td><td>从迭代器<code>b</code>指向的内存地址开始创建<code>n</code>个对象。<code>b</code>必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。</td></tr></tbody></table><ul><li>定义在头文件<code>memory</code>中。</li><li>在给定目的位置创建元素，而不是由系统分配内存给他们。</li></ul><h1 id="第13章-拷贝控制"><a href="#第13章-拷贝控制" class="headerlink" title="第13章 拷贝控制"></a>第13章 拷贝控制</h1><h2 id="赋值运算符通常应该返回一个指向其左侧运算对象的引用"><a href="#赋值运算符通常应该返回一个指向其左侧运算对象的引用" class="headerlink" title="赋值运算符通常应该返回一个指向其左侧运算对象的引用"></a>赋值运算符通常应该返回一个指向其左侧运算对象的引用</h2><p><strong>拷贝控制操作</strong>（copy control）:</p><ul><li>拷贝构造函数（copy constructor）</li><li>拷贝赋值运算符（copy-assignment operator）</li><li>移动构造函数（move constructor）</li><li>移动赋值函数（move-assignement operator）</li><li>析构函数（destructor）</li></ul><h2 id="拷贝、赋值和销毁"><a href="#拷贝、赋值和销毁" class="headerlink" title="拷贝、赋值和销毁"></a>拷贝、赋值和销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul><li>如果一个构造函数的第一个参数是<strong>自身类类型的引用</strong>，且任何额外参数都有默认值，则此构造函数是<strong>拷贝构造函数</strong>。</li><li><code>class Foo&#123; public: Foo(const Foo&amp;); &#125;</code></li><li><strong>合成的拷贝构造函数</strong>（synthesized copy constructor）：会将参数的成员逐个拷贝到正在创建的对象中。</li><li><strong>拷贝初始化</strong>：<ul><li>将右侧运算对象拷贝到正在创建的对象中，如果需要，还需进行类型转换。</li><li>通常使用拷贝构造函数完成。</li><li><code>string book = &quot;9-99&quot;;</code></li><li>出现场景：<ul><li>用<code>=</code>定义变量时。</li><li>将一个对象作为实参传递给一个非引用类型的形参。</li><li>从一个返回类型为非引用类型的函数返回一个对象。</li><li>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。</li></ul></li></ul></li></ul><h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><ul><li><strong>重载赋值运算符</strong>：<ul><li>重写一个名为<code>operator=</code>的函数.</li><li>通常返回一个指向其左侧运算对象的引用。</li><li><code>Foo&amp; operator=(const Foo&amp;);</code></li></ul></li><li><strong>合成拷贝赋值运算符</strong>：<ul><li>将右侧运算对象的每个非<code>static</code>成员赋予左侧运算对象的对应成员。</li></ul></li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li>释放对象所使用的资源，并销毁对象的非<code>static</code>数据成员。</li><li>名字由波浪号接类名构成。没有返回值，也不接受参数。</li><li><code>~Foo();</code></li><li>调用时机：<ul><li>变量在离开其作用域时。</li><li>当一个对象被销毁时，其成员被销毁。</li><li>容器被销毁时，其元素被销毁。</li><li>动态分配的对象，当对指向它的指针应用<code>delete</code>运算符时。</li><li>对于临时对象，当创建它的完整表达式结束时。</li></ul></li><li><strong>合成析构函数</strong>：<ul><li>空函数体执行完后，<strong>成员会被自动销毁。</strong></li><li>注意：析构函数体本身并不直接销毁成员。</li></ul></li></ul><h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三&#x2F;五法则"></a>三&#x2F;五法则</h3><ul><li>需要析构函数的类也需要拷贝和赋值操作。</li><li>需要拷贝操作的类也需要赋值操作，反之亦然。</li></ul><h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用&#x3D;default"></a>使用&#x3D;default</h3><ul><li>可以通过将拷贝控制成员定义为<code>=default</code>来显式地要求编译器生成合成的版本。</li><li>合成的函数将隐式地声明为内联的。</li></ul><h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><ul><li>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。</li><li>定义删除的函数：<code>=delete</code>。</li><li>虽然声明了它们，但是不能以任何方式使用它们。</li><li>析构函数不能是删除的成员。</li><li>如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，则对应的成员函数将被定义为删除的。</li><li>老版本使用<code>private</code>声明来阻止拷贝。</li></ul><h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><ul><li>类的行为可以像一个值，也可以像一个指针。<ul><li>行为像值：对象有自己的状态，副本和原对象是完全独立的。</li><li>行为像指针：共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。</li></ul></li></ul><h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><ul><li>管理资源的类通常还定义一个名为<code>swap</code>的函数。</li><li>经常用于重排元素顺序的算法。</li><li>用<code>swap</code>而不是<code>std::swap</code>。</li><li>在使用swap前加一个using std::swap是一个好习惯</li></ul><h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><ul><li>很多拷贝操作后，原对象会被销毁，因此引入移动操作可以大幅度提升性能。</li><li>在新标准中，我们可以用容器保存不可拷贝的类型，只要它们可以被移动即可。</li><li>标准库容器、<code>string</code>和<code>shared_ptr</code>类既可以支持移动也支持拷贝。<code>IO</code>类和<code>unique_ptr</code>类可以移动但不能拷贝。</li></ul><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><ul><li>新标准引入右值引用以支持移动操作。</li><li>通过<code>&amp;&amp;</code>获得右值引用。</li><li>只能绑定到一个将要销毁的对象（字面值、临时对象）。</li><li>常规引用可以称之为左值引用。</li><li>左值持久，右值短暂。</li><li>变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行</li></ul><p><strong>move函数</strong>：</p><ul><li><code>int &amp;&amp;rr2 = std::move(rr1);</code></li><li><code>move</code>告诉编译器，我们有一个左值，但我希望像右值一样处理它。</li><li>调用<code>move</code>意味着：除了对<code>rr1</code>赋值或者销毁它外，我们将不再使用它。</li></ul><h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><ul><li><p><strong>移动构造函数</strong>：</p><ul><li>第一个参数是该类类型的一个引用，关键是，这个引用参数是一个<strong>右值引用</strong>。</li><li><code>StrVec::StrVec(StrVec &amp;&amp;s) noexcept&#123;&#125;</code></li><li>移动构造必须加上noexcept，否则vector不会使用移动构造，依然使用拷贝构造。</li><li>不分配任何新内存，只是接管给定的内存。</li></ul></li><li><p><strong>移动赋值运算符</strong>：</p><ul><li><code>StrVec&amp; StrVec::operator=(StrVec &amp;&amp; rhs) noexcept&#123;&#125;</code></li></ul></li><li><p>移动右值，拷贝左值。</p></li><li><p>如果没有移动构造函数，右值也被拷贝。</p></li><li><p>拷贝并交换赋值运算符——<strong>既可以用于拷贝赋值，也可以用于移动赋值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className &amp;<span class="keyword">operator</span>=(className cln)</span><br><span class="line">&#123;<span class="built_in">swap</span>(*<span class="keyword">this</span>, cln); <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure></li><li><p>更新三&#x2F;五法则：如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。</p></li><li><p>移动迭代器：</p><ul><li><code>make_move_iterator</code>函数讲一个普通迭代器转换为一个移动迭代器。</li></ul></li><li><p>建议：小心地使用移动操作，以获得性能提升。</p><ul><li>确保移后源没有其他用户</li></ul></li></ul><h3 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h3><ul><li>区分移动和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>，而另一个版本接受一个<code>T&amp;&amp;</code>。</li><li>引用限定符：<ul><li>在参数列表后面放置一个<code>&amp;</code>，限定只能向可修改的左值赋值而不能向右值赋值。</li><li>在参数列表后面放置&amp;&amp;则相反</li><li>同时有const和&amp;时，顺序为const &amp;</li><li>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有限定符</li></ul></li></ul><h1 id="第14章-重载运算和类型转换"><a href="#第14章-重载运算和类型转换" class="headerlink" title="第14章 重载运算和类型转换"></a>第14章 重载运算和类型转换</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>重载运算符是具有特殊名字的函数：由关键字<code>operator</code>和其后要定义的运算符号共同组成。</li><li>当一个重载的运算符是成员函数时，<code>this</code>绑定到左侧运算对象。动态运算符符函数的参数数量比运算对象的数量<strong>少一个</strong>。</li><li>只能重载大多数的运算符，而不能发明新的运算符号。</li><li>重载运算符的优先级和结合律跟对应的内置运算符保持一致。</li><li>调用方式：<ul><li><code>data1 + data2;</code></li><li><code>operator+(data1, data2);</code></li></ul></li><li>是否是成员函数：<ul><li>赋值（<code>=</code>）、下标（<code>[]</code>）、调用（<code>()</code>）和成员访问箭头（<code>-&gt;</code>）运算符必须是成员。</li><li>复合赋值运算符一般来说是成员。</li><li>改变对象状态的运算符或者和给定类型密切相关的运算符通常是成员，如递增、解引用。</li><li>具有对称性的运算符如算术、相等性、关系和位运算符等，通常是非成员函数。</li></ul></li></ul><p><strong>运算符</strong>:</p><table><thead><tr><th>可以被重载</th><th>不可以被重载</th></tr></thead><tbody><tr><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code></td><td><code>::</code>, <code>.*</code>, <code>.</code>, <code>? :</code>,</td></tr><tr><td><code>&amp;</code>, &#96;</td><td><code>, </code>~&#96;, <code>!</code>, <code>,</code>, <code>=</code></td></tr><tr><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>++</code>, <code>--</code></td><td></td></tr><tr><td><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>==</code>, <code>!=</code>, <code>&amp;&amp;</code>, &#96;</td><td></td></tr><tr><td><code>+=</code>, <code>-=</code>, <code>/=</code>, <code>%=</code>, <code>^=</code>, <code>&amp;=</code></td><td></td></tr><tr><td>|&#x3D;, <code>*=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>[]</code>, <code>()</code></td><td></td></tr><tr><td><code>-&gt;</code>, <code>-&gt;*</code>, <code>new</code>, <code>new[]</code>, <code>delete</code>, <code>delete[]</code></td><td></td></tr></tbody></table><h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><h3 id="重载输出运算符"><a href="#重载输出运算符" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><ul><li>第一个形参通常是一个非常量的<code>ostream</code>对象的引用。非常量是因为向流中写入会改变其状态；而引用是因为我们无法复制一个<code>ostream</code>对象。</li><li>通常，输出运算符应该主要负责打印对象的内容而非控制格式。输出运算符不应该打印换行符</li><li>输入输出运算符必须是非成员函数。</li></ul><h3 id="重载输入运算符"><a href="#重载输入运算符" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><ul><li>第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的（非常量）对象的引用。</li><li>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</li></ul><h2 id="算数和关系运算符（-、-、-、-）"><a href="#算数和关系运算符（-、-、-、-）" class="headerlink" title="算数和关系运算符（+、-、*、&#x2F;）"></a>算数和关系运算符（+、-、*、&#x2F;）</h2><ul><li>如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符。</li></ul><h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符&#x3D;&#x3D;"></a>相等运算符&#x3D;&#x3D;</h3><ul><li>如果定义了<code>operator==</code>，则这个类也应该定义<code>operator!=</code>。</li><li>相等运算符和不等运算符的一个应该把工作委托给另一个。</li><li>相等运算符应该具有传递性。</li><li>如果某个类在逻辑上有相等性的含义，则该类应该定义<code>operator==</code>，这样做可以使用户更容易使用标准库算法来处理这个类。</li></ul><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul><li>如果存在唯一一种逻辑可靠的<code>&lt;</code>定义，则应该考虑为这个类定义<code>&lt;</code>运算符。如果同时还包含<code>==</code>，则当且晋档<code>&lt;</code>的定义和<code>++</code>产生的结果一直时才定义<code>&lt;</code>运算符。</li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符&#x3D;"></a>赋值运算符&#x3D;</h2><ul><li>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。</li><li>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这么做。这两类运算符都应该返回左侧运算对象的引用。</li></ul><h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符[]"></a>下标运算符[]</h2><ul><li>下标运算符必须是成员函数。</li><li>一般会定义两个版本：<ul><li>1.返回普通引用。</li><li>2.类的常量成员，并返回常量引用。</li></ul></li></ul><h2 id="递增和递减运算符（-、–）"><a href="#递增和递减运算符（-、–）" class="headerlink" title="递增和递减运算符（++、–）"></a>递增和递减运算符（++、–）</h2><ul><li>定义递增和递减运算符的类应该同时定义前置版本和后置版本。</li><li>通常应该被定义成类的成员。</li><li>为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。</li><li>同样为了和内置版本保持一致，后置运算符应该返回递增或递减前对象的值，而不是引用。</li><li>后置版本接受一个额外的，不被使用的<code>int</code>类型的形参。因为不会用到，所以无需命名。</li></ul><h2 id="成员访问运算符（-、-）"><a href="#成员访问运算符（-、-）" class="headerlink" title="成员访问运算符（*、-&gt;）"></a>成员访问运算符（*、-&gt;）</h2><ul><li>箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。</li><li>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</li><li>解引用和乘法的区别是一个是一元运算符，一个是二元运算符。</li></ul><h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><ul><li>可以像使用函数一样，调用该类的对象。因为这样对待类同时也能存储状态，所以与普通函数相比更加灵活。</li><li>函数调用运算符必须是成员函数。</li><li>一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</li><li>如果累定义了调用运算符，则该类的对象称作<strong>函数对象</strong>。</li></ul><h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a><code>lambda</code>是函数对象</h3><ul><li><code>lambda</code>捕获变量：<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数。</li></ul><h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p><strong>标准库函数对象</strong>:</p><table><thead><tr><th>算术</th><th>关系</th><th>逻辑</th></tr></thead><tbody><tr><td><code>plus&lt;Type&gt;</code></td><td><code>equal_to&lt;Type&gt;</code></td><td><code>logical_and&lt;Type&gt;</code></td></tr><tr><td><code>minus&lt;Type&gt;</code></td><td><code>not_equal_to&lt;Type&gt;</code></td><td><code>logical_or&lt;Type&gt;</code></td></tr><tr><td><code>multiplies&lt;Type&gt;</code></td><td><code>greater&lt;Type&gt;</code></td><td><code>logical_not&lt;Type&gt;</code></td></tr><tr><td><code>divides&lt;Type&gt;</code></td><td><code>greater_equal&lt;Type&gt;</code></td><td></td></tr><tr><td><code>modulus&lt;Type&gt;</code></td><td><code>less&lt;Type&gt;</code></td><td></td></tr><tr><td><code>negate&lt;Type&gt;</code></td><td><code>less_equal&lt;Type&gt;</code></td><td></td></tr></tbody></table><ul><li>可以在算法中使用标准库函数对象。</li></ul><h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><p><strong>标准库function类型</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>function&lt;T&gt; f;</code></td><td><code>f</code>是一个用来存储可调用对象的空<code>function</code>，这些可调用对象的调用形式应该与类型<code>T</code>相同。</td></tr><tr><td><code>function&lt;T&gt; f(nullptr);</code></td><td>显式地构造一个空<code>function</code></td></tr><tr><td><code>function&lt;T&gt; f(obj)</code></td><td>在<code>f</code>中存储可调用对象<code>obj</code>的副本</td></tr><tr><td><code>f</code></td><td>将<code>f</code>作为条件：当<code>f</code>含有一个可调用对象时为真；否则为假。</td></tr><tr><td>定义为<code>function&lt;T&gt;</code>的成员的类型</td><td></td></tr><tr><td><code>result_type</code></td><td>该<code>function</code>类型的可调用对象返回的类型</td></tr><tr><td><code>argument_type</code></td><td>当<code>T</code>有一个或两个实参时定义的类型。如果<code>T</code>只有一个实参，则<code>argument_type</code></td></tr><tr><td><code>first_argument_type</code></td><td>第一个实参的类型</td></tr><tr><td><code>second_argument_type</code></td><td>第二个实参的类型</td></tr></tbody></table><ul><li>例如：声明一个<code>function</code>类型，它可以表示接受两个<code>int</code>，返回一个<code>int</code>的可调用对象。<code>function&lt;int(int, int)&gt;</code></li><li>函数表——利用map和function（没有不行）可以把函数，lambda，函数指针，函数对象类弄在一起<ul><li>map&lt;std::string, function&lt;..(.., ..)&gt;)</li></ul></li></ul><h2 id="重载、类型转换、运算符"><a href="#重载、类型转换、运算符" class="headerlink" title="重载、类型转换、运算符"></a>重载、类型转换、运算符</h2><h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><ul><li><p>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下：<code>operator type() const;</code></p></li><li><p>一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是<code>const</code>。</p></li><li><p>避免过度使用类型转换函数。</p></li><li><p>C++11引入了显式的类型转换运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(classObeject) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般定义成<code>explicit</code>的。</p><ul><li><p>防止在其他地方自动转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">cin &lt;&lt; i;<span class="comment">//如果向bool的类型转换不是显式的，则该代码在编译器看来将是合法的</span></span><br></pre></td></tr></table></figure></li><li><p>将cin转换成bool，而bool值会被提升成int并用内置的左移运算符的左侧运算对象，这样bool值就会被左移42个位置</p></li></ul></li></ul><h3 id="函数匹配与重载运算符"><a href="#函数匹配与重载运算符" class="headerlink" title="函数匹配与重载运算符"></a>函数匹配与重载运算符</h3><ul><li>如果<code>a</code>是一种类型，则表达式<code>a sym b</code>可能是：<ul><li><code>a.operatorsym(b);</code></li><li><code>operatorsym(a,b);</code></li></ul></li><li>表达式中运算符的候选函数集既应该包括成员函数，也应该包括非成员函数</li><li>如果我们队同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</li></ul><h1 id="第15章-面向对象程序设计"><a href="#第15章-面向对象程序设计" class="headerlink" title="第15章 面向对象程序设计"></a>第15章 面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><ul><li><p>面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。</p></li><li><p>继承</p><p>（inheritance）：</p><ul><li>通过继承联系在一起的类构成一种层次关系。</li><li>通常在层次关系的根部有一个<strong>基类</strong>（base class）。</li><li>其他类直接或者简介从基类继承而来，这些继承得到的类成为<strong>派生类</strong>（derived class）。</li><li>基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</li><li>对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成<strong>虚函数</strong>（virtual function）。</li><li>派生类必须通过使用<strong>类派生列表</strong>（class derivation list）明确指出它是从哪个基类继承而来 。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符。<code>class Bulk_quote : public Quote&#123;&#125;;</code></li><li>派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上<code>virtual</code>关键字，也可以不加。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</li></ul></li><li><p>动态绑定</p><p>（dynamic binding，又称运行时绑定）：</p><ul><li>使用同一段代码可以分别处理基类和派生类的对象。</li><li>函数的运行版本由<strong>实参</strong>决定（形参是基类的引用），即在运行时选择函数的版本。</li></ul></li></ul><h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><ul><li>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</li><li>基类通过在其成员函数的声明语句前加上关键字<code>virtual</code>使得该函数执行<strong>动态绑定</strong>。</li><li>如果成员函数没有被声明为虚函数，则解析过程发生在编译时而非运行时。</li><li>访问控制：<ul><li><code>protected</code> ： 基类和和其派生类还有友元可以访问。</li><li><code>private</code> ： 只有基类本身和友元可以访问。</li></ul></li></ul><h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><ul><li>派生类必须通过类派生列表（class derivation list）明确指出它是从哪个基类继承而来。形式：冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有一下三种访问说明符的一个：<code>public</code>、<code>protected</code>、<code>private</code>。</li><li>C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</li><li>派生类构造函数：派生类必须使用基类的构造函数去初始化它的基类部分。</li><li>静态成员：如果基类定义了一个基类成员，则在整个继承体系中只存在该成员的唯一定义。</li><li>派生类的声明：声明中不包含它的派生列表。</li><li>C++11新标准提供了一种防止继承的方法，在类名后面跟一个关键字<code>final</code>。</li></ul><h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><ul><li>理解基类和派生类之间的类型抓换是理解C++语言面向对象编程的关键所在。</li><li>可以将基类的指针或引用绑定到派生类对象上。</li><li>不存在从基类向派生类的隐式类型转换。</li><li>派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。<ul><li>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分被拷贝、移动或赋值，它的派生类部分将被忽略掉</li></ul></li></ul><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul><li>使用虚函数可以执行动态绑定。</li><li>OOP的核心思想是多态性（polymorphism）。</li><li>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</li><li>派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上<code>virtual</code>关键字，也可以不加。</li><li>C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</li><li>如果我们想覆盖某个虚函数，但不小心把形参列表弄错了，这个时候就不会覆盖基类中的虚函数。加上<code>override</code>可以明确程序员的意图，让编译器帮忙确认参数列表是否出错。</li><li>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</li><li>通常，只有成员函数（或友元）中的代码才需要使用<strong>作用域运算符</strong>（<code>::</code>）来回避虚函数的机制。</li></ul><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><ul><li><strong>纯虚函数</strong>（pure virtual）：清晰地告诉用户当前的函数是没有实际意义的。纯虚函数无需定义，只用在函数体的位置前书写<code>=0</code>就可以将一个虚函数说明为纯虚函数。</li><li>含有纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。不能创建抽象基类的对象。</li></ul><h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><ul><li>受保护的成员：<ul><li><code>protected</code>说明符可以看做是<code>public</code>和<code>private</code>中的产物。</li><li>类似于私有成员，受保护的成员对类的用户来说是不可访问的。</li><li>类似于公有成员，受保护的成员对于派生类的成员和友元来说是可访问的。</li><li>派生类的成员或友元<strong>只能通过派生类对象来访问基类的受保护成员</strong>。派生类对于一个基类对象中的受保护成员没有任何访问特权。</li></ul></li><li>派生访问说明符：<ul><li>对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。</li><li>派生访问说明符的目的是：控制派生类用户对于基类成员的访问权限。比如<code>struct Priv_Drev: private Base&#123;&#125;</code>意味着在派生类<code>Priv_Drev</code>中，从<code>Base</code>继承而来的部分都是<code>private</code>的。</li></ul></li><li>友元关系不能继承。</li><li>改变个别成员的可访问性：使用<code>using</code>。<ul><li>派生类只能为那些他可以访问的名字提供using声明</li></ul></li><li>默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的；使用<code>struct</code>关键字定义的派生类是公有继承的。</li></ul><h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><ul><li>每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。</li><li>派生类的成员将隐藏同名的基类成员。</li><li>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</li><li>使用using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的<strong>所有重载实列</strong>都添加到派生类作用域中，此时，派生类只需要override其中需要的虚函数就可以了</li></ul><h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><ul><li>基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。</li><li>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针将产生未定义的行为。</li><li>虚析构函数将阻止合成移动操作。</li></ul><h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><ul><li>基类或派生类的合成拷贝控制成员的行为和其他合成的构造函数、赋值运算符或析构函数类似：他们对类本身的成员依次进行初始化、赋值或销毁的操作。</li></ul><h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><ul><li>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</li><li>派生类析构函数：派生类析构函数先执行，然后执行基类的析构函数。</li><li>如果构造函数或析构函数调用了某个虚函数，我们应该执行与构造函数或析构函数所属类型一致的虚函数版本<ul><li>如果基类构造的时候调用了虚函数，则只能使用基类的虚函数，而不能使用派生类的，因为此时派生类版本的虚函数还未定义</li></ul></li></ul><h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><ul><li>C++11新标准中，派生类可以重用其直接基类定义的构造函数。</li><li>如<code>using Disc_quote::Disc_quote;</code>，注明了要继承<code>Disc_quote</code>的构造函数。</li></ul><h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><ul><li>当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式。</li><li>派生类对象直接赋值给基类对象，其中的派生类部分会被切掉。<ul><li>当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此<strong>容器和存在继承关系的类型无法兼容</strong></li></ul></li><li>在容器中放置（智能）指针而非对象。（智能指针是更好的选择）——放置（智能）指针保证多态性</li><li>对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以经常定义一些辅助的类来处理这些复杂的情况。</li></ul><h1 id="第16章-模板和泛型编程"><a href="#第16章-模板和泛型编程" class="headerlink" title="第16章 模板和泛型编程"></a>第16章 模板和泛型编程</h1><ul><li>面向对象编程和泛型编程都能处理在编写程序时不知道类型的情况。<ul><li>OOP能处理类型在程序运行之前都未知的情况；</li><li>泛型编程中，在编译时就可以获知类型。</li></ul></li></ul><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><ul><li><strong>模板</strong>：模板是泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</li></ul><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><ul><li><code>template &lt;typename T&gt; int compare(const T &amp;v1, const T &amp;v2)&#123;&#125;</code></li><li>模板定义以关键字 <code>template</code>开始，后接<strong>模板形参表</strong>，模板形参表是用<strong>尖括号</strong><code>&lt;&gt;</code>括住的一个或多个<strong>模板形参</strong>的列表，用逗号分隔，<strong>不能为空</strong>。</li><li>使用模板时，我们显式或隐式地指定模板实参，将其绑定到模板参数上。</li><li>模板类型参数：类型参数前必须使用关键字<code>class</code>或者<code>typename</code>，这两个关键字含义相同，可以互换使用。旧的程序只能使用<code>class</code>。</li><li>非类型模板参数：表示一个值而非一个类型。实参必须是常量表达式。<code>template &lt;class T, size_t N&gt; void array_init(T (&amp;parm)[N])&#123;&#125;</code></li><li>内联函数模板： <code>template &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);</code></li><li>模板程序应该尽量减少对实参类型的要求。</li><li>函数模板和类模板成员函数的定义通常放在头文件中。</li></ul><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><ul><li><p>类模板用于生成类的蓝图。</p></li><li><p>不同于函数模板，编译器不能推断模板参数类型。</p></li><li><p>定义类模板</p><p>：</p><ul><li><code>template &lt;class Type&gt; class Queue &#123;&#125;;</code></li></ul></li><li><p>实例化类模板：提供显式模板实参列表，来实例化出特定的类。</p><ul><li>一个类模板中所有的实例都形成一个独立的类。</li></ul></li><li><p><strong>模板形参作用域</strong>：模板形参的名字可以在声明为模板形参之后直到模板声明或定义的末尾处使用。</p></li><li><p>类模板的成员函数：</p><ul><li><code>template &lt;typename T&gt; ret-type Blob::member-name(parm-list)</code></li></ul></li><li><p>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</p></li><li><p>新标准允许模板将自己的类型参数成为友元。<code>template &lt;typename T&gt; class Bar&#123;friend T;&#125;;</code>。</p></li><li><p>模板类型别名：因为模板不是一个类型，因此无法定义一个<code>typedef</code>引用一个模板，但是新标准允许我们为类模板定义一个类型别名：<code>template&lt;typename T&gt; using twin = pair&lt;T, T&gt;;</code></p></li></ul><h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><ul><li><p>模板参数与作用域：一个模板参数名的可用范围是在声明之后，至模板声明或定义结束前。</p></li><li><p>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置。</p></li><li><p>当我们希望<strong>通知编译器一个名字表示类型</strong>时，必须使用关键字<code>typename</code>，而不能使用<code>class</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> T::size_type<span class="comment">//以防编译器认为是static成员</span></span><br></pre></td></tr></table></figure></li><li><p>默认模板实参：<code>template &lt;class T = int&gt; class Numbers&#123;&#125;</code></p></li></ul><h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><ul><li>成员模板（member template）：本身是模板的函数成员。<ul><li>普通（非模板）类的成员模板。</li><li>类模板的成员模板。</li></ul></li></ul><h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><ul><li>动机：<strong>在多个文件中实例化相同模板的额外开销可能非常严重。</strong></li><li>显式实例化：<ul><li><code>extern template declaration;  // 实例化声明</code></li><li><code>template declaration;  // 实例化定义</code></li></ul></li></ul><h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><ul><li>能够自动转换类型的只有：<ul><li>和其他函数一样，顶层<code>const</code>会被忽略。</li><li>数组实参或函数实参转换为指针。</li></ul></li><li><code>const</code> 转换：可以将一个非 <code>const</code> 对象的引用（或指针）传递给一个 <code>const</code> 的引用（或指针）形参。</li><li>数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li></ul><h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><ul><li><p>某些情况下，编译器无法推断出模板实参的类型。</p></li><li><p>定义：<code>template &lt;typename T1, typename T2, typename T3&gt; T1 sum(T2, T3);</code></p></li><li><p>使用函数显式实参调用：<code>auto val3 = sum&lt;long long&gt;(i, lng); // T1是显式指定，T2和T3都是从函数实参类型推断而来</code></p></li><li><p><strong>注意</strong>：正常类型转换可以应用于显式指定的实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> j = <span class="number">3.14</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(i, j);<span class="comment">//3</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(i, j);<span class="comment">//3.14</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3><ul><li>使用场景：并不清楚返回结果的准确类型，但知道所需类型是和参数相关的。</li><li><code>template &lt;typename It&gt; auto fcn(It beg, It end) -&gt; decltype(*beg)</code></li><li>尾置返回允许我们在参数列表之后声明返回类型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准库的<strong>类型转换</strong>模板：</p><ul><li>remove_reference&lt;…&gt;脱去引用</li></ul><ul><li>定义在头文件<code>type_traits</code>中。</li></ul><table><thead><tr><th>对<code>Mod&lt;T&gt;</code>，其中<code>Mod</code>是：</th><th>若<code>T</code>是：</th><th>则<code>Mod&lt;T&gt;::type</code>是：</th></tr></thead><tbody><tr><td><code>remove_reference</code></td><td><code>X&amp;</code>或<code>X&amp;&amp;</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>add_const</code></td><td><code>X&amp;</code>或<code>const X</code>或函数</td><td><code>T</code></td></tr><tr><td></td><td>否则</td><td><code>const T</code></td></tr><tr><td><code>add_lvalue_reference</code></td><td><code>X&amp;</code></td><td><code>T</code></td></tr><tr><td></td><td><code>X&amp;&amp;</code></td><td><code>X&amp;</code></td></tr><tr><td></td><td>否则</td><td><code>T&amp;</code></td></tr><tr><td><code>add_rvalue_reference</code></td><td><code>X&amp;</code>或<code>X&amp;&amp;</code></td><td><code>T</code></td></tr><tr><td></td><td>否则</td><td><code>T&amp;&amp;</code></td></tr><tr><td><code>remove_pointer</code></td><td><code>X*</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>add_pointer</code></td><td><code>X&amp;</code>或<code>X&amp;&amp;</code></td><td><code>X*</code></td></tr><tr><td></td><td>否则</td><td><code>T*</code></td></tr><tr><td><code>make_signed</code></td><td><code>unsigned X</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>make_unsigned</code></td><td>带符号类型</td><td><code>unsigned X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>remove_extent</code></td><td><code>X[n]</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>remove_all_extents</code></td><td><code>X[n1][n2]...</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr></tbody></table><p>​</p><h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><ul><li>当使用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;) = compare;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>(*) (<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>(*) (<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="built_in">func</span>(compare);<span class="comment">//错误：不知道使用哪个</span></span><br><span class="line"><span class="built_in">func</span>(compare&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure><h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><ul><li><p>从左值引用函数推断类型：若形如<code>T&amp;</code>，则只能传递给它一个左值。但如果是<code>const T&amp;</code>，则可以接受一个右值。</p></li><li><p>从右值引用函数推断类型：若形如<code>T&amp;&amp;</code>，则只能传递给它一个右值。</p></li><li><p>引用折叠和右值引用参数：</p><ul><li><p>规则1：当我们将一个左值传递给函数的右值引用参数，且右值引用指向模板类型参数时（如<code>T&amp;&amp;</code>），编译器会推断模板类型参数为实参的左值引用类型。</p></li><li><p>规则2：如果我们间接创造一个引用的引用，则这些引用形成了</p><p>折叠</p><p>。折叠引用只能应用在间接创造的引用的引用，如类型别名或模板参数。对于一个给定类型<code>x</code>:</p><ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>和<code>X&amp;&amp; &amp;</code>都折叠成类型<code>X&amp;</code>。</li><li>类型<code>X&amp;&amp; &amp;&amp;</code>折叠成<code>X&amp;&amp;</code>。</li></ul></li><li><p>上面两个例外规则导致两个重要结果： </p><ul><li>1.如果一个函数参数是一个指向模板类型参数的右值引用（如<code>T&amp;&amp;</code>），则它可以被绑定到一个左值上；</li><li>2.如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个左值引用参数（<code>T&amp;</code>）。</li></ul></li></ul></li></ul><h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><ul><li>标准库<code>move</code>函数是使用右值引用的模板的一个很好的例子。</li><li>从一个左值<code>static_cast</code>到一个右值引用是允许的。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><ul><li><p>使用一个名为<code>forward</code>的新标准库设施来传递参数，它能够保持<strong>原始实参的类型</strong>。（如果是右值，让其保持右值，如果是左值，让其保持左值）</p></li><li><p>定义在头文件<code>utility</code>中。</p></li><li><p>与move不同<strong>必须通过显式模板实参</strong>来调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::forward&lt;Type&gt;(arg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="built_in">intermediary</span>(Type &amp;&amp;arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">finalFcn</span>(std::forward&lt;Type&gt;(arg));</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>std::forward&lt;Type&gt;返回的是右值引用</p><ul><li>如果实参是一个右值，则Type是一个普通（非引用）类型，forward&lt;Type&gt;将返回Type&amp;&amp;（<strong>右值引用</strong>）</li><li>如果实参是一个左值，则通过<strong>引用折叠</strong>，Type本身是一个左值引用类型，返回类型是一个指向左值引用类型的<strong>右值引用</strong></li></ul></li></ul><ul><li>与std::move相同，对std::forward不适用using声明是一个好主意。</li></ul><h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><ul><li>多个可行模板：当有多个重载模板对一个调用提供同样好的匹配时，会选择最特例化的版本。</li><li>非模板和模板重载：对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。</li></ul><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p><strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类。</p><ul><li>可变数目的参数被称为参数包。<ul><li>模板参数包：标识另个或多个模板参数。</li><li>函数参数包：标识另个或者多个函数参数。</li></ul></li><li>用一个省略号来指出一个模板参数或函数参数，表示一个包。</li><li><code>template &lt;typename T, typename... Args&gt;</code>，<code>Args</code>第一个模板参数包。</li><li><code>void foo(const T &amp;t, const Args&amp; ... rest);</code>，<code>rest</code>是一个函数参数包。</li><li><code>sizeof...</code>运算符，返回参数的数目。</li></ul><h3 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h3><ul><li>可变参数函数通常是递归的：第一步调用处理包中的第一个实参，然后用剩余实参调用自身。</li></ul><h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><ul><li>对于一个参数包，除了获取它的大小，唯一能做的事情就是<strong>扩展</strong>（expand）。</li><li>扩展一个包时，还要提供用于每个扩展元素的<strong>模式</strong>（pattern）。</li></ul><h3 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h3><ul><li>新标准下可以组合使用可变参数模板和<code>forward</code>机制，实现将实参不变地传递给其他函数。</li></ul><h4 id="转发和可变参数模板"><a href="#转发和可变参数模板" class="headerlink" title="转发和可变参数模板"></a>转发和可变参数模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Args&amp;&amp;... args)</span></span>&#123;</span><br><span class="line"><span class="comment">// work的实参及拓展Args有拓展args</span></span><br><span class="line"><span class="built_in">work</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板特例化（Specializations）"><a href="#模板特例化（Specializations）" class="headerlink" title="模板特例化（Specializations）"></a>模板特例化（Specializations）</h2><ul><li>定义函数模板特例化：关键字<code>template</code>后面跟一个空尖括号对（<code>&lt;&gt;</code>）。</li><li>特例化的本质是实例化一个模板，而不是重载它。特例化不影响函数匹配。</li><li>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是特例化版本。<ul><li>编译器不会检测到模板特例化的丢失</li></ul></li><li>类模板特例化（hash&lt;Sales_data&gt;）<ul><li>给hash特例化Sales_data类型——p627</li></ul></li><li>我们可以部分特例化类模板，但不能部分特例化函数模板。</li></ul><h2 id="move和forward"><a href="#move和forward" class="headerlink" title="move和forward"></a>move和forward</h2><p><a href="https://wendeng.github.io/2019/05/14/c++%E5%9F%BA%E7%A1%80/c++11move%E5%92%8Cforword/">c++11特性之move和forward应用与区别</a></p><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux笔记</title>
      <link href="/2023/07/25/Linux%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/25/Linux%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><p><strong>在Linux世界里，一切皆文件</strong></p><img src="LINUX.assets/image-20230310164516872.png" alt="image-20230310164516872" style="zoom:200%;" /><img src="LINUX.assets/image-20230310162737815.png" alt="image-20230310162737815"  /><img src="LINUX.assets/image-20230310163105171.png" alt="image-20230310163105171"  /><p><img src="/LINUX.assets/image-20230310163541388.png" alt="image-20230310163541388"></p><p><img src="/LINUX.assets/image-20230310164222893.png" alt="image-20230310164222893"></p><h1 id="远程登陆Linux"><a href="#远程登陆Linux" class="headerlink" title="远程登陆Linux"></a>远程登陆Linux</h1><h2 id="Xshell"><a href="#Xshell" class="headerlink" title="Xshell"></a>Xshell</h2><blockquote><p>只能对远程Linux系统进行命令的操作</p></blockquote><p><img src="/LINUX.assets/image-20230310165658949.png" alt="image-20230310165658949"></p><p><img src="/LINUX.assets/image-20230310165754894.png" alt="image-20230310165754894"></p><h2 id="Xftp"><a href="#Xftp" class="headerlink" title="Xftp"></a>Xftp</h2><p><img src="/LINUX.assets/image-20230310172626067.png" alt="image-20230310172626067"></p><p><img src="/LINUX.assets/image-20230310172822256.png" alt="image-20230310172822256"></p><h1 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h1><p><img src="/LINUX.assets/image-20230311000018587.png" alt="image-20230311000018587"></p><h1 id="关机-重启命令"><a href="#关机-重启命令" class="headerlink" title="关机&amp;重启命令"></a>关机&amp;重启命令</h1><ul><li>shutdown</li></ul><p><img src="/LINUX.assets/image-20230311220618530.png" alt="image-20230311220618530"></p><h1 id="登陆注销"><a href="#登陆注销" class="headerlink" title="登陆注销"></a>登陆注销</h1><p><img src="/LINUX.assets/image-20230311221326848.png" alt="image-20230311221326848"></p><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p><img src="/LINUX.assets/image-20230311221816487.png" alt="image-20230311221816487"></p><h2 id="指定-修改密码"><a href="#指定-修改密码" class="headerlink" title="指定&#x2F;修改密码"></a>指定&#x2F;修改密码</h2><p><img src="/LINUX.assets/image-20230311222854469.png" alt="image-20230311222854469"></p><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p><img src="/LINUX.assets/image-20230311222902572.png" alt="image-20230311222902572"></p><h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><p><img src="/LINUX.assets/image-20230311223245004.png" alt="image-20230311223245004"></p><h2 id="查看当前用户-登录用户"><a href="#查看当前用户-登录用户" class="headerlink" title="查看当前用户&#x2F;登录用户"></a>查看当前用户&#x2F;登录用户</h2><ul><li>显示初始登陆用户</li></ul><p><img src="/LINUX.assets/image-20230311223458211.png" alt="image-20230311223458211"></p><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p><img src="/LINUX.assets/image-20230311224749847.png" alt="image-20230311224749847"></p><p><img src="/LINUX.assets/image-20230311224725931.png" alt="image-20230311224725931"></p><h2 id="id-usr"><a href="#id-usr" class="headerlink" title="id usr"></a>id usr</h2><ul><li>查看当前用户所在组</li></ul><h2 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h2><p><img src="/LINUX.assets/image-20230311230143587.png" alt="image-20230311230143587"></p><h1 id="Linux实用指令"><a href="#Linux实用指令" class="headerlink" title="Linux实用指令"></a>Linux实用指令</h1><ul><li>… &amp; &#x2F;&#x2F;让…后台运行</li></ul><h2 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h2><p><img src="/LINUX.assets/image-20230315203710153.png" alt="image-20230315203710153"></p><ul><li>systemctl get-default</li><li>systemctl set-default</li></ul><p><img src="/LINUX.assets/image-20230315203738693.png" alt="image-20230315203738693"></p><h2 id="root找回密码"><a href="#root找回密码" class="headerlink" title="root找回密码"></a>root找回密码</h2><h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><p><img src="/LINUX.assets/image-20230315205223514.png" alt="image-20230315205223514"></p><h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><h3 id="pwd，ls"><a href="#pwd，ls" class="headerlink" title="pwd，ls"></a>pwd，ls</h3><p><img src="/LINUX.assets/image-20230315205536917.png" alt="image-20230315205536917"></p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p><img src="/LINUX.assets/image-20230315205902443.png" alt="image-20230315205902443"></p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p><img src="/LINUX.assets/image-20230315210940899.png" alt="image-20230315210940899"></p><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p><img src="/LINUX.assets/image-20230315211414549.png" alt="image-20230315211414549"></p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p><img src="/LINUX.assets/image-20230315211439440.png" alt="image-20230315211439440"></p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p><img src="/LINUX.assets/image-20230315212145919.png" alt="image-20230315212145919"></p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p><img src="/LINUX.assets/image-20230315212413193.png" alt="image-20230315212413193"></p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p><img src="/LINUX.assets/image-20230315213158566.png" alt="image-20230315213158566">           </p><h3 id="cat与more（浏览）"><a href="#cat与more（浏览）" class="headerlink" title="cat与more（浏览）"></a>cat与more（浏览）</h3><p><img src="/LINUX.assets/image-20230315213747884.png" alt="image-20230315213747884"></p><p><img src="/LINUX.assets/image-20230315213806749.png" alt="image-20230315213806749"></p><h3 id="less（浏览）"><a href="#less（浏览）" class="headerlink" title="less（浏览）"></a>less（浏览）</h3><p><img src="/LINUX.assets/image-20230315214853428.png" alt="image-20230315214853428"></p><h3 id="echo，head，tail"><a href="#echo，head，tail" class="headerlink" title="echo，head，tail"></a>echo，head，tail</h3><p><img src="/LINUX.assets/image-20230315215939933.png" alt="image-20230315215939933"></p><p><img src="/LINUX.assets/image-20230315220049916.png" alt="image-20230315220049916"></p><ul><li><strong>ctrl+c退出监控</strong></li></ul><h3 id=""><a href="#" class="headerlink" title="&gt;,&gt;&gt;"></a>&gt;,&gt;&gt;</h3><p><img src="/LINUX.assets/image-20230315220728589.png" alt="image-20230315220728589"></p><h3 id="ln-软连接"><a href="#ln-软连接" class="headerlink" title="ln(软连接)"></a>ln(软连接)</h3><p><img src="/LINUX.assets/image-20230315222626325.png" alt="image-20230315222626325"></p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p><img src="/LINUX.assets/image-20230315222826295.png" alt="image-20230315222826295"></p><h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p><img src="/LINUX.assets/image-20230323212132767.png" alt="image-20230323212132767"></p><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p><img src="/LINUX.assets/image-20230323212317968.png" alt="image-20230323212317968"></p><h2 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><img src="/LINUX.assets/image-20230323213140432.png" alt="image-20230323213140432"></p><h3 id="locate-、which"><a href="#locate-、which" class="headerlink" title="locate 、which"></a>locate 、which</h3><p><img src="/LINUX.assets/image-20230323213436089.png" alt="image-20230323213436089"></p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><img src="/LINUX.assets/image-20230323213846296.png" alt="image-20230323213846296"></p><ul><li>grep -v<ul><li>反向匹配</li></ul></li></ul><h2 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h2><h3 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip gunzip"></a>gzip gunzip</h3><p><img src="/LINUX.assets/image-20230328162620713.png" alt="image-20230328162620713"></p><h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip unzip"></a>zip unzip</h3><p><img src="/LINUX.assets/image-20230328163308333.png" alt="image-20230328163308333"></p><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p><img src="/LINUX.assets/image-20230328165232447.png" alt="image-20230328165232447"></p><h1 id="Linux组管理和权限管理"><a href="#Linux组管理和权限管理" class="headerlink" title="Linux组管理和权限管理"></a>Linux组管理和权限管理</h1><h2 id="Linux组基本介绍"><a href="#Linux组基本介绍" class="headerlink" title="Linux组基本介绍"></a>Linux组基本介绍</h2><p><img src="/LINUX.assets/image-20230328171925798.png" alt="image-20230328171925798"></p><h2 id="文件-目录所有者"><a href="#文件-目录所有者" class="headerlink" title="文件&#x2F;目录所有者"></a>文件&#x2F;目录所有者</h2><p><img src="/LINUX.assets/image-20230328172640235.png" alt="image-20230328172640235"></p><p><img src="/LINUX.assets/image-20230328201432439.png" alt="image-20230328201432439"></p><h2 id="文件-目录所在组"><a href="#文件-目录所在组" class="headerlink" title="文件&#x2F;目录所在组"></a>文件&#x2F;目录所在组</h2><p><img src="/LINUX.assets/image-20230328173922986.png" alt="image-20230328173922986"></p><p><img src="/LINUX.assets/image-20230328201714927.png" alt="image-20230328201714927"></p><h2 id="其他组"><a href="#其他组" class="headerlink" title="其他组"></a>其他组</h2><p><img src="/LINUX.assets/image-20230328174300172.png" alt="image-20230328174300172"></p><h2 id="权限基本介绍"><a href="#权限基本介绍" class="headerlink" title="权限基本介绍"></a>权限基本介绍</h2><p><img src="/LINUX.assets/image-20230328194457408.png" alt="image-20230328194457408"></p><h2 id="rwx详解"><a href="#rwx详解" class="headerlink" title="rwx详解"></a>rwx详解</h2><p><img src="/LINUX.assets/image-20230328195014055.png" alt="image-20230328195014055"></p><p><img src="/LINUX.assets/image-20230328195728018.png" alt="image-20230328195728018"></p><h2 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限-chmod"></a>修改权限-chmod</h2><h3 id="第一种方式：-变更权限"><a href="#第一种方式：-变更权限" class="headerlink" title="第一种方式：+ - &#x3D;变更权限"></a>第一种方式：+ - &#x3D;变更权限</h3><p><img src="/LINUX.assets/image-20230328200308556.png" alt="image-20230328200308556"></p><h3 id="第二种方式：通过数字变更权限"><a href="#第二种方式：通过数字变更权限" class="headerlink" title="第二种方式：通过数字变更权限"></a>第二种方式：通过数字变更权限</h3><p><img src="/LINUX.assets/image-20230328200524274.png" alt="image-20230328200524274"></p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><img src="/LINUX.assets/image-20230328204921051.png" alt="image-20230328204921051"></p><h1 id="Linux定时任务调度"><a href="#Linux定时任务调度" class="headerlink" title="Linux定时任务调度"></a>Linux定时任务调度</h1><h2 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h2><h3 id="e-l-r"><a href="#e-l-r" class="headerlink" title="-e -l -r"></a>-e -l -r</h3><ul><li>crontab</li></ul><p><img src="/LINUX.assets/image-20230329121325624.png" alt="image-20230329121325624"></p><h3 id="占位参数"><a href="#占位参数" class="headerlink" title="占位参数"></a>占位参数</h3><p><img src="/LINUX.assets/image-20230329121310020.png" alt="image-20230329121310020"></p><h3 id="特殊符号说明"><a href="#特殊符号说明" class="headerlink" title="特殊符号说明"></a>特殊符号说明</h3><p><img src="/LINUX.assets/image-20230329121611400.png" alt="image-20230329121611400"></p><h3 id="特殊时间执行案列"><a href="#特殊时间执行案列" class="headerlink" title="特殊时间执行案列"></a>特殊时间执行案列</h3><p><img src="/LINUX.assets/image-20230329121758235.png" alt="image-20230329121758235"></p><h3 id="crond应用案例与相关指令"><a href="#crond应用案例与相关指令" class="headerlink" title="crond应用案例与相关指令"></a>crond应用案例与相关指令</h3><p><img src="/LINUX.assets/image-20230329123514406.png" alt="image-20230329123514406"></p><h2 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><h4 id="ps-ef-与-命令格式"><a href="#ps-ef-与-命令格式" class="headerlink" title="ps -ef 与 命令格式"></a>ps -ef 与 命令格式</h4><p><img src="/LINUX.assets/image-20230329124131561.png" alt="image-20230329124131561"></p><h3 id="at命令选项"><a href="#at命令选项" class="headerlink" title="at命令选项"></a>at命令选项</h3><p><img src="/LINUX.assets/image-20230329124243524.png" alt="image-20230329124243524"></p><h3 id="at时间定义"><a href="#at时间定义" class="headerlink" title="at时间定义"></a>at时间定义</h3><p><img src="/LINUX.assets/image-20230329124500458.png" alt="image-20230329124500458"></p><h3 id="at定时任务-案列"><a href="#at定时任务-案列" class="headerlink" title="at定时任务-案列"></a>at定时任务-案列</h3><p><img src="/LINUX.assets/image-20230329125638184.png" alt="image-20230329125638184"></p><h1 id="Linux磁盘分区、挂载"><a href="#Linux磁盘分区、挂载" class="headerlink" title="Linux磁盘分区、挂载"></a>Linux磁盘分区、挂载</h1><h2 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p><img src="/LINUX.assets/image-20230329144617864.png" alt="image-20230329144617864"></p><h3 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a>硬盘说明</h3><p><img src="/LINUX.assets/image-20230329145025644.png" alt="image-20230329145025644">     </p><h3 id="查看所有设备挂载情况"><a href="#查看所有设备挂载情况" class="headerlink" title="查看所有设备挂载情况"></a>查看所有设备挂载情况</h3><ul><li>lsblk</li><li>lsblk -f</li></ul><p><img src="/LINUX.assets/image-20230329145315985.png" alt="image-20230329145315985"></p><h2 id="挂载经典案列"><a href="#挂载经典案列" class="headerlink" title="挂载经典案列"></a>挂载经典案列</h2><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p><img src="/LINUX.assets/image-20230329151326131.png" alt="image-20230329151326131"></p><h3 id="步骤2-fdisk-dev-sdb"><a href="#步骤2-fdisk-dev-sdb" class="headerlink" title="步骤2-fdisk &#x2F;dev&#x2F;sdb"></a>步骤2-fdisk &#x2F;dev&#x2F;sdb</h3><p><img src="/LINUX.assets/image-20230329151549171.png" alt="image-20230329151549171"></p><h3 id="步骤3-mkfs-t-ext4-dev-sdb1"><a href="#步骤3-mkfs-t-ext4-dev-sdb1" class="headerlink" title="步骤3-mkfs -t ext4 &#x2F;dev&#x2F;sdb1"></a>步骤3-mkfs -t ext4 &#x2F;dev&#x2F;sdb1</h3><p><img src="/LINUX.assets/image-20230329151717218.png" alt="image-20230329151717218"></p><h3 id="步骤4-mount-dev-sdb1-newdisk"><a href="#步骤4-mount-dev-sdb1-newdisk" class="headerlink" title="步骤4-mount &#x2F;dev&#x2F;sdb1 &#x2F;newdisk"></a>步骤4-mount &#x2F;dev&#x2F;sdb1 &#x2F;newdisk</h3><p><img src="/LINUX.assets/image-20230329151724895.png" alt="image-20230329151724895"></p><h3 id="步骤5-vim-etc-fstab"><a href="#步骤5-vim-etc-fstab" class="headerlink" title="步骤5- vim &#x2F;etc&#x2F;fstab"></a>步骤5- vim &#x2F;etc&#x2F;fstab</h3><ul><li>永久挂载</li></ul><p><img src="/LINUX.assets/image-20230329151830181.png" alt="image-20230329151830181"></p><h2 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h2><h3 id="查询系统整体磁盘占用情况–df-h"><a href="#查询系统整体磁盘占用情况–df-h" class="headerlink" title="查询系统整体磁盘占用情况–df -h"></a>查询系统整体磁盘占用情况–df -h</h3><p><img src="/LINUX.assets/image-20230329153536405.png" alt="image-20230329153536405"></p><h3 id="查询指定目录的磁盘占用情况-du-选项"><a href="#查询指定目录的磁盘占用情况-du-选项" class="headerlink" title="查询指定目录的磁盘占用情况-du -[选项]"></a>查询指定目录的磁盘占用情况-du -[选项]</h3><p><img src="/LINUX.assets/image-20230329153411036.png" alt="image-20230329153411036"></p><h2 id="磁盘工作实用指令"><a href="#磁盘工作实用指令" class="headerlink" title="磁盘工作实用指令"></a>磁盘工作实用指令</h2><p><img src="/LINUX.assets/image-20230329154540599.png" alt="image-20230329154540599"></p><h1 id="Linux网络配置"><a href="#Linux网络配置" class="headerlink" title="Linux网络配置"></a>Linux网络配置</h1><h2 id="Linux网络配置原理图"><a href="#Linux网络配置原理图" class="headerlink" title="Linux网络配置原理图"></a>Linux网络配置原理图</h2><p><img src="/LINUX.assets/image-20230329161752755.png" alt="image-20230329161752755"></p><h2 id="查看网络IP和网关"><a href="#查看网络IP和网关" class="headerlink" title="查看网络IP和网关"></a>查看网络IP和网关</h2><h3 id="查看虚拟网络编辑器和修改IP地址"><a href="#查看虚拟网络编辑器和修改IP地址" class="headerlink" title="查看虚拟网络编辑器和修改IP地址"></a>查看虚拟网络编辑器和修改IP地址</h3><p><img src="/LINUX.assets/image-20230329173758202.png" alt="image-20230329173758202"></p><h3 id="查看网关"><a href="#查看网关" class="headerlink" title="查看网关"></a>查看网关</h3><p><img src="/LINUX.assets/image-20230329173831126.png" alt="image-20230329173831126"></p><h3 id="在Windows和Linux查看网络配置"><a href="#在Windows和Linux查看网络配置" class="headerlink" title="在Windows和Linux查看网络配置"></a>在Windows和Linux查看网络配置</h3><p><img src="/LINUX.assets/image-20230329170156104.png" alt="image-20230329170156104"></p><h3 id="ping测试主机之间的网络连通性"><a href="#ping测试主机之间的网络连通性" class="headerlink" title="ping测试主机之间的网络连通性"></a>ping测试主机之间的网络连通性</h3><p><img src="/LINUX.assets/image-20230329170239913.png" alt="image-20230329170239913"></p><h2 id="Linux网络环境配置"><a href="#Linux网络环境配置" class="headerlink" title="Linux网络环境配置"></a>Linux网络环境配置</h2><h3 id="第一种方法（自动获取）"><a href="#第一种方法（自动获取）" class="headerlink" title="第一种方法（自动获取）"></a>第一种方法（自动获取）</h3><p><img src="/LINUX.assets/image-20230329170403946.png" alt="image-20230329170403946"></p><h3 id="第二种方法（指定ip）"><a href="#第二种方法（指定ip）" class="headerlink" title="第二种方法（指定ip）"></a>第二种方法（指定ip）</h3><p><img src="/LINUX.assets/image-20230329171348271.png" alt="image-20230329171348271"></p><p><img src="/LINUX.assets/image-20230329171444815.png" alt="image-20230329171444815"></p><h2 id="设置主机名和hosts映射"><a href="#设置主机名和hosts映射" class="headerlink" title="设置主机名和hosts映射"></a>设置主机名和hosts映射</h2><h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><p><img src="/LINUX.assets/image-20230329172430499.png" alt="image-20230329172430499"></p><h3 id="设置hosts映射"><a href="#设置hosts映射" class="headerlink" title="设置hosts映射"></a>设置hosts映射</h3><p><img src="/LINUX.assets/image-20230329172503371.png" alt="image-20230329172503371"></p><h3 id="主机名解析机制分析（Hosts、DNS）"><a href="#主机名解析机制分析（Hosts、DNS）" class="headerlink" title="主机名解析机制分析（Hosts、DNS）"></a>主机名解析机制分析（Hosts、DNS）</h3><p><img src="/LINUX.assets/image-20230329173331587.png" alt="image-20230329173331587"></p><h1 id="Linux进程管理"><a href="#Linux进程管理" class="headerlink" title="Linux进程管理"></a>Linux进程管理</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><img src="/LINUX.assets/image-20230330154205288.png" alt="image-20230330154205288"></p><h2 id="显示系统执行的进程-ps"><a href="#显示系统执行的进程-ps" class="headerlink" title="显示系统执行的进程-ps"></a>显示系统执行的进程-ps</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><img src="/LINUX.assets/image-20230330154829193.png" alt="image-20230330154829193"></p><h3 id="ps详解"><a href="#ps详解" class="headerlink" title="ps详解"></a>ps详解</h3><p><img src="/LINUX.assets/image-20230330155124202.png" alt="image-20230330155124202"></p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p><img src="/LINUX.assets/image-20230330155907573.png" alt="image-20230330155907573"></p><h3 id="查看进程树-pstree"><a href="#查看进程树-pstree" class="headerlink" title="查看进程树-pstree"></a>查看进程树-pstree</h3><p><img src="/LINUX.assets/image-20230330161813263.png" alt="image-20230330161813263"></p><h2 id="终止进程-kill-killall"><a href="#终止进程-kill-killall" class="headerlink" title="终止进程-kill killall"></a>终止进程-kill killall</h2><p><img src="/LINUX.assets/image-20230330161434706.png" alt="image-20230330161434706"></p><h2 id="Linux服务管理"><a href="#Linux服务管理" class="headerlink" title="Linux服务管理"></a>Linux服务管理</h2><h3 id="介绍-service-守护进程"><a href="#介绍-service-守护进程" class="headerlink" title="介绍-service-守护进程"></a>介绍-service-守护进程</h3><p><img src="/LINUX.assets/image-20230330163255066.png" alt="image-20230330163255066"></p><h3 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h3><p><img src="/LINUX.assets/image-20230330163322904.png" alt="image-20230330163322904"></p><h3 id="服务的运行级别"><a href="#服务的运行级别" class="headerlink" title="服务的运行级别"></a>服务的运行级别</h3><p><img src="/LINUX.assets/image-20230330163524958.png" alt="image-20230330163524958"></p><ul><li>systemctl get-default</li><li>systemctl set-default</li></ul><p><img src="/LINUX.assets/image-20230330164042142.png" alt="image-20230330164042142"></p><h3 id="chkconfig-服务在各个运行级别的开-关"><a href="#chkconfig-服务在各个运行级别的开-关" class="headerlink" title="chkconfig-服务在各个运行级别的开&#x2F;关"></a>chkconfig-服务在各个运行级别的开&#x2F;关</h3><p><img src="/LINUX.assets/image-20230330164459661.png" alt="image-20230330164459661"></p><h3 id="systemctl管理指令"><a href="#systemctl管理指令" class="headerlink" title="systemctl管理指令"></a>systemctl管理指令</h3><p><img src="/LINUX.assets/image-20230330170708760.png" alt="image-20230330170708760"></p><h3 id="打开或关闭指定端口-firewall"><a href="#打开或关闭指定端口-firewall" class="headerlink" title="打开或关闭指定端口-firewall"></a>打开或关闭指定端口-firewall</h3><p><img src="/LINUX.assets/image-20230330171658194.png" alt="image-20230330171658194"></p><h2 id="动态监控进程-top"><a href="#动态监控进程-top" class="headerlink" title="动态监控进程-top"></a>动态监控进程-top</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/LINUX.assets/image-20230330172845829.png" alt="image-20230330172845829"></p><h3 id="top交互操作说明"><a href="#top交互操作说明" class="headerlink" title="top交互操作说明"></a>top交互操作说明</h3><p><img src="/LINUX.assets/image-20230330173643205.png" alt="image-20230330173643205"></p><h2 id="监控网络状态-netstat-ping"><a href="#监控网络状态-netstat-ping" class="headerlink" title="监控网络状态-netstat -ping"></a>监控网络状态-netstat -ping</h2><p><img src="/LINUX.assets/image-20230330175340004.png" alt="image-20230330175340004"></p><h1 id="Linux-RPM-与-YUM"><a href="#Linux-RPM-与-YUM" class="headerlink" title="Linux RPM 与 YUM"></a>Linux RPM 与 YUM</h1><h2 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h2><h3 id="简单查询指令"><a href="#简单查询指令" class="headerlink" title="简单查询指令"></a>简单查询指令</h3><p><img src="/LINUX.assets/image-20230330191327530.png" alt="image-20230330191327530"></p><h3 id="其他查询指令"><a href="#其他查询指令" class="headerlink" title="其他查询指令"></a>其他查询指令</h3><p><img src="/LINUX.assets/image-20230330191825775.png" alt="image-20230330191825775"></p><h3 id="卸载-rpm-e-RPM包名"><a href="#卸载-rpm-e-RPM包名" class="headerlink" title="&#x3D;&#x3D;卸载&#x3D;&#x3D;-rpm -e RPM包名"></a>&#x3D;&#x3D;卸载&#x3D;&#x3D;-rpm -e RPM包名</h3><p><img src="/LINUX.assets/image-20230330192841450.png" alt="image-20230330192841450"></p><h3 id="安装-rpm-ivh-RPM包全路径名"><a href="#安装-rpm-ivh-RPM包全路径名" class="headerlink" title="&#x3D;&#x3D;安装&#x3D;&#x3D;-rpm -ivh RPM包全路径名"></a>&#x3D;&#x3D;安装&#x3D;&#x3D;-rpm -ivh RPM包全路径名</h3><p><img src="/LINUX.assets/image-20230330192932130.png" alt="image-20230330192932130"></p><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p><img src="/LINUX.assets/image-20230330194014268.png" alt="image-20230330194014268"></p><h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><h2 id="shell是什么"><a href="#shell是什么" class="headerlink" title="shell是什么"></a>shell是什么</h2><p><img src="/LINUX.assets/image-20230330194556985.png" alt="image-20230330194556985"></p><h2 id="shell脚本的执行方式"><a href="#shell脚本的执行方式" class="headerlink" title="shell脚本的执行方式"></a>shell脚本的执行方式</h2><ul><li>shell脚本格式要求</li></ul><p><img src="/LINUX.assets/image-20230330195032460.png" alt="image-20230330195032460"></p><h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><h3 id="介绍与定义"><a href="#介绍与定义" class="headerlink" title="介绍与定义"></a>介绍与定义</h3><p><img src="/LINUX.assets/image-20230410210221182.png" alt="image-20230410210221182"></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p><img src="/LINUX.assets/image-20230410210513608.png" alt="image-20230410210513608"></p><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p><img src="/LINUX.assets/image-20230410211546265.png" alt="image-20230410211546265"></p><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p><img src="/LINUX.assets/image-20230410211907092.png" alt="image-20230410211907092"></p><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p><img src="/LINUX.assets/image-20230410212507532.png" alt="image-20230410212507532"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><img src="/LINUX.assets/image-20230410213557018.png" alt="image-20230410213557018"></p><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><p><img src="/LINUX.assets/image-20230410214827923.png" alt="image-20230410214827923"></p><h3 id="常用判断条件"><a href="#常用判断条件" class="headerlink" title="常用判断条件"></a>常用判断条件</h3><p><img src="/LINUX.assets/image-20230410214909344.png" alt="image-20230410214909344"></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p><img src="/LINUX.assets/image-20230410214841454.png" alt="image-20230410214841454"></p><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><p><img src="/LINUX.assets/image-20230410215456418.png" alt="image-20230410215456418"></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><img src="/LINUX.assets/image-20230410220211905.png" alt="image-20230410220211905"></p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><img src="/LINUX.assets/image-20230410221354001.png" alt="image-20230410221354001"></p><h2 id="read获取输入"><a href="#read获取输入" class="headerlink" title="read获取输入"></a>read获取输入</h2><p><img src="/LINUX.assets/image-20230410221640166.png" alt="image-20230410221640166"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><p><img src="/LINUX.assets/image-20230410222042907.png" alt="image-20230410222042907"> </p><p><img src="/LINUX.assets/image-20230410222221659.png" alt="image-20230410222221659"></p><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p><img src="/LINUX.assets/image-20230410223040188.png" alt="image-20230410223040188"></p><h2 id="shell编程综合案例"><a href="#shell编程综合案例" class="headerlink" title="shell编程综合案例"></a>shell编程综合案例</h2><p><img src="/LINUX.assets/image-20230410224350616.png" alt="image-20230410224350616"></p><p><img src="/LINUX.assets/image-20230410231505337.png" alt="image-20230410231505337"></p><h1 id="Linux日志管理"><a href="#Linux日志管理" class="headerlink" title="Linux日志管理"></a>Linux日志管理</h1><h2 id="日志介绍和实例"><a href="#日志介绍和实例" class="headerlink" title="日志介绍和实例"></a>日志介绍和实例</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><img src="/LINUX.assets/image-20230411204648948.png" alt="image-20230411204648948"></p><h3 id="系统常用日志"><a href="#系统常用日志" class="headerlink" title="系统常用日志"></a>系统常用日志</h3><p><img src="/LINUX.assets/image-20230411205953350.png" alt="image-20230411205953350"></p><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p><img src="/LINUX.assets/image-20230411210400211.png" alt="image-20230411210400211"></p><h2 id="日志管理服务rsyslogd"><a href="#日志管理服务rsyslogd" class="headerlink" title="日志管理服务rsyslogd"></a>日志管理服务rsyslogd</h2><h3 id="日志服务原理图"><a href="#日志服务原理图" class="headerlink" title="日志服务原理图"></a>日志服务原理图</h3><p><img src="/LINUX.assets/image-20230411210759638.png" alt="image-20230411210759638"></p><h3 id="配置文件及格式"><a href="#配置文件及格式" class="headerlink" title="配置文件及格式"></a>配置文件及格式</h3><p><img src="/LINUX.assets/image-20230411211954910.png" alt="image-20230411211954910"></p><p><img src="/LINUX.assets/image-20230411212012926.png" alt="image-20230411212012926"></p><h3 id="日志文件格式"><a href="#日志文件格式" class="headerlink" title="日志文件格式"></a>日志文件格式</h3><p><img src="/LINUX.assets/image-20230411211857242.png" alt="image-20230411211857242"></p><h3 id="自定义日志服务"><a href="#自定义日志服务" class="headerlink" title="自定义日志服务"></a>自定义日志服务</h3><p><img src="/LINUX.assets/image-20230411212445573.png" alt="image-20230411212445573"></p><p><img src="/LINUX.assets/image-20230411221435054.png" alt="image-20230411221435054"></p><h2 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/LINUX.assets/image-20230411220125275.png" alt="image-20230411220125275"></p><h3 id="logrotate配置文件"><a href="#logrotate配置文件" class="headerlink" title="logrotate配置文件"></a>logrotate配置文件</h3><p><img src="/LINUX.assets/image-20230411220417213.png" alt="image-20230411220417213"></p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p><img src="/LINUX.assets/image-20230411220637134.png" alt="image-20230411220637134"></p><h3 id="自定义日志轮替"><a href="#自定义日志轮替" class="headerlink" title="自定义日志轮替"></a>自定义日志轮替</h3><p><img src="/LINUX.assets/image-20230411220830598.png" alt="image-20230411220830598"></p><img src="LINUX.assets/image-20230411221110084.png" alt="image-20230411221110084" style="zoom: 80%;" /><h3 id="日志轮替机制原理"><a href="#日志轮替机制原理" class="headerlink" title="日志轮替机制原理"></a>日志轮替机制原理</h3><p><img src="/LINUX.assets/image-20230411221622266.png" alt="image-20230411221622266"></p><h2 id="查看内存日志"><a href="#查看内存日志" class="headerlink" title="查看内存日志"></a>查看内存日志</h2><p><img src="/LINUX.assets/image-20230411222204722.png" alt="image-20230411222204722"></p><h1 id="定制自己的Linux"><a href="#定制自己的Linux" class="headerlink" title="定制自己的Linux"></a>定制自己的Linux</h1><h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><img src="/LINUX.assets/image-20230411222826360.png" alt="image-20230411222826360"></p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="/LINUX.assets/image-20230411222925848.png" alt="image-20230411222925848"></p><h2 id="制作mini-Linux的思路分析"><a href="#制作mini-Linux的思路分析" class="headerlink" title="制作mini Linux的思路分析"></a>制作mini Linux的思路分析</h2><p><img src="/LINUX.assets/image-20230411223100721.png" alt="image-20230411223100721"></p><img src="LINUX.assets/image-20230411223500742.png" alt="image-20230411223500742" style="zoom:50%;" /><h1 id="Linux内核源码-内核升级"><a href="#Linux内核源码-内核升级" class="headerlink" title="Linux内核源码&amp;内核升级"></a>Linux内核源码&amp;内核升级</h1><h2 id="为什么要阅读Linux内核"><a href="#为什么要阅读Linux内核" class="headerlink" title="为什么要阅读Linux内核"></a>为什么要阅读Linux内核</h2><p><img src="/LINUX.assets/image-20230412152354497.png" alt="image-20230412152354497"></p><h2 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><img src="/LINUX.assets/image-20230412152317682.png" alt="image-20230412152317682"></p><h2 id="源码阅读技巧"><a href="#源码阅读技巧" class="headerlink" title="源码阅读技巧"></a>源码阅读技巧</h2><p><img src="/LINUX.assets/image-20230412152708542.png" alt="image-20230412152708542"></p><h2 id="Linux内核最新版和内核升级"><a href="#Linux内核最新版和内核升级" class="headerlink" title="Linux内核最新版和内核升级"></a>Linux内核最新版和内核升级</h2><h3 id="最新版"><a href="#最新版" class="headerlink" title="最新版"></a>最新版</h3><p><img src="/LINUX.assets/image-20230412154725851.png" alt="image-20230412154725851"></p><h3 id="内核升级"><a href="#内核升级" class="headerlink" title="内核升级"></a>内核升级</h3><p><img src="/LINUX.assets/image-20230412154700094.png" alt="image-20230412154700094"></p><h1 id="备份与恢复介绍"><a href="#备份与恢复介绍" class="headerlink" title="备份与恢复介绍"></a>备份与恢复介绍</h1><h2 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><img src="/LINUX.assets/image-20230412155440078.png" alt="image-20230412155440078"></p><h2 id="安装dump和restore"><a href="#安装dump和restore" class="headerlink" title="安装dump和restore"></a>安装dump和restore</h2><p><img src="/LINUX.assets/image-20230412155619597.png" alt="image-20230412155619597"></p><h2 id="用dump完成备份"><a href="#用dump完成备份" class="headerlink" title="用dump完成备份"></a>用dump完成备份</h2><h3 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><img src="/LINUX.assets/image-20230412160222768.png" alt="image-20230412160222768"></p><h3 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h3><p><img src="/LINUX.assets/image-20230412160525841.png" alt="image-20230412160525841"></p><h3 id="dump-W"><a href="#dump-W" class="headerlink" title="dump -W"></a>dump -W</h3><p><img src="/LINUX.assets/image-20230412160646181.png" alt="image-20230412160646181"></p><h3 id="dump备份文件或目录-不支持增量备份"><a href="#dump备份文件或目录-不支持增量备份" class="headerlink" title="dump备份文件或目录-不支持增量备份"></a>dump备份文件或目录-不支持增量备份</h3><p><img src="/LINUX.assets/image-20230412161112939.png" alt="image-20230412161112939"></p><h2 id="用restore完成恢复"><a href="#用restore完成恢复" class="headerlink" title="用restore完成恢复"></a>用restore完成恢复</h2><h3 id="基本介绍和基本语法"><a href="#基本介绍和基本语法" class="headerlink" title="基本介绍和基本语法"></a>基本介绍和基本语法</h3><p><img src="/LINUX.assets/image-20230412161546683.png" alt="image-20230412161546683"></p><h3 id="应用案例-2"><a href="#应用案例-2" class="headerlink" title="应用案例"></a>应用案例</h3><h4 id="比较模式"><a href="#比较模式" class="headerlink" title="比较模式"></a>比较模式</h4><p><img src="/LINUX.assets/image-20230412161707514.png" alt="image-20230412161707514"></p><h4 id="查看模式"><a href="#查看模式" class="headerlink" title="查看模式"></a>查看模式</h4><p><img src="/LINUX.assets/image-20230412162559818.png" alt="image-20230412162559818"></p><h4 id="还原模式"><a href="#还原模式" class="headerlink" title="还原模式"></a>还原模式</h4><p><img src="/LINUX.assets/image-20230412162539292.png" alt="image-20230412162539292"></p><p><img src="/LINUX.assets/image-20230412162518745.png" alt="image-20230412162518745"></p><h1 id="Linux可视化管理-webmin和bt运维工具"><a href="#Linux可视化管理-webmin和bt运维工具" class="headerlink" title="Linux可视化管理 webmin和bt运维工具\"></a>Linux可视化管理 webmin和bt运维工具\</h1><h2 id="bt"><a href="#bt" class="headerlink" title="bt"></a>bt</h2><h3 id="bt安装"><a href="#bt安装" class="headerlink" title="bt安装"></a>bt安装</h3><p><img src="/LINUX.assets/image-20230412170346021.png" alt="image-20230412170346021"></p><p><img src="/LINUX.assets/image-20230412170318243.png" alt="image-20230412170318243"></p><h3 id="查看用户密码等"><a href="#查看用户密码等" class="headerlink" title="查看用户密码等"></a>查看用户密码等</h3><p><img src="/LINUX.assets/image-20230412170411998.png" alt="image-20230412170411998"></p><h1 id="Linux面试题-12"><a href="#Linux面试题-12" class="headerlink" title="Linux面试题-12"></a>Linux面试题-12</h1><p>p142-153</p><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记</title>
      <link href="/2023/07/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习建议"><a href="#操作系统学习建议" class="headerlink" title="操作系统学习建议"></a>操作系统学习建议</h1><p>不过说实话，如果你还在校大二大三，我真的墙裂建议你去做一些国外的计算机 lab，比如OS、Network。</p><p>等到毕业了，几乎就不太可能从头开始系统学习那些基础知识了，除非你能自己闭关两三年，啥也不做，待在一个地方专心修炼。</p><p>好好珍惜在学校大把的空闲时间，做一些让在专业上让自己受益一生的事情。</p><p>这里我可以列举几个，国内不少喜欢 System 的同学都会去跟 MIT、CMU、UCB 这些计算机名校的课程。</p><p>比如 MIT 的 <strong>6.824 Distributed System</strong>、<strong>6.830 Database Systems</strong>、<strong>MIT 6.828 Operating System Engineering</strong> …..</p><blockquote><p>6.828是MIT的操作系统导论课，网上流传了一个录制质量不高的版本，可能可以在B站找到。 这门课教了操作系统的原理，并带学生简单实现了操作系统的主要部分。 要学习6.828的Lab，最好已经对C语言非常熟悉，而且上过了诸如 计算机组成原理 和 操作系统 等等课程，否则可能非常吃力，看着大佬的讲义不明所以。</p></blockquote><h1 id="操作系统lab项目"><a href="#操作系统lab项目" class="headerlink" title="操作系统lab项目"></a><a href="https://chyyuu.gitbooks.io/ucore_os_docs/content/">操作系统lab项目</a></h1><p>RTFM是Read The Fucking Manual的意思，STFW是Search The Fucking Web的意思。</p><img src="操作系统(王道+操作系统导论).assets/image-20220902233323683.png" alt="image-20220902233323683" style="zoom:50%;" /><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><ul><li>是指控制和管理整个计算机系统的硬件和软件资源，并合理组织和调度计算机工作和资源分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的&#x3D;&#x3D;系统软件&#x3D;&#x3D;</li></ul><h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><ul><li><p><strong>作为系统资源的管理者</strong></p><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220903100814014.png" alt="image-20220903100814014" style="zoom:50%;" /></li></ul></li><li><p><strong>作为用户和计算机硬件之间的接口</strong></p><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220903101031471.png" alt="image-20220903101031471" style="zoom:50%;" /></li><li><p>命令接口</p><ul><li><p>联机命令接口：交互式命令接口</p></li><li><p>脱机命令接口：批处理命令接口</p></li></ul></li><li><p>程序接口(允许用户通过程序间接使用)</p><ul><li>有一组系统调用组成（程序接口&#x3D;&#x3D;系统调用）————系统调用=&#x3D;系统调用命令=&#x3D;广义指令（易懵指令）</li></ul></li><li><p>GUI</p><ul><li>就是图形化操作界面</li></ul></li></ul></li><li><p><strong>作为最接近硬件的层次</strong></p><ul><li>实现对硬件资源的拓展（封装思想）</li><li>没有任何软件支持的计算机称为&#x3D;&#x3D;裸机&#x3D;&#x3D;。在裸机上安装操作系统，可以提供资源管理功能和方便用户的服务功能、将裸机改造成功能更强、使用更方便的机器</li><li>通常把覆盖了软件的机器称作为&#x3D;&#x3D;扩充机器&#x3D;&#x3D;，又称之为&#x3D;&#x3D;虚拟机&#x3D;&#x3D;</li></ul></li></ul><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><img src="操作系统(王道+操作系统导论).assets/image-20220903102653218.png" alt="image-20220903102653218" style="zoom:50%;" /><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><ul><li>指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的</li><li>混淆概念——并行：指两个或多个事件在同一时刻同时发生</li><li><strong>操作系统的并发性</strong><ul><li>计算机系统中同时存在多个运行着的程序<ul><li>一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会协调多个程序的交替执行，这些程序在微观上是交替进行的，但宏观上好像是同时进行的<ul><li>事实上，操作系统就是伴随着“多到程序技术”诞生的。因此操作系统和程序并发是同时出现的</li></ul></li><li>当今的计算机，一般都是多核CPU，比如4核CPU，这意味着同一时刻可以有4个程序并行执行，但操作系统的并发性依然必不可少，因为有4个以上程序在运行的可能</li></ul></li></ul></li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a><strong>共享</strong></h3><ul><li><p>即资源共享，是指系统中的资源可提供给内存中多个并发执行的进程共同使用</p></li><li><p>互斥共享方式</p><ul><li>系统中的某些资源虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong><ul><li>例子：如qq和微信视屏聊天，同一时间段内摄像头只能分配给一个进程</li></ul></li><li>系统中的某些资源，<strong>允许一个时间段内有多个进程“同时”对它们访问</strong>（同时是宏观的，微观上，进程是交替访问的，即分时共享）<ul><li>使用qq发送文件A，使用微信发送文件B。从宏观上看，两边同时读取并发送文件，说明两个进程都在访问硬盘资源，在读取数据。从微观上看是交替访问硬盘（<strong>所以为什么说并发和共享互为存在条件</strong>）</li></ul></li></ul></li></ul><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a><strong>虚拟</strong></h3><ul><li>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的</li><li>例子：<ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220903105739149.png" alt="image-20220903105739149" style="zoom:50%;" /></li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA" alt="image-20220903105908446 - 副本">.assets&#x2F;image-20220903105908446 - 副本.png)</li></ul></li><li><strong>虚拟技术</strong><ul><li><strong>空分复用技术</strong>（如虚拟存储器技术）</li><li><strong>时分复用技术</strong>（如虚拟处理器）</li><li><em>没有并发性就谈不上虚拟性</em></li></ul></li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong>异步</strong></h3><ul><li>在多道程序下，允许程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进，这就是进程的异步性<ul><li>例子：<ul><li>一个进程调用了一个资源，但由于并发性，轮到下一个进程占用CPU，其也要调用这个资源，但是上个进程还未归还，所以要等到其归还才可以调用这个资源</li></ul></li><li><em>只有系统拥有并发性，才有可能导致异步性</em></li></ul></li></ul><h2 id="操作系统的发展和分类"><a href="#操作系统的发展和分类" class="headerlink" title="操作系统的发展和分类"></a>操作系统的发展和分类</h2><img src="操作系统(王道+操作系统导论).assets/image-20220904094118110.png" alt="image-20220904094118110" style="zoom:50%;" /><ul><li><p><strong>手工操作阶段</strong></p><ul><li>主要缺点用户独占全机，人机速度矛盾导致的资源利用率低</li></ul></li><li><p><strong>批处理阶段</strong>——单道批处理系统</p><ul><li><p>引入脱机输入／输出技术（用磁带完成），并监督程序负责控制作业的输入、输出</p></li><li><p>&#x3D;&#x3D;主要优点&#x3D;&#x3D;：缓解了一定程度的人机速度矛盾，资源利用率有所提升。主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待1／0完成。资源利用率依然很低。</p></li></ul></li><li><p><strong>批处理阶段</strong>—一多道批处理系统</p><ul><li><p>每次往内存中输</p></li><li><p>操作系统正式诞生，并引入了中断入多道程序技术，由操作系统负责管理这些程序的运行。各个程序并发执行</p></li><li><p>多道批处理系统：</p></li><li><p>&#x3D;&#x3D;主要优点&#x3D;&#x3D;：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</p></li><li><p>&#x3D;&#x3D;主要缺点&#x3D;&#x3D;：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</p></li></ul></li><li><p><strong>分时操作系统</strong></p><ul><li><p>计算机以时间片为单位轮流为各个用户／作业服务，各个用户可通过终端与计算机进行交互。</p></li><li><p>主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p></li><li><p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户／作业都是完全公平的，循环地为每个用户／作业服务一个时间片，不区分任务的紧急性。</p></li></ul></li><li><p><strong>实时操作系统</strong>：</p><ul><li><p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</p></li><li><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性</p></li><li><p>硬实时操作系统</p><ul><li>必须在绝对严格的时间内完成处理，<em>例如：导弹控制系统，自动驾驶系统</em></li></ul></li><li><p>软实时操作系统</p><ul><li>能接受偶尔违反时间规定，<em>例如：12306火车订票系统</em></li></ul></li></ul></li><li><p><strong>网络操作系统</strong>：</p><ul><li>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）</li></ul></li><li><p><strong>分布式操作系统</strong>：</p><ul><li>主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。</li></ul></li><li><p><strong>个人计算机操作系统</strong>：</p><ul><li>如Windows XP、MacOS，方便个人使用。</li></ul></li></ul><h2 id="操作系统运行机制和体系结构"><a href="#操作系统运行机制和体系结构" class="headerlink" title="操作系统运行机制和体系结构"></a>操作系统运行机制和体系结构</h2><img src="操作系统(王道+操作系统导论).assets/image-20220904094736191.png" alt="image-20220904094736191" style="zoom:50%;" /><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><ul><li><p><strong>两种指令</strong></p><ul><li><strong>特权指令</strong>：如内存清零指令（不允许用户程序来使用）</li><li>非特权指令：如普通的运算指令</li></ul></li><li><p><strong>两种处理器状态</strong>——*&#x3D;&#x3D;都是在CPU上执行&#x3D;&#x3D;*</p></li><li><p>——<em>用程序状态字寄存器（PSW）的某种标志位来标识当前处理器处于什么状态。如0为用户态，1为核心态</em></p><ul><li><p><strong>核心态</strong></p><ul><li>此时CPU<em>只能执行非特权指令</em></li></ul></li><li><p>用户态</p><ul><li>特权指令和非特权指令都可以执行</li></ul></li></ul></li><li><p><strong>两种程序应用程序</strong></p><ul><li>内核程序<ul><li>操作系统的内核程序是系统的管理者既可以执行特权指令，也可以执行非特权指令，运行在&#x3D;&#x3D;核心态&#x3D;&#x3D;</li></ul></li><li>应用程序<ul><li>为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在&#x3D;&#x3D;用户态&#x3D;&#x3D;</li></ul></li></ul></li></ul><h3 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h3><img src="操作系统(王道+操作系统导论).assets/image-20220904100516564.png" alt="image-20220904100516564" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220904100810609.png" alt="image-20220904100810609" style="zoom:50%;" /><h3 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a>操作系统体系结构</h3><img src="操作系统(王道+操作系统导论).assets/image-20220904100854666.png" alt="image-20220904100854666" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220904101150324-1664886548334-1.png" alt="image-20220904101150324" style="zoom:50%;" /><h2 id="中断和异常（操作系统的内核）"><a href="#中断和异常（操作系统的内核）" class="headerlink" title="中断和异常（操作系统的内核）"></a>中断和异常（<em>操作系统的内核</em>）</h2><img src="操作系统(王道+操作系统导论).assets/image-20220904101721692.png" alt="image-20220904101721692" style="zoom:50%;" /><ul><li><p><strong>中断机制的诞生</strong></p><ul><li>引入中断机制，实现了多道程序并发执行，<strong>本质</strong>：&#x3D;&#x3D;发生中断&#x3D;&#x3D;就意味着需要&#x3D;&#x3D;操作系统介入，开展管理工作&#x3D;&#x3D;</li></ul></li><li><p><strong>中断的概念和应用</strong></p><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220904102348496.png" alt="image-20220904102348496" style="zoom:50%;" /></li></ul></li><li><p><strong>中断的分类</strong></p><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220904103000720.png" alt="image-20220904103000720" style="zoom:50%;" /></li><li><p>&#x3D;&#x3D;另一种分类方式&#x3D;&#x3D;</p></li><li><img src="操作系统(王道+操作系统导论).assets/image-20220904103205928.png" alt="image-20220904103205928" style="zoom:50%;" /></li></ul></li><li><p><strong>外中断处理过程</strong></p><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220904103444627.png" alt="image-20220904103444627" style="zoom:50%;" /></li></ul></li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><img src="操作系统(王道+操作系统导论).assets/image-20220904103735653.png" alt="image-20220904103735653" style="zoom:50%;" /><h3 id="什么是系统调用，有何作用"><a href="#什么是系统调用，有何作用" class="headerlink" title="什么是系统调用，有何作用"></a><strong>什么是系统调用，有何作用</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220904104004178.png" alt="image-20220904104004178" style="zoom:50%;" /></li></ul><hr><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220904104709516.png" alt="image-20220904104709516" style="zoom:50%;" /></li></ul><h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a><strong>系统调用和库函数的区别</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220904105044075.png" alt="image-20220904105044075" style="zoom:50%;" /></li></ul><h3 id="系统调用背后的过程"><a href="#系统调用背后的过程" class="headerlink" title="系统调用背后的过程"></a><strong>系统调用背后的过程</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220904105719452.png" alt="image-20220904105719452" style="zoom:50%;" /></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>总结</strong>&#x3D;&#x3D;</h3><img src="操作系统(王道+操作系统导论).assets/image-20220904110302874.png" alt="image-20220904110302874" style="zoom:100%;" /><p>​</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="进程的定义、组成、组织方式、特征"><a href="#进程的定义、组成、组织方式、特征" class="headerlink" title="进程的定义、组成、组织方式、特征"></a>进程的定义、组成、组织方式、特征</h2><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a><strong>进程的定义</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905084312209.png" alt="image-20220905084312209" style="zoom:50%;" /></li></ul><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a><strong>进程的组成</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905084922874.png" alt="image-20220905084922874" style="zoom: 50%;" /></li><li><img src="操作系统(王道+操作系统导论).assets/image-20220905084559660.png" alt="image-20220905084559660" style="zoom: 33%;" /></li><li><h4 id="PCB组成"><a href="#PCB组成" class="headerlink" title="PCB组成"></a><strong>PCB组成</strong></h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905084803213.png" alt="image-20220905084803213" style="zoom:50%;" /></li></ul></li></ul><h3 id="进程的-组织方式"><a href="#进程的-组织方式" class="headerlink" title="进程的&#x3D;&#x3D;组织方式&#x3D;&#x3D;"></a><strong>进程的&#x3D;&#x3D;组织方式&#x3D;&#x3D;</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905085114722.png" alt="image-20220905085114722" style="zoom:50%;" /><ul><li><h4 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a><strong>链接方式</strong></h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905085244127.png" alt="image-20220905085244127" style="zoom:50%;" /></li></ul></li><li><h4 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a><strong>索引方式</strong></h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905085336199.png" alt="image-20220905085336199" style="zoom: 50%;" /></li></ul></li></ul></li></ul><h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a><strong>进程的特征</strong></h3><ul><li><p>进程和程序是两个截然不同的概念。相比较于程序，进程拥有以下特征</p></li><li><img src="操作系统(王道+操作系统导论).assets/image-20220905085630651.png" alt="image-20220905085630651" style="zoom:50%;" /></li><li><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>总结</strong>&#x3D;&#x3D;</h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905085806818.png" alt="image-20220905085806818" style="zoom:50%;" /></li></ul></li></ul><h2 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h2><h4 id="与处理机调度的联系"><a href="#与处理机调度的联系" class="headerlink" title="与处理机调度的联系"></a>与处理机调度的联系</h4><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a><strong>进程的状态</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905090156899.png" alt="image-20220905090156899" style="zoom:50%;" /></li><li><h4 id="三种基本状态"><a href="#三种基本状态" class="headerlink" title="三种基本状态"></a><strong>三种基本状态</strong></h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905090616882.png" alt="image-20220905090616882" style="zoom:50%;" /></li></ul></li><li><h4 id="另外两种状态"><a href="#另外两种状态" class="headerlink" title="另外两种状态"></a><strong>另外两种状态</strong></h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905090654002.png" alt="image-20220905090654002" style="zoom: 80%;" /></li></ul></li></ul><h3 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905091020634.png" alt="image-20220905091020634" style="zoom:50%;" /></li><li><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>总结</strong>&#x3D;&#x3D;</h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905091103801.png" alt="image-20220905091103801" style="zoom:50%;" /></li></ul></li></ul><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220905091709237.png" alt="image-20220905091709237"></p><h2 id="进程控制（-控制进程状态-转换具体细节-）"><a href="#进程控制（-控制进程状态-转换具体细节-）" class="headerlink" title="进程控制（*控制进程状态&#x3D;&#x3D;转换具体细节&#x3D;&#x3D;*）"></a>进程控制（*控制进程状态&#x3D;&#x3D;转换具体细节&#x3D;&#x3D;*）</h2><ul><li><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态之间的转换</p></li><li><img src="操作系统(王道+操作系统导论).assets/image-20220905091555291.png" alt="image-20220905091555291" style="zoom:50%;" /><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a><strong>如何实现</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905092208784.png" alt="image-20220905092208784" style="zoom:50%;" /></li><li>为了防止进程标志位的出错（即运行态……），&#x3D;&#x3D;用“原语”实现&#x3D;&#x3D;</li></ul></li></ul><h3 id="原语——即具体细节"><a href="#原语——即具体细节" class="headerlink" title="原语——即具体细节"></a><strong>原语</strong>——<em>即具体细节</em></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905092506567.png" alt="image-20220905092506567" style="zoom:50%;" /></li><li><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220905092719927.png" alt="image-20220905092719927"></p></li></ul><h3 id="进程相关原语"><a href="#进程相关原语" class="headerlink" title="进程相关原语"></a><strong>进程相关原语</strong></h3><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a><strong>进程的创建</strong></h4><ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220905093351769.png" alt="image-20220905093351769"></li></ul><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a><strong>进程的终止</strong></h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905093447119.png" alt="image-20220905093447119" style="zoom:50%;" /></li></ul><h4 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a><strong>进程的阻塞和唤醒</strong></h4><ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220905093611975.png" alt="image-20220905093611975"></li></ul><h4 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a><strong>进程的切换</strong></h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905093817194.png" alt="image-20220905093817194" style="zoom:50%;" /></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905094006745.png" alt="image-20220905094006745" style="zoom:50%;" /></li></ul><img src="操作系统(王道+操作系统导论).assets/image-20220905094511585.png" alt="image-20220905094511585" style="zoom:50%;" /><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul><li>进程是分配系统资源的单位（包括内存地址空间），因此&#x3D;&#x3D;各进程&#x3D;&#x3D;拥有的&#x3D;&#x3D;内存地址空间相互独立&#x3D;&#x3D;<ul><li>为了保证安全，一个进程不能直接访问另一个进程的地址空间</li><li>但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法</li></ul></li><li>总览</li></ul><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221004212020487.png" alt="image-20221004212020487"></p><h3 id="共享通信"><a href="#共享通信" class="headerlink" title="共享通信"></a><strong>共享通信</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905095008999.png" alt="image-20220905095008999" style="zoom:50%;" />+ ==互斥==：读和写不能同时进行</li></ul><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a><strong>消息传递</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905095535308.png" alt="image-20220905095535308" style="zoom:50%;" /></li></ul><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a><strong>管道通信</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905095244034.png" alt="image-20220905095244034" style="zoom:50%;" /></li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220905095635514.png" alt="image-20220905095635514" style="zoom: 67%;" /></li></ul><h2 id="线程和多线程模型（在进程之下）"><a href="#线程和多线程模型（在进程之下）" class="headerlink" title="线程和多线程模型（在进程之下）"></a>线程和多线程模型（<em>在进程之下</em>）</h2><h3 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a><strong>知识总览</strong></h3><img src="操作系统(王道+操作系统导论).assets/image-20220907090139736.png" alt="image-20220907090139736" style="zoom:50%;" /><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a><strong>什么是线程</strong></h3><ul><li><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220907091052985.png" alt="image-20220907091052985"></p></li><li><p>可以把线程理解为“轻量级进程”。</p></li><li><p>线程是一个&#x3D;&#x3D;基本的CPU执行单位&#x3D;&#x3D;，也可以是&#x3D;&#x3D;程序执行流的最小单位&#x3D;&#x3D;</p></li><li><p>引入线程之后，不仅是进程之间可以&#x3D;&#x3D;并发&#x3D;&#x3D;，进程内的&#x3D;&#x3D;各线程之间&#x3D;&#x3D;也可以&#x3D;&#x3D;并发&#x3D;&#x3D;，从而进一步提升了&#x3D;&#x3D;系统的并发度&#x3D;&#x3D;，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</p></li><li><p>引入线程后，&#x3D;&#x3D;进程&#x3D;&#x3D;只作为&#x3D;&#x3D;除CPU之外的系统资源的分配单位&#x3D;&#x3D;（如打印机、内存地址空间等都是分配给进程的）。 </p></li><li><p>多线程下每一个线程都有一个栈</p></li><li><p><strong>引入线程带来的变化</strong></p></li></ul><img src="操作系统(王道+操作系统导论).assets/image-20220907091701066.png" alt="image-20220907091701066" style="zoom:50%;" /><h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a><strong>线程的属性</strong></h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907091811682.png" alt="image-20220907091811682" style="zoom:50%;" /></li></ul><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a><strong>线程的实现方式</strong></h3><ul><li><strong>用户级线程</strong><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907092344566.png" alt="image-20220907092344566" style="zoom:50%;" /></li></ul></li><li><strong>内核级线程</strong><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907092432241.png" alt="image-20220907092432241" style="zoom:50%;" /></li></ul></li><li>在同时支持用户级线程和内核级线程的系统中，可采用二者结合的方式：将n个用户级线程映射到m个内核级线程上（n&gt;&#x3D;m）<ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907092704628.png" alt="image-20220907092704628" style="zoom:50%;" /></li></ul></li></ul><h3 id="多线程模型（用户级线程映射在内核级线程）"><a href="#多线程模型（用户级线程映射在内核级线程）" class="headerlink" title="多线程模型（用户级线程映射在内核级线程）"></a>多线程模型（<em>用户级线程映射在内核级线程</em>）</h3><h4 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a><strong>多对一</strong></h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907092915371.png" alt="image-20220907092915371" style="zoom:50%;" /></li></ul><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907093138941.png" alt="image-20220907093138941" style="zoom:50%;" /></li></ul><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907093321714.png" alt="image-20220907093321714" style="zoom:50%;" /></li></ul><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907093456788.png" alt="image-20220907093456788" style="zoom: 67%;" /></li></ul><h2 id="处理机调度（控制不同状态-进程的执行顺序-）"><a href="#处理机调度（控制不同状态-进程的执行顺序-）" class="headerlink" title="处理机调度（控制不同状态&#x3D;&#x3D;进程的执行顺序&#x3D;&#x3D;）"></a>处理机调度（控制不同状态&#x3D;&#x3D;进程的执行顺序&#x3D;&#x3D;）</h2><ul><li><strong>什么是处理机</strong>：<em>处理机包括中央处理器，主存储器，输入-输出接口，加接外围设备就构成完整的计算机系统。</em></li></ul><h3 id="知识总览-1"><a href="#知识总览-1" class="headerlink" title="知识总览"></a>知识总览</h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907094749417.png" alt="image-20220907094749417" style="zoom:50%;" /></li></ul><h3 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907095035816.png" alt="image-20220907095035816" style="zoom:50%;" /></li></ul><h3 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h3><h4 id="高级调度（作业调度）"><a href="#高级调度（作业调度）" class="headerlink" title="高级调度（作业调度）"></a>高级调度（作业调度）</h4><ul><li>主要指调入的问题</li><li><img src="操作系统(王道+操作系统导论).assets/image-20220907101330739.png" alt="image-20220907101330739" style="zoom:50%;" /></li></ul><h4 id="中级调度（内存调度）"><a href="#中级调度（内存调度）" class="headerlink" title="中级调度（内存调度）"></a>中级调度（内存调度）</h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907101439545.png" alt="image-20220907101439545" style="zoom:50%;" /></li></ul><img src="操作系统(王道+操作系统导论).assets/image-20220907101658642.png" alt="image-20220907101658642" style="zoom:50%;" /><h4 id="进程的挂起态与七状态模型"><a href="#进程的挂起态与七状态模型" class="headerlink" title="进程的挂起态与七状态模型"></a>进程的挂起态与七状态模型</h4><img src="操作系统(王道+操作系统导论).assets/image-20220907101954187.png" alt="image-20220907101954187" style="zoom:50%;" /><h4 id="低级调度（进程调度）"><a href="#低级调度（进程调度）" class="headerlink" title="低级调度（进程调度）"></a>低级调度（进程调度）</h4><img src="操作系统(王道+操作系统导论).assets/image-20220907102103187.png" alt="image-20220907102103187" style="zoom:50%;" /><h4 id="三层调度的联系和对比（-以及对进程状态影响-）"><a href="#三层调度的联系和对比（-以及对进程状态影响-）" class="headerlink" title="三层调度的联系和对比（*&#x3D;&#x3D;以及对进程状态影响&#x3D;&#x3D;*）"></a>三层调度的联系和对比（*&#x3D;&#x3D;以及对进程状态影响&#x3D;&#x3D;*）</h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907102301829.png" alt="image-20220907102301829" style="zoom:50%;" /></li></ul><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907102431704.png" alt="image-20220907102431704" style="zoom:50%;" /></li></ul><h3 id="进程调度-低级调度（细节）"><a href="#进程调度-低级调度（细节）" class="headerlink" title="进程调度&#x2F;低级调度（细节）"></a>进程调度&#x2F;低级调度（<em>细节</em>）</h3><h4 id="我的理解-："><a href="#我的理解-：" class="headerlink" title="&#x3D;&#x3D;我的理解&#x3D;&#x3D;："></a>&#x3D;&#x3D;我的理解&#x3D;&#x3D;：</h4><ul><li><strong>选择进程进行进程状态（就绪态和运行态）的切换</strong></li></ul><h4 id="知识总览-2"><a href="#知识总览-2" class="headerlink" title="知识总览"></a>知识总览</h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907102854553.png" alt="image-20220907102854553" style="zoom:50%;" /></li></ul><h4 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907103636626.png" alt="image-20220907103636626" style="zoom:50%;" /></li></ul><h4 id="进程调度的方式（对应两个调度时机）"><a href="#进程调度的方式（对应两个调度时机）" class="headerlink" title="进程调度的方式（对应两个调度时机）"></a>进程调度的方式（<em>对应两个调度时机</em>）</h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907105901693.png" alt="image-20220907105901693" style="zoom:50%;" /></li></ul><h4 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h4><h5 id="“-狭义-的进程调度”和”进程切换”的区别——-广义-的进程调度"><a href="#“-狭义-的进程调度”和”进程切换”的区别——-广义-的进程调度" class="headerlink" title="“&#x3D;&#x3D;狭义&#x3D;&#x3D;的进程调度”和”进程切换”的区别——&#x3D;&#x3D;广义&#x3D;&#x3D;的进程调度"></a>“&#x3D;&#x3D;狭义&#x3D;&#x3D;的进程调度”和”进程切换”的区别——&#x3D;&#x3D;广义&#x3D;&#x3D;的进程调度</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220907111433426.png" alt="image-20220907111433426"></p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><img src="操作系统(王道+操作系统导论).assets/image-20220907111654394.png" alt="image-20220907111654394" style="zoom:50%;" /><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220907111313934.png" alt="image-20220907111313934" style="zoom:50%;" /></li></ul><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><h4 id="知识总览-3"><a href="#知识总览-3" class="headerlink" title="知识总览"></a>知识总览</h4><ul><li><img src="操作系统(王道+操作系统导论).assets/image-20220910102306102.png" alt="image-20220910102306102" style="zoom:67%;" /></li></ul><h4 id="cpu利用率"><a href="#cpu利用率" class="headerlink" title="cpu利用率"></a>cpu利用率</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910102420292.png" alt="image-20220910102420292" style="zoom: 50%;" /><h4 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910102521064.png" alt="image-20220910102521064" style="zoom:50%;" /><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910102756241.png" alt="image-20220910102756241" style="zoom: 33%;" /><h5 id="进一步：带权周转时间"><a href="#进一步：带权周转时间" class="headerlink" title="进一步：带权周转时间"></a>进一步：带权周转时间</h5><ul><li><em>可计算出作业周转时间是作业实际运行时间的多少倍</em></li></ul><img src="操作系统(王道+操作系统导论).assets/image-20220910102956693.png" alt="image-20220910102956693" style="zoom:33%;" /><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910103134117.png" alt="image-20220910103134117" style="zoom: 33%;" /><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910103226532.png" alt="image-20220910103226532" style="zoom:33%;" /><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910103206676.png" alt="image-20220910103206676" style="zoom: 50%;" /><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="&#x3D;&#x3D;调度算法&#x3D;&#x3D;"></a>&#x3D;&#x3D;调度算法&#x3D;&#x3D;</h3><h4 id="知识总览-4"><a href="#知识总览-4" class="headerlink" title="知识总览"></a>知识总览</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910103521148.png" alt="image-20220910103521148" style="zoom:50%;" /><h4 id="学习思路"><a href="#学习思路" class="headerlink" title="学习思路"></a>学习思路</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910103614834.png" alt="image-20220910103614834" style="zoom:50%;" /><h4 id="FCFS算法"><a href="#FCFS算法" class="headerlink" title="FCFS算法"></a>FCFS算法</h4><blockquote><p>First Come Fisrt Serve</p></blockquote><img src="操作系统(王道+操作系统导论).assets/image-20220910104312300.png" alt="image-20220910104312300" style="zoom:50%;" /><h4 id="SJF算法"><a href="#SJF算法" class="headerlink" title="SJF算法"></a>SJF算法</h4><blockquote><p>Shortest Job(作业) First \ SPF : Shortest Proccess(进程) First</p></blockquote><img src="操作系统(王道+操作系统导论).assets/image-20220910105640059.png" alt="image-20220910105640059" style="zoom:50%;" /><h5 id="非抢占式"><a href="#非抢占式" class="headerlink" title="非抢占式"></a>非抢占式</h5><ul><li><strong>&#x3D;&#x3D;注意是在当前已到达里选运行时间最短的作业&#x2F;进程&#x3D;&#x3D;</strong></li></ul><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220910104813142.png" alt="image-20220910104813142"></p><h5 id="抢占式——SRTN"><a href="#抢占式——SRTN" class="headerlink" title="抢占式——SRTN"></a>抢占式——SRTN</h5><blockquote><p>Short Remaining Time Next</p></blockquote><img src="操作系统(王道+操作系统导论).assets/image-20220910105200187.png" alt="image-20220910105200187" style="zoom:50%;" /><h5 id="注意一些细节"><a href="#注意一些细节" class="headerlink" title="注意一些细节"></a>注意一些细节</h5><img src="操作系统(王道+操作系统导论).assets/image-20220910105450294.png" alt="image-20220910105450294" style="zoom:50%;" /><h4 id="HRRT算法"><a href="#HRRT算法" class="headerlink" title="HRRT算法"></a>HRRT算法</h4><blockquote><p>Highest Response Ratio Next——高响应比优先算法</p></blockquote><img src="操作系统(王道+操作系统导论).assets/image-20220910110425552.png" alt="image-20220910110425552" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220910110330867.png" alt="image-20220910110330867" style="zoom:50%;" /><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910110450132.png" alt="image-20220910110450132" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220910110522988.png" alt="image-20220910110522988" style="zoom:50%;" /><hr><h4 id="时间片轮转调度算法（RR）"><a href="#时间片轮转调度算法（RR）" class="headerlink" title="时间片轮转调度算法（RR）"></a>时间片轮转调度算法（RR）</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910112128471.png" alt="image-20220910112128471" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220910111825355.png" alt="image-20220910111825355" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220910111929360.png" alt="image-20220910111929360" style="zoom:50%;" /><ul><li><h4 id="一般来说，设计时间片时让让切换进程的开销占比不超过1"><a href="#一般来说，设计时间片时让让切换进程的开销占比不超过1" class="headerlink" title="一般来说，设计时间片时让让切换进程的开销占比不超过1%"></a><em><strong>一般来说，设计时间片时让让切换进程的开销占比不超过1%</strong></em></h4></li></ul><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910113050504.png" alt="image-20220910113050504" style="zoom:50%;" /><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><img src="操作系统(王道+操作系统导论).assets/image-20220910113137000.png" alt="image-20220910113137000" style="zoom:50%;" /><h4 id="多级反馈队列调度算法-MLFQ"><a href="#多级反馈队列调度算法-MLFQ" class="headerlink" title="多级反馈队列调度算法(MLFQ)"></a>多级反馈队列调度算法(MLFQ)</h4><blockquote><p>Multi-level Feedback Queue</p></blockquote><blockquote><p>对于短时间运行的交互型工作，获得类似于SJF&#x2F;STCF的很好的全局性能，同时对长时间运行的CPU密集型负载也可以公平地、不断稳步前进</p></blockquote><img src="操作系统(王道+操作系统导论).assets/image-20220910113701339.png" alt="image-20220910113701339" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220910113514688.png" alt="image-20220910113514688" style="zoom:50%;" /><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><img src="操作系统(王道+操作系统导论).assets/image-20220910113719368.png" alt="image-20220910113719368" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220910113841590.png" alt="image-20220910113841590" style="zoom:50%;" /><h4 id="彩票调度（lottery-scheduling）"><a href="#彩票调度（lottery-scheduling）" class="headerlink" title="彩票调度（lottery scheduling）"></a>彩票调度（lottery scheduling）</h4><blockquote><p>比例份额(proportional-shared)调度程序，又称公平份额(fair-share)调度程序</p><p>书p65</p></blockquote><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><ul><li>每隔一段时间，都会举行一次彩票抽奖，以确定接下来应该运行哪个程序。越是应该频繁运行的程序，越是应该拥有更多地赢得彩票的机会。</li></ul><h4 id="步长调度（stride-scheduling）"><a href="#步长调度（stride-scheduling）" class="headerlink" title="步长调度（stride scheduling）"></a>步长调度（stride scheduling）</h4><blockquote><p>彩票数小的步长在整体中大，彩票数小的步长在整体中小</p><p>书p69</p></blockquote><h2 id="进程同步-进程互斥"><a href="#进程同步-进程互斥" class="headerlink" title="进程同步&#x2F;进程互斥"></a>进程同步&#x2F;进程互斥</h2><h3 id="什么是进程同步"><a href="#什么是进程同步" class="headerlink" title="什么是进程同步"></a>什么是进程同步</h3><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911100353843.png" alt="image-20220911100353843" style="zoom: 50%;" /><h3 id="什么是进程互斥"><a href="#什么是进程互斥" class="headerlink" title="什么是进程互斥"></a>什么是进程互斥</h3><blockquote><p>1.临界资源<br>临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。</p><p>2.临界区：<br>每个进程中访问临界资源的那段代码称为临界区（criticalsection），每次只允许一个进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界资源的的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。</p></blockquote><img src="操作系统(王道+操作系统导论).assets/image-20220911100530772.png" alt="image-20220911100530772" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220911100713038.png" alt="image-20220911100713038" style="zoom:50%;" /><h4 id="为了实现临界资源的互斥访问，同时保证系统性能，需要遵循以下规则"><a href="#为了实现临界资源的互斥访问，同时保证系统性能，需要遵循以下规则" class="headerlink" title="为了实现临界资源的互斥访问，同时保证系统性能，需要遵循以下规则"></a>为了实现临界资源的互斥访问，同时保证系统性能，需要遵循以下规则</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911100921030.png" alt="image-20220911100921030" style="zoom:50%;" /><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><img src="操作系统(王道+操作系统导论).assets/image-20220911100952166.png" alt="image-20220911100952166" style="zoom:67%;" /><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><blockquote><p>给进入临界资源的进程加锁，实现不同进程对临界资源的互斥访问</p></blockquote><h4 id="Pthread锁"><a href="#Pthread锁" class="headerlink" title="Pthread锁"></a>Pthread锁</h4><ul><li>p220</li></ul><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><blockquote><p>一直消耗时间片但什么也不做，浪费cpu资源</p></blockquote><ul><li>p223</li></ul><h3 id="基于锁的并发数据结构"><a href="#基于锁的并发数据结构" class="headerlink" title="基于锁的并发数据结构"></a>基于锁的并发数据结构</h3><blockquote><p>当有多个线程进行时如何对数据结构进行操作（在并发的同时如何通过加锁互斥的进行对数据结构的各种操作）</p><p>p237</p></blockquote><h4 id="并发计数器"><a href="#并发计数器" class="headerlink" title="并发计数器"></a>并发计数器</h4><blockquote><p>p237</p></blockquote><ul><li>简单的实现</li><li>可扩展的计数</li></ul><h4 id="并发链表"><a href="#并发链表" class="headerlink" title="并发链表"></a>并发链表</h4><blockquote><p>不同进程对链表的操作</p><p>p241</p></blockquote><ul><li><p>扩展链表</p></li><li><blockquote><p>每个节点并发（上锁释放锁）</p></blockquote><ul><li>过手锁（锁耦合）</li><li>会导致开销过大：频繁的获取锁，释放锁</li><li>p243</li></ul></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>当心锁和控制流</li><li>p244</li></ul><h4 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h4><blockquote><p>p244</p></blockquote><h4 id="并发散列表"><a href="#并发散列表" class="headerlink" title="并发散列表"></a>并发散列表</h4><blockquote><p>p245</p></blockquote><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><blockquote><p>p249</p><p>条件变量是一个显示队列</p></blockquote><ul><li><p>一个进程暂停执行，进入队列等待某一条件成立的场景</p></li><li><p>生产者消费者问题</p></li></ul><h4 id="覆盖条件"><a href="#覆盖条件" class="headerlink" title="覆盖条件"></a>覆盖条件</h4><ul><li>保守策略</li><li>在不知道应该在条件变量（显示队列）上唤醒哪个进程时，全部唤醒</li></ul><h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><p>虚假唤醒(spurious wakeup)在采用条件等待时，我们使用的是 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(条件不满足)&#123; </span><br><span class="line">   <span class="built_in">pthread_cond_wait</span>(cond, mutex); </span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">//而不是: </span></span><br><span class="line"> <span class="built_in">If</span>( 条件不满足 )&#123; </span><br><span class="line">   <span class="built_in">pthread_cond_wait</span>(cond,mutex); </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p> 这是因为可能会存在虚假唤醒”spurious wakeup”的情况。 </p></blockquote><ul><li>也就是说，即使没有线程调用condition_signal, 原先调用condition_wait的函数也可能会返回。此时线程被唤醒了，但是条件并不满足，这个时候<strong>如果不对条件进行检查而往下执行</strong>(例如书p256)，就可能会导致后续的处理出现错误。 </li><li>虚假唤醒在linux的多处理器系统中&#x2F;在程序接收到信号时可能回发生。在Windows系统和JAVA虚拟机上也存在。在系统设计时应该可以避免虚假唤醒，但是这会影响条件变量的执行效率，而既然通过while循环就能避免虚假唤醒造成的错误，因此程序的逻辑就变成了while循环的情况。 </li><li>注意：即使是虚假唤醒的情况，线程也是在成功锁住mutex后才能从condition_wait()中返回。即使存在多个线程被虚假唤醒，但是也只能是一个线程一个线程的顺序执行，也即：lock(mutex)  检查&#x2F;处理  condition_wai()或者unlock(mutex)来解锁.</li></ul><h3 id="进程互斥-软件-实现方法"><a href="#进程互斥-软件-实现方法" class="headerlink" title="进程互斥&#x3D;&#x3D;软件&#x3D;&#x3D;实现方法"></a>进程互斥&#x3D;&#x3D;软件&#x3D;&#x3D;实现方法</h3><h4 id="单标志法——问题：？？其他就不会出现空闲让进吗？？"><a href="#单标志法——问题：？？其他就不会出现空闲让进吗？？" class="headerlink" title="单标志法——问题：？？其他就不会出现空闲让进吗？？"></a>单标志法——问题：？？其他就不会出现空闲让进吗？？</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911101607954.png" alt="image-20220911101607954" style="zoom:50%;" /><h4 id="双标志先检查法——问题：一起进入"><a href="#双标志先检查法——问题：一起进入" class="headerlink" title="双标志先检查法——问题：一起进入"></a>双标志先检查法——问题：一起进入</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911102138224.png" alt="image-20220911102138224" style="zoom:50%;" /><h4 id="双标志后检查法——问题：一起等待"><a href="#双标志后检查法——问题：一起等待" class="headerlink" title="双标志后检查法——问题：一起等待"></a>双标志后检查法——问题：一起等待</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911102511655.png" alt="image-20220911102511655" style="zoom:50%;" /><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911103439047.png" alt="image-20220911103439047" style="zoom: 50%;" /><h4 id="总结-12"><a href="#总结-12" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911103520021.png" alt="image-20220911103520021" style="zoom:50%;" /><h3 id="进程互斥-硬件-实现方法"><a href="#进程互斥-硬件-实现方法" class="headerlink" title="进程互斥&#x3D;&#x3D;硬件&#x3D;&#x3D;实现方法"></a>进程互斥&#x3D;&#x3D;硬件&#x3D;&#x3D;实现方法</h3><h4 id="中断屏蔽法"><a href="#中断屏蔽法" class="headerlink" title="中断屏蔽法"></a>中断屏蔽法</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911105032201.png" alt="image-20220911105032201" style="zoom:50%;" /><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>简单、高效</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不适用于多处理机（可能导致多台处理机同时访问临界资源）</li><li>只适用于操作系统内核进程，不适用于用户进程（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果让用户随意使用会很危险）</li></ul><h4 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911105827061.png" alt="image-20220911105827061" style="zoom:50%;" /><h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911110454494.png" alt="image-20220911110454494" style="zoom:50%;" /><h4 id="CompareAndSwap指令"><a href="#CompareAndSwap指令" class="headerlink" title="CompareAndSwap指令"></a>CompareAndSwap指令</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr,<span class="type">int</span> expected,<span class="type">int</span> <span class="keyword">new</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> actual=*ptr;</span><br><span class="line">    <span class="keyword">if</span>(actual=expected)</span><br><span class="line">        *ptr=<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链接加载和条件式存储"><a href="#链接加载和条件式存储" class="headerlink" title="链接加载和条件式存储"></a>链接加载和条件式存储</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Loadlinked</span><span class="params">(<span class="type">int</span> *ptr)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StoreConditonal</span><span class="params">(<span class="type">int</span> *ptr,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(no one has updeated *ptr since the Loadlinked to <span class="keyword">this</span> address)&#123;</span><br><span class="line">*ptr=value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//success!</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o;<span class="comment">//failed to update</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">Loadlinked</span>(&amp;lock-&gt;flag)==<span class="number">1</span>)</span><br><span class="line">            ;<span class="comment">//spin until it&#x27;s zero</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">StoreConditonal</span>(&amp;lock-&gt;flag,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">// if set-it-to-1 was a success:all done</span></span><br><span class="line">           <span class="comment">// otherwise:try it all over again</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">lock-&gt;flag==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fetch-and-add指令"><a href="#fetch-and-add指令" class="headerlink" title="fetch-and-add指令"></a>fetch-and-add指令</h4><blockquote><p>不同于之前的方法：本方法能够保证所有线程都能抢到锁。只要一个线程获得了ticket值，它最终会被调度。之前的方法不能够保证。比如基于test-and-set的方法，一个线程有可能一直自旋，即使其他线程在获取和释放锁</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="type">int</span> *ptr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> old=*ptr;</span><br><span class="line">    *ptr=old+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">lock_t</span>&#123;</span><br><span class="line">    <span class="type">int</span> ticket;</span><br><span class="line">    <span class="type">int</span> turn;</span><br><span class="line">&#125;<span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock_init</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">    lock-&gt;ticket=<span class="number">0</span>;</span><br><span class="line">    lock-&gt;turn=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> myturn = <span class="built_in">FetchAndAdd</span>(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span>(lock-&gt;turn!=myturn)</span><br><span class="line">        ;<span class="comment">//spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="built_in">FetchAndAdd</span>(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911110439661.png" alt="image-20220911110439661" style="zoom:50%;" /><h3 id="自旋过多怎么办"><a href="#自旋过多怎么办" class="headerlink" title="自旋过多怎么办"></a>自旋过多怎么办</h3><h4 id="放弃CPU"><a href="#放弃CPU" class="headerlink" title="放弃CPU"></a>放弃CPU</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;flag,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">yield</span>();<span class="comment">//give up the CPU       yield:退让</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>yeild()系统调用<ul><li>能够让运行(running)态变为就绪(ready)态，从而允许其他线程运行</li></ul></li></ul><h4 id="使用队列：休眠代替自旋"><a href="#使用队列：休眠代替自旋" class="headerlink" title="使用队列：休眠代替自旋"></a>使用队列：休眠代替自旋</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="信息量机制"><a href="#信息量机制" class="headerlink" title="信息量机制"></a>信息量机制</h3><img src="操作系统(王道+操作系统导论).assets/image-20220911111232874.png" alt="image-20220911111232874" style="zoom:50%;" /><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911112440928.png" alt="image-20220911112440928" style="zoom:50%;" /><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><h5 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h5><img src="操作系统(王道+操作系统导论).assets/image-20220911112847286.png" alt="image-20220911112847286" style="zoom:50%;" /><ul><li><em><strong>其中wait原语中while（S&lt;&#x3D;0）导致有一段时间在等待——问题是原语是不可中断的？？？</strong></em></li></ul><h5 id="记录型信号量——阻塞队列"><a href="#记录型信号量——阻塞队列" class="headerlink" title="记录型信号量——阻塞队列"></a>记录型信号量——阻塞队列</h5><img src="操作系统(王道+操作系统导论).assets/image-20220911114208367.png" alt="image-20220911114208367" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220911114358866.png" alt="image-20220911114358866" style="zoom:50%;" /><h4 id="进程互斥-信号量-实现方法"><a href="#进程互斥-信号量-实现方法" class="headerlink" title="进程互斥&#x3D;&#x3D;信号量&#x3D;&#x3D;实现方法"></a>进程互斥&#x3D;&#x3D;信号量&#x3D;&#x3D;实现方法</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911115315832.png" alt="image-20220911115315832" style="zoom:50%;" /><h4 id="进程同步-信号量-实现方法"><a href="#进程同步-信号量-实现方法" class="headerlink" title="进程同步&#x3D;&#x3D;信号量&#x3D;&#x3D;实现方法"></a>进程同步&#x3D;&#x3D;信号量&#x3D;&#x3D;实现方法</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911115759383.png" alt="image-20220911115759383" style="zoom:50%;" /><h4 id="实现进程的前驱关系"><a href="#实现进程的前驱关系" class="headerlink" title="实现进程的前驱关系"></a>实现进程的前驱关系</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911120114907.png" alt="image-20220911120114907" style="zoom:50%;" /><h4 id="总结-14"><a href="#总结-14" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><img src="操作系统(王道+操作系统导论).assets/image-20220911120243663.png" alt="image-20220911120243663" style="zoom:50%;" /><h4 id="p-v"><a href="#p-v" class="headerlink" title="p-v"></a>p-v</h4><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h5><ul><li><em><strong>实现互斥的操作要放在实现同步操作之后避免死锁现象</strong></em></li></ul><img src="操作系统(王道+操作系统导论).assets/image-20220912095247671.png" alt="image-20220912095247671" style="zoom: 50%;" /><h5 id="多生产者多消费者"><a href="#多生产者多消费者" class="headerlink" title="多生产者多消费者"></a>多生产者多消费者</h5><img src="操作系统(王道+操作系统导论).assets/image-20220912102105260.png" alt="image-20220912102105260" style="zoom:50%;" /><h5 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h5><img src="操作系统(王道+操作系统导论).assets/image-20220912102614874.png" alt="image-20220912102614874" style="zoom:50%;" /><h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h5><ul><li><h4 id="如何实现-1"><a href="#如何实现-1" class="headerlink" title="如何实现"></a>如何实现</h4></li></ul><img src="操作系统(王道+操作系统导论).assets/image-20220912104716532.png" alt="image-20220912104716532" style="zoom:50%;" /><h5 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h5><img src="操作系统(王道+操作系统导论).assets/image-20220912113250132.png" alt="image-20220912113250132" style="zoom:50%;" /><img src="C:\Users\Estrella\AppData\Roaming\Typora\typora-user-images\image-20220912113347424.png" alt="image-20220912113347424" style="zoom: 67%;" /><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><h4 id="为什么要引入管程"><a href="#为什么要引入管程" class="headerlink" title="为什么要引入管程"></a>为什么要引入管程</h4><img src="操作系统(王道+操作系统导论).assets/image-20220912113631445.png" alt="image-20220912113631445" style="zoom:50%;" /><h4 id="管程定义和基本特征"><a href="#管程定义和基本特征" class="headerlink" title="管程定义和基本特征"></a>管程定义和基本特征</h4><img src="操作系统(王道+操作系统导论).assets/image-20220912115330806.png" alt="image-20220912115330806" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220912115534010.png" alt="image-20220912115534010" style="zoom:50%;" /><h4 id="总结-15"><a href="#总结-15" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><img src="操作系统(王道+操作系统导论).assets/image-20220912115729084.png" alt="image-20220912115729084" style="zoom:50%;" /><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220913092013915.png" alt="image-20220913092013915"></p><h2 id="非死锁的缺陷"><a href="#非死锁的缺陷" class="headerlink" title="非死锁的缺陷"></a>非死锁的缺陷</h2><blockquote><p>并发编程的缺陷之一</p><p>主要讨论两种：违反原子性缺陷和错误顺序缺陷</p></blockquote><h3 id="违反原子性缺陷"><a href="#违反原子性缺陷" class="headerlink" title="违反原子性缺陷"></a>违反原子性缺陷</h3><ul><li>即需要原子操作的指令没有原子操作（原子操作就是不能被打断的操作）</li></ul><h3 id="错误顺序缺陷"><a href="#错误顺序缺陷" class="headerlink" title="错误顺序缺陷"></a>错误顺序缺陷</h3><ul><li><p>例如默认数据已经初始化了然后调用，实际数据还没初始化</p></li><li><p>解决方案：用锁和条件变量（显示队列）</p></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul><li>在并发环境下，各进程因<em><strong>竞争资源</strong></em>而造成的一种<em><strong>互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进</strong></em>的现象，这就是“死锁”。发生死锁后若无外力干涉，这些进程将无法向前推进。</li></ul><h3 id="死锁，饥饿和死循环的区别"><a href="#死锁，饥饿和死循环的区别" class="headerlink" title="死锁，饥饿和死循环的区别"></a>死锁，饥饿和死循环的区别</h3><img src="操作系统(王道+操作系统导论).assets/image-20220913092733666.png" alt="image-20220913092733666" style="zoom:50%;" /><h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><img src="操作系统(王道+操作系统导论).assets/image-20220913093021480.png" alt="image-20220913093021480" style="zoom:50%;" /><h4 id="操作系统导论中的死锁必要条件"><a href="#操作系统导论中的死锁必要条件" class="headerlink" title="操作系统导论中的死锁必要条件"></a>操作系统导论中的死锁必要条件</h4><ol><li>互斥：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）</li><li>持有并等待：线程获得的资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。</li><li>非抢占：线程获得的资源（例如锁），不能被抢占</li><li>循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的</li></ol><ul><li>如果这4个条件有一个不能满足，死锁就不能发生</li></ul><p>​</p><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><img src="操作系统(王道+操作系统导论).assets/image-20220913093441216.png" alt="image-20220913093441216" style="zoom:50%;" /><h3 id="死锁的处理策略——预防死锁"><a href="#死锁的处理策略——预防死锁" class="headerlink" title="死锁的处理策略——预防死锁"></a>死锁的处理策略——预防死锁</h3><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914091642672.png" alt="image-20220914091642672" style="zoom:50%;" /><h4 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914091839004.png" alt="image-20220914091839004" style="zoom:50%;" /><h5 id="操作系统导论中提及活锁的概念"><a href="#操作系统导论中提及活锁的概念" class="headerlink" title="操作系统导论中提及活锁的概念"></a>操作系统导论中提及活锁的概念</h5><ul><li><pre><code class="cpp">top:     lock(L1);    if(tryLock(L2)==-1)&#123;        unlock(L1);        goto top;    &#125;</code></pre></li><li><p>注意，另一个线程可以使用相同加锁方式，但是是不同的加锁顺序（L2然后L1），线程仍然不会产生死锁。但是会引入一个新的问题：活锁（livelock）。两个线程可能一直重复这个序列，又同时都枪锁失败。</p></li></ul><h4 id="破坏请求和保持条件（持有并等待）"><a href="#破坏请求和保持条件（持有并等待）" class="headerlink" title="破坏请求和保持条件（持有并等待）"></a>破坏请求和保持条件（持有并等待）</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914092038167.png" alt="image-20220914092038167" style="zoom:50%;" /><h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914092348957.png" alt="image-20220914092348957" style="zoom:50%;" /><ul><li>操作系统导论中针对第二点程序员可以自行对传入的参数进行调整顺序</li></ul><h4 id="总结-17"><a href="#总结-17" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914092409770.png" alt="image-20220914092409770" style="zoom:50%;" /><h3 id="死锁的处理策略——避免死锁"><a href="#死锁的处理策略——避免死锁" class="headerlink" title="死锁的处理策略——避免死锁"></a>死锁的处理策略——避免死锁</h3><h4 id="什么是安全策略"><a href="#什么是安全策略" class="headerlink" title="什么是安全策略"></a>什么是安全策略</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914093143295.png" alt="image-20220914093143295" style="zoom:50%;" /><h4 id="安全序列、不安全状态、死锁的联系"><a href="#安全序列、不安全状态、死锁的联系" class="headerlink" title="安全序列、不安全状态、死锁的联系"></a>安全序列、不安全状态、死锁的联系</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914093427382.png" alt="image-20220914093427382" style="zoom:50%;" /><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914094030785.png" alt="image-20220914094030785" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220914094140327.png" alt="image-20220914094140327" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20220914094400340.png" alt="image-20220914094400340" style="zoom:50%;" /><h4 id="总结-18"><a href="#总结-18" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914094442135.png" alt="image-20220914094442135" style="zoom:50%;" /><h3 id="死锁的处理策略——检测和解除"><a href="#死锁的处理策略——检测和解除" class="headerlink" title="死锁的处理策略——检测和解除"></a>死锁的处理策略——检测和解除</h3><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914095001801.png" alt="image-20220914095001801" style="zoom:50%;" /><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914100233393.png" alt="image-20220914100233393" style="zoom:50%;" /><h4 id="总结-19"><a href="#总结-19" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><img src="操作系统(王道+操作系统导论).assets/image-20220914100353862.png" alt="image-20220914100353862" style="zoom:50%;" /><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h2><img src="操作系统(王道+操作系统导论).assets/image-20220927233435448.png" alt="image-20220927233435448" style="zoom:50%;" /><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220927234925690.png" alt="image-20220927234925690"></p><h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928103815815.png" alt="image-20220928103815815"></p><h2 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h2><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928104945243.png" alt="image-20220928104945243"></p><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928104757996.png" alt="image-20220928104757996"></p><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928104557541.png" alt="image-20220928104557541"></p><h3 id="总结-20"><a href="#总结-20" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928104718770.png" alt="image-20220928104718770"></p><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928105947680.png" alt="image-20220928105947680"></p><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><blockquote><p>产生内部碎片——块内的浪费</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928105250897.png" alt="image-20220928105250897"></p><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928105452739.png" alt="image-20220928105452739"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928105629140.png" alt="image-20220928105629140"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928105919026.png" alt="image-20220928105919026"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928110035114.png" alt="image-20220928110035114"></p><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><blockquote><p>产生外部碎片</p><p>紧凑处理</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928110544000.png" alt="image-20220928110544000"></p><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928110759660.png" alt="image-20220928110759660"></p><h3 id="动态分区与分配算法"><a href="#动态分区与分配算法" class="headerlink" title="动态分区与分配算法"></a>动态分区与分配算法</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928111406132.png" alt="image-20220928111406132"></p><h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928111347571.png" alt="image-20220928111347571"></p><h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928111549018.png" alt="image-20220928111549018"></p><h4 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928111938021.png" alt="image-20220928111938021"></p><h4 id="总结-22"><a href="#总结-22" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220928112059913.png" alt="image-20220928112059913"></p><h3 id="连续分配方式的缺点"><a href="#连续分配方式的缺点" class="headerlink" title="连续分配方式的缺点"></a>连续分配方式的缺点</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929143654486.png" alt="image-20220929143654486"></p><h2 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h2><h3 id="基本分页存储管理-的基本概念"><a href="#基本分页存储管理-的基本概念" class="headerlink" title="&#x3D;&#x3D;基本分页存储管理&#x3D;&#x3D;的基本概念"></a>&#x3D;&#x3D;基本分页存储管理&#x3D;&#x3D;的基本概念</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929143937043.png" alt="image-20220929143937043"></p><p>&#x3D;&#x3D;<strong>注意页面和页框的区别</strong>&#x3D;&#x3D;</p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929144129324.png" alt="image-20220929144129324"></p><h4 id="如何实现地址的转换"><a href="#如何实现地址的转换" class="headerlink" title="如何实现地址的转换"></a>如何实现地址的转换</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929144700357.png" alt="image-20220929144700357"></p><img src="操作系统(王道+操作系统导论).assets/image-20220929144901370.png" alt="image-20220929144901370" style="zoom:50%;" /><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929145322271.png" alt="image-20220929145322271"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929145543201.png" alt="image-20220929145543201"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929145609060.png" alt="image-20220929145609060"></p><h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929145842562.png" alt="image-20220929145842562"></p><h4 id="页表——隐式页号"><a href="#页表——隐式页号" class="headerlink" title="页表——隐式页号"></a>页表——隐式页号</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929150604253.png" alt="image-20220929150604253"></p><h4 id="总结-23"><a href="#总结-23" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929150740306.png" alt="image-20220929150740306"></p><h3 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h3><h4 id="用页面来存页表项"><a href="#用页面来存页表项" class="headerlink" title="用页面来存页表项"></a><strong>用页面来存页表项</strong></h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929152247752.png" alt="image-20220929152247752"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929152916786.png" alt="image-20220929152916786"></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929153507002.png" alt="image-20220929153507002"> </p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929153945754.png" alt="image-20220929153945754"></p><h4 id="总结-24"><a href="#总结-24" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929154310874.png" alt="image-20220929154310874"></p><h3 id="具有快表的地址转换机构"><a href="#具有快表的地址转换机构" class="headerlink" title="具有快表的地址转换机构"></a>具有快表的地址转换机构</h3><blockquote><p>是基本地址变换机构的改进版本</p><p>局部性原理</p><p>​空间局部性、时间局部性</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929161519767.png" alt="image-20220929161519767"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929162253194.png" alt="image-20220929162253194"></p><h4 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h4><blockquote><p>Translation Lookaside Buffer &#x2F; 可以理解为页表缓冲</p></blockquote><ul><li>TLB,cache 本身都是存储器，但TLB,CACHE材质相较于内存更好，访存更快，速度差距几十倍不等。 TLB本质上也是Cache，只不过是做为页表的Cache。</li><li>存在CPU中</li></ul><h5 id="TLB替换策略"><a href="#TLB替换策略" class="headerlink" title="TLB替换策略"></a>TLB替换策略</h5><ul><li>LRU（最近最少使用策略）</li><li>随机策略</li><li>实际系统的TLB表项</li></ul><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221008163953237.png" alt="image-20221008163953237"></p><h4 id="多处理器（CPU）调度"><a href="#多处理器（CPU）调度" class="headerlink" title="多处理器（CPU）调度"></a>多处理器（CPU）调度</h4><blockquote><p>p74</p></blockquote><h5 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h5><ul><li>不同CPU上，假设一个CPU修改了进程的地址，另一个CPU的缓存上保存的还是之前的</li><li>所以每个缓存需要通过监听链接所有的缓存和内存的总线，来发现内存访问，如果CPU发现对它放在缓存中的数据的更新，会作废(invalidate)本地副本（从缓存中移除）</li></ul><h5 id="缓存亲和性"><a href="#缓存亲和性" class="headerlink" title="缓存亲和性"></a>缓存亲和性</h5><ul><li>尽可能让进程保持在同一个CPU上</li></ul><h5 id="单队列调度SQMS"><a href="#单队列调度SQMS" class="headerlink" title="单队列调度SQMS"></a>单队列调度SQMS</h5><blockquote><p>Single Queue Multiprocessor Scheduling</p></blockquote><ul><li>单队列多处理器调度</li><li>复用单处理器调度的基本架构</li><li>负载均衡，但是缓存亲和性低<ul><li>解决<ul><li>牺牲其他工作的亲和度来实现负载均衡和提高缓存亲和度</li><li>p77</li></ul></li></ul></li></ul><h5 id="多队列调度MQMS"><a href="#多队列调度MQMS" class="headerlink" title="多队列调度MQMS"></a>多队列调度MQMS</h5><blockquote><p>Multi-Queue Multiprocessor Scheduling</p><p>p77</p></blockquote><ul><li>缓存亲和度高，负载不均<ul><li>解决<ul><li>迁移：找到合适的阈值进行迁移</li></ul></li></ul></li></ul><h4 id="引入快表后，地址的变换过程"><a href="#引入快表后，地址的变换过程" class="headerlink" title="引入快表后，地址的变换过程"></a>引入快表后，地址的变换过程</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929162814330.png" alt="image-20220929162814330"></p><h4 id="总结-25"><a href="#总结-25" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929163004207.png" alt="image-20220929163004207"></p><h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><h4 id="问题一-：-单个页表占用连续页框"><a href="#问题一-：-单个页表占用连续页框" class="headerlink" title="问题一 ：&#x3D;&#x3D;单个页表占用连续页框&#x3D;&#x3D;"></a>问题一 ：&#x3D;&#x3D;单个页表占用连续页框&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929164732893.png" alt="image-20220929164732893"></p><h5 id="两级页表的原理、地址结构"><a href="#两级页表的原理、地址结构" class="headerlink" title="两级页表的原理、地址结构"></a>两级页表的原理、地址结构</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929170325926.png" alt="image-20220929170325926"></p><h5 id="如何实现地址转换——两级页表"><a href="#如何实现地址转换——两级页表" class="headerlink" title="如何实现地址转换——两级页表"></a>如何实现地址转换——两级页表</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929171032915.png" alt="image-20220929171032915"></p><h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929171455804.png" alt="image-20220929171455804"></p><h4 id="需要注意的几个细节"><a href="#需要注意的几个细节" class="headerlink" title="需要注意的几个细节"></a>需要注意的几个细节</h4><blockquote><p>为了让一个页面存放一个页表，各级页表的大小不能超过一个页面</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929172627018.png" alt="image-20220929172627018"></p><h4 id="总结-26"><a href="#总结-26" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20220929172650896.png" alt="image-20220929172650896"></p><h3 id="基本分段存储管理-方式"><a href="#基本分段存储管理-方式" class="headerlink" title="&#x3D;&#x3D;基本分段存储管理&#x3D;&#x3D;方式"></a>&#x3D;&#x3D;基本分段存储管理&#x3D;&#x3D;方式</h3><blockquote><p>按逻辑段拆分进程</p></blockquote><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001104309513.png" alt="image-20221001104309513"></p><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001104702406.png" alt="image-20221001104702406"></p><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001105225830.png" alt="image-20221001105225830"></p><h4 id="总结-27"><a href="#总结-27" class="headerlink" title="总结"></a>总结</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001110602549.png" alt="image-20221001110602549"></p><h3 id="分段、分页管理的对比"><a href="#分段、分页管理的对比" class="headerlink" title="分段、分页管理的对比"></a>分段、分页管理的对比</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001110224066.png" alt="image-20221001110224066"></p><ul><li><h4 id="分段的地址空间是二维的：因为分段的每个段的长度不同，需要检查偏移量是否越界，所以要传入段内地址"><a href="#分段的地址空间是二维的：因为分段的每个段的长度不同，需要检查偏移量是否越界，所以要传入段内地址" class="headerlink" title="分段的地址空间是二维的：因为分段的每个段的长度不同，需要检查偏移量是否越界，所以要传入段内地址"></a><strong>分段的地址空间是二维的：因为分段的每个段的长度不同，需要检查偏移量是否越界，所以要传入段内地址</strong></h4></li></ul><hr><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001105932915.png" alt="image-20221001105932915"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001110135749.png" alt="image-20221001110135749"></p><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001110323594.png" alt="image-20221001110323594"></p><h3 id="段页式分段管理"><a href="#段页式分段管理" class="headerlink" title="&#x3D;&#x3D;段页式分段管理&#x3D;&#x3D;"></a>&#x3D;&#x3D;段页式分段管理&#x3D;&#x3D;</h3><h4 id="分页、分段优缺点分析"><a href="#分页、分段优缺点分析" class="headerlink" title="分页、分段优缺点分析"></a>分页、分段优缺点分析</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001110934151.png" alt="image-20221001110934151"></p><h4 id="分段-分页-段页式管理"><a href="#分段-分页-段页式管理" class="headerlink" title="分段+分页&#x3D;段页式管理"></a>分段+分页&#x3D;段页式管理</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001111129821.png" alt="image-20221001111129821"></p><h4 id="段页式管理的逻辑地址结构"><a href="#段页式管理的逻辑地址结构" class="headerlink" title="段页式管理的逻辑地址结构"></a>段页式管理的逻辑地址结构</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001111912090.png" alt="image-20221001111912090"></p><h4 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001112158429.png" alt="image-20221001112158429"></p><h4 id="地址转换-1"><a href="#地址转换-1" class="headerlink" title="地址转换"></a>地址转换</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001112516685.png" alt="image-20221001112516685"></p><h4 id="总结-28"><a href="#总结-28" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001112917444.png" alt="image-20221001112917444"></p><h2 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h2><h3 id="传统存储管理方式的特征，缺点"><a href="#传统存储管理方式的特征，缺点" class="headerlink" title="传统存储管理方式的特征，缺点"></a>传统存储管理方式的特征，缺点</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001140143549.png" alt="image-20221001140143549"></p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001140448995.png" alt="image-20221001140448995"></p><h3 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001140750228.png" alt="image-20221001140750228"></p><hr><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001140654529.png" alt="image-20221001140654529"></p><h3 id="如何实现虚拟存储技术"><a href="#如何实现虚拟存储技术" class="headerlink" title="如何实现虚拟存储技术"></a>如何实现虚拟存储技术</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001140943964.png" alt="image-20221001140943964"></p><h3 id="总结-29"><a href="#总结-29" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001141111146.png" alt="image-20221001141111146"></p><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><blockquote><p>虚拟技术和非连续分配管理方式的结合</p></blockquote><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001141501593.png" alt="image-20221001141501593"></p><h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001141701572.png" alt="image-20221001141701572"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001141825615.png" alt="image-20221001141825615"></p><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001142049905.png" alt="image-20221001142049905"></p><h4 id="地址转换流程"><a href="#地址转换流程" class="headerlink" title="地址转换流程"></a>地址转换流程</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001142212793.png" alt="image-20221001142212793"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001142731470.png" alt="image-20221001142731470"></p><h4 id="总结-30"><a href="#总结-30" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001142920570.png" alt="image-20221001142920570"></p><h3 id="页面置换算法—调出驻留集"><a href="#页面置换算法—调出驻留集" class="headerlink" title="页面置换算法—调出驻留集"></a>页面置换算法—调出<del>驻留集</del></h3><blockquote><p>页面的换入、换出需要磁盘I&#x2F;O,会有较大的开销，因此好的页面置换算法应该追求最少的缺页率</p><p><strong>适用于&#x3D;&#x3D;缓存&#x3D;&#x3D;的替换</strong></p></blockquote><h4 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h4><blockquote><p>OPT : optimal</p><p>理想化算法，在实际应用中无法实现</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001143745627.png" alt="image-20221001143745627"></p><p>​<img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001143832702.png" alt="image-20221001143832702"></p><h4 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h4><blockquote><p>FIFO : First In First Out</p><p>页面置换算法中只有FIFO会产生belady异常</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001144219428.png" alt="image-20221001144219428"></p><h4 id="最近最久-未使用算法（LRU）"><a href="#最近最久-未使用算法（LRU）" class="headerlink" title="&#x3D;&#x3D;最近最久&#x3D;&#x3D;未使用算法（LRU）"></a>&#x3D;&#x3D;最近最久&#x3D;&#x3D;未使用算法（LRU）</h4><blockquote><p>Last Recently used</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001150320283.png" alt="image-20221001150320283"></p><h4 id="时钟置换算法（CLOCK）-最近-未用算法（NRU）"><a href="#时钟置换算法（CLOCK）-最近-未用算法（NRU）" class="headerlink" title="时钟置换算法（CLOCK）&#x2F; &#x3D;&#x3D;最近&#x3D;&#x3D;未用算法（NRU）"></a>时钟置换算法（CLOCK）&#x2F; &#x3D;&#x3D;最近&#x3D;&#x3D;未用算法（NRU）</h4><blockquote><p>NRU : Not Recently used</p></blockquote><h5 id="简单的时钟置换算法"><a href="#简单的时钟置换算法" class="headerlink" title="简单的时钟置换算法"></a>简单的时钟置换算法</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001150939466.png" alt="image-20221001150939466"></p><h5 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001151517913.png" alt="image-20221001151517913"></p><h4 id="总结-31"><a href="#总结-31" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001151559264.png" alt="image-20221001151559264"></p><ul><li><h2 id="随机策略：不会出现特殊情况下奇怪的结果"><a href="#随机策略：不会出现特殊情况下奇怪的结果" class="headerlink" title="随机策略：不会出现特殊情况下奇怪的结果"></a>随机策略：不会出现特殊情况下奇怪的结果</h2></li></ul><h3 id="页面分配、置换策略（调入驻留集）"><a href="#页面分配、置换策略（调入驻留集）" class="headerlink" title="页面分配、置换策略（调入驻留集）"></a>页面分配、置换策略（调入<del>驻留集</del>）</h3><h4 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001160126054.png" alt="image-20221001160126054"></p><hr><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001160145266.png" alt="image-20221001160145266"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001155134409.png" alt="image-20221001155134409"></p><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><blockquote><p>如果页存在内存中会被标记为有效的，反之会被标记无效的（有效位）</p><p>页错误：内存中缺页，通过页表查找到这些页在磁盘的什么位置，在用交换技术将磁盘中的页交换进内存</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001155533452.png" alt="image-20221001155533452"></p><h4 id="何处调入页面"><a href="#何处调入页面" class="headerlink" title="何处调入页面"></a>何处调入页面</h4><img src="操作系统(王道+操作系统导论).assets/image-20221001155809355.png" alt="image-20221001155809355" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221001155803418.png" alt="image-20221001155803418" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221001155847491.png" alt="image-20221001155847491" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221001155934266.png" alt="image-20221001155934266" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221001160024979.png" alt="image-20221001160024979" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221001160034777.png" alt="image-20221001160034777" style="zoom:50%;" /><h4 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001160315101.png" alt="image-20221001160315101"></p><h5 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h5><blockquote><p>为了研究应该为每个进程分配多少个物理块，Denning提出了进程“工作集”的概念</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001160542094.png" alt="image-20221001160542094"></p><h4 id="总结-32"><a href="#总结-32" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221001160908701.png" alt="image-20221001160908701"></p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="初始文件管理"><a href="#初始文件管理" class="headerlink" title="初始文件管理"></a>初始文件管理</h2><h3 id="操作系统向上提供了哪些功能"><a href="#操作系统向上提供了哪些功能" class="headerlink" title="操作系统向上提供了哪些功能"></a>操作系统向上提供了哪些功能</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002092022988.png" alt="image-20221002092022988"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002092121205.png" alt="image-20221002092121205"></p><h3 id="从上往下看，文件应如何存入到外存"><a href="#从上往下看，文件应如何存入到外存" class="headerlink" title="从上往下看，文件应如何存入到外存"></a>从上往下看，文件应如何存入到外存</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002092454206.png" alt="image-20221002092454206"></p><h3 id="其他需要操作系统实现的文件管理功能"><a href="#其他需要操作系统实现的文件管理功能" class="headerlink" title="其他需要操作系统实现的文件管理功能"></a>其他需要操作系统实现的文件管理功能</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002092621819.png" alt="image-20221002092621819"></p><h3 id="总结-——框架"><a href="#总结-——框架" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;——框架"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;——框架</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002092641570.png" alt="image-20221002092641570"></p><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><blockquote><p>所谓的“逻辑结构”，就是指在用户看来，文件<strong>内部</strong>的数据应该是如何组织起来的。</p><p>而“物理结构”指的是在操作系统看来，文件的（内部）数据是如何存放到外存中的</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002093222636.png" alt="image-20221002093222636"></p><h3 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002093322665.png" alt="image-20221002093322665"></p><h3 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002093450318.png" alt="image-20221002093450318"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002093508650.png" alt="image-20221002093508650"></p><h4 id="定长记录"><a href="#定长记录" class="headerlink" title="定长记录"></a>定长记录</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002093527836.png" alt="image-20221002093527836"></p><h4 id="可变长记录"><a href="#可变长记录" class="headerlink" title="可变长记录"></a>可变长记录</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002093622699.png" alt="image-20221002093622699"></p><h3 id="有结构文件的逻辑结构"><a href="#有结构文件的逻辑结构" class="headerlink" title="有结构文件的逻辑结构"></a>有结构文件的逻辑结构</h3><h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002094424918.png" alt="image-20221002094424918"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002094254381.png" alt="image-20221002094254381"></p><ul><li><h4 id="顺序文件可以定期写入外存，可以减少增删次数"><a href="#顺序文件可以定期写入外存，可以减少增删次数" class="headerlink" title="顺序文件可以定期写入外存，可以减少增删次数"></a><strong>顺序文件可以定期写入外存，可以减少增删次数</strong></h4></li></ul><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><blockquote><p>解决可变长记录文件的查找开销大的问题—&gt;实现随机访问</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002094731133.png" alt="image-20221002094731133"></p><h4 id="索引顺序表"><a href="#索引顺序表" class="headerlink" title="索引顺序表"></a>索引顺序表</h4><blockquote><p>索引表的缺点：每个记录对应的一个索引表项，因此索引表可能会很大。</p><p>比如：文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002095945954.png" alt="image-20221002095945954"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002100005463.png" alt="image-20221002100005463"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002100050110.png" alt="image-20221002100050110"></p><h4 id="总结-33"><a href="#总结-33" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002100242310.png" alt="image-20221002100242310"></p><h3 id="总结-34"><a href="#总结-34" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002100119448.png" alt="image-20221002100119448"></p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><blockquote><img src="操作系统(王道+操作系统导论).assets/image-20221002100604604.png" alt="image-20221002100604604" style="zoom: 33%;" /></blockquote><h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002100833404.png" alt="image-20221002100833404"></p><hr><h4 id="FCB-目录项"><a href="#FCB-目录项" class="headerlink" title="FCB 目录项"></a>FCB <del>目录项</del></h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002101005343.png" alt="image-20221002101005343"></p><hr><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002101114412.png" alt="image-20221002101114412"></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002101334564.png" alt="image-20221002101334564"></p><h4 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002101505251.png" alt="image-20221002101505251"></p><h4 id="多级目录结构-树形目录结构"><a href="#多级目录结构-树形目录结构" class="headerlink" title="多级目录结构 树形目录结构"></a>多级目录结构 <del>树形目录结构</del></h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002101803894.png" alt="image-20221002101803894"></p><h4 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h4><blockquote><p>由于树结构不便于实现文件的共享，提出了“无环图目录结构”</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002102051940.png" alt="image-20221002102051940"></p><h3 id="索引节点（FCB的改进）"><a href="#索引节点（FCB的改进）" class="headerlink" title="索引节点（FCB的改进）"></a>索引节点（FCB的改进）</h3><blockquote><p>使索引表瘦身，减少磁盘I&#x2F;O的开销，增加搜索效率</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002102631439.png" alt="image-20221002102631439"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002102737162.png" alt="image-20221002102737162"></p><h3 id="总结-35"><a href="#总结-35" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002102840341.png" alt="image-20221002102840341"></p><h2 id="文件的物理结构-文件的分配方式"><a href="#文件的物理结构-文件的分配方式" class="headerlink" title="文件的物理结构 文件的分配方式"></a>文件的物理结构 <del>文件的分配方式</del></h2><blockquote><p>即：文件数据应该怎样存放在外存中</p></blockquote><blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002103213063.png" alt="image-20221002103213063"></p></blockquote><h3 id="文件块、磁盘块"><a href="#文件块、磁盘块" class="headerlink" title="文件块、磁盘块"></a>文件块、磁盘块</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002104318288.png" alt="image-20221002104318288"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002104501708.png" alt="image-20221002104501708"></p><h3 id="文件分配方式"><a href="#文件分配方式" class="headerlink" title="文件分配方式"></a>文件分配方式</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><h5 id="地址转换-2"><a href="#地址转换-2" class="headerlink" title="地址转换"></a>地址转换</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002104850226.png" alt="image-20221002104850226"></p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002105010878.png" alt="image-20221002105010878"></p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002105125202.png" alt="image-20221002105125202"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002105219863.png" alt="image-20221002105219863"></p><h5 id="汇总-1"><a href="#汇总-1" class="headerlink" title="汇总"></a>汇总</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002110552875.png" alt="image-20221002110552875"></p><h4 id="链接分配-链式"><a href="#链接分配-链式" class="headerlink" title="链接分配 链式"></a>链接分配 <del>链式</del></h4><blockquote><p>不管是隐式分配或是显式分配，都需要从起始节点<strong>依次</strong>查找</p></blockquote><h5 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h5><h6 id="地址转换-3"><a href="#地址转换-3" class="headerlink" title="地址转换"></a>地址转换</h6><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002110834983.png" alt="image-20221002110834983"></p><h5 id="显式链接——文件分配表FAT"><a href="#显式链接——文件分配表FAT" class="headerlink" title="显式链接——文件分配表FAT"></a>显式链接——文件分配表FAT</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002111203163.png" alt="image-20221002111203163"></p><h6 id="地址转换-4"><a href="#地址转换-4" class="headerlink" title="地址转换"></a>地址转换</h6><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002111640713.png" alt="image-20221002111640713"></p><h5 id="总结-36"><a href="#总结-36" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002110914941.png" alt="image-20221002110914941"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002111652981.png" alt="image-20221002111652981"></p><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><blockquote><p>目录中需要一个索引块（也是逻辑块，在外存中有对应的磁盘块）</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002112858515.png" alt="image-20221002112858515"></p><h5 id="地址转换-5"><a href="#地址转换-5" class="headerlink" title="地址转换"></a>地址转换</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002113230548.png" alt="image-20221002113230548"></p><h5 id="链接分配中显式分配-和-索引分配-区别"><a href="#链接分配中显式分配-和-索引分配-区别" class="headerlink" title="链接分配中显式分配 和 索引分配 &#x3D;&#x3D;区别&#x3D;&#x3D;"></a>链接分配中显式分配 和 索引分配 &#x3D;&#x3D;区别&#x3D;&#x3D;</h5><img src="操作系统(王道+操作系统导论).assets/image-20221002112656232.png" alt="image-20221002112656232" style="zoom:50%;" /><h5 id="索引表太大的解决方案"><a href="#索引表太大的解决方案" class="headerlink" title="索引表太大的解决方案"></a>索引表太大的解决方案</h5><h6 id="链接方案"><a href="#链接方案" class="headerlink" title="链接方案"></a>链接方案</h6><blockquote><p>索引表在不同磁盘块是并行的，按索引表递增链接的</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002114340959.png" alt="image-20221002114340959"></p><h6 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h6><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002114818503.png" alt="image-20221002114818503"></p><img src="操作系统(王道+操作系统导论).assets/image-20221002114826714.png" alt="image-20221002114826714" style="zoom: 50%;" /><h6 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h6><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002115150457.png" alt="image-20221002115150457"></p><h6 id="总结-37"><a href="#总结-37" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h6><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002115522192.png" alt="image-20221002115522192"></p><h4 id="总结-38"><a href="#总结-38" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002115749220.png" alt="image-20221002115749220"></p><h2 id="文件存储空间管理-空闲磁盘块"><a href="#文件存储空间管理-空闲磁盘块" class="headerlink" title="文件存储空间管理 空闲磁盘块"></a>文件存储空间管理 <del>空闲磁盘块</del></h2><blockquote><p>对空闲磁盘块管理</p></blockquote><h3 id="存储空间的划分与初始化"><a href="#存储空间的划分与初始化" class="headerlink" title="存储空间的划分与初始化"></a>存储空间的划分与初始化</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002135937148.png" alt="image-20221002135937148"></p><h3 id="存储空间管理"><a href="#存储空间管理" class="headerlink" title="存储空间管理"></a>存储空间管理</h3><h4 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h4><blockquote><p>适用于“连续分配方式”</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002140921578.png" alt="image-20221002140921578"></p><h4 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h4><h5 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h5><blockquote><p>以盘块为单位组成一条空闲链</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002141455292.png" alt="image-20221002141455292"></p><h5 id="空闲盘块区"><a href="#空闲盘块区" class="headerlink" title="空闲盘块区"></a>空闲盘块区</h5><blockquote><p>以盘区为单位组成一条空闲链</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002141624035.png" alt="image-20221002141624035"></p><h4 id="位视图法"><a href="#位视图法" class="headerlink" title="位视图法"></a>位视图法</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002142031220.png" alt="image-20221002142031220"></p><ul><li><h5 id="分配与回收"><a href="#分配与回收" class="headerlink" title="分配与回收"></a>分配与回收</h5></li></ul><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002142238486.png" alt="image-20221002142238486"></p><h4 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002142412682.png" alt="image-20221002142412682"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002142900551.png" alt="image-20221002142900551"></p><ul><li><h3 id="201-299都被用了，不是空闲盘块"><a href="#201-299都被用了，不是空闲盘块" class="headerlink" title="201-299都被用了，不是空闲盘块"></a>201-299都被用了，不是空闲盘块</h3></li></ul><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221021172245702.png" alt="image-20221021172245702"></p><h5 id="如何分配"><a href="#如何分配" class="headerlink" title="如何分配"></a>如何分配</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002143007691.png" alt="image-20221002143007691"></p><h5 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002143158073.png" alt="image-20221002143158073"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002143215281.png" alt="image-20221002143215281"></p><h4 id="总结-39"><a href="#总结-39" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002143425121.png" alt="image-20221002143425121"></p><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002143646245.png" alt="image-20221002143646245"></p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002143745182.png" alt="image-20221002143745182"></p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><blockquote><p>系统只有一份打开表 &#x2F; 其他进程也会有打开表</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002143939901.png" alt="image-20221002143939901"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002144141769.png" alt="image-20221002144141769"></p><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002144229823.png" alt="image-20221002144229823"></p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002144432800.png" alt="image-20221002144432800"></p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><blockquote><p>懒惰（延迟）写入是一种美德</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002144558483.png" alt="image-20221002144558483"></p><h3 id="总结-40"><a href="#总结-40" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002144853210.png" alt="image-20221002144853210"></p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002144950283.png" alt="image-20221002144950283"></p><h3 id="基于索引节点的共享方式（硬链接）"><a href="#基于索引节点的共享方式（硬链接）" class="headerlink" title="基于索引节点的共享方式（硬链接）"></a>基于索引节点的共享方式（硬链接）</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002145418428.png" alt="image-20221002145418428"></p><h3 id="基于符号链的共享方式（软链接）快捷方式"><a href="#基于符号链的共享方式（软链接）快捷方式" class="headerlink" title="基于符号链的共享方式（软链接）快捷方式"></a>基于符号链的共享方式（软链接）<del>快捷方式</del></h3><blockquote><p>快捷方式（存放了从别的用户下的路径，然后一层一层去找）</p><p>所以软链接访问速度没有硬链接快</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002145548694.png" alt="image-20221002145548694"><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002145721281.png" alt="image-20221002145721281"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002145909542.png" alt="image-20221002145909542"></p><h3 id="总结-41"><a href="#总结-41" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002150213187.png" alt="image-20221002150213187"></p><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><h3 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002150918286.png" alt="image-20221002150918286"></p><h3 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002151122928.png" alt="image-20221002151122928"></p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002151619056.png" alt="image-20221002151619056"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002151626217.png" alt="image-20221002151626217"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002151730366.png" alt="image-20221002151730366"></p><h3 id="总结-42"><a href="#总结-42" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002152045445.png" alt="image-20221002152045445"></p><h2 id="文件系统的层次结构-以上的汇总"><a href="#文件系统的层次结构-以上的汇总" class="headerlink" title="文件系统的层次结构 以上的汇总"></a>文件系统的层次结构 <del>以上的汇总</del></h2><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002152445520.png" alt="image-20221002152445520"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002152628063.png" alt="image-20221002152628063"></p><ul><li><h4 id="文件句柄"><a href="#文件句柄" class="headerlink" title="文件句柄"></a>文件句柄</h4></li></ul><blockquote><p>用于唯一地描述文件或目录</p></blockquote><ul><li>重要组件<ul><li>卷标识符</li><li>inode号</li><li>世代号</li></ul></li></ul><h2 id="崩溃一致性：FSCK和日志"><a href="#崩溃一致性：FSCK和日志" class="headerlink" title="崩溃一致性：FSCK和日志"></a>崩溃一致性：FSCK和日志</h2><blockquote><p>p380 </p></blockquote><h2 id="日志结构文件系统（LFS）"><a href="#日志结构文件系统（LFS）" class="headerlink" title="日志结构文件系统（LFS）"></a>日志结构文件系统（LFS）</h2><blockquote><p>Log-structured File System</p><p>copy</p><p>p395</p></blockquote><p><strong>核心</strong>：简单地讲所有更新（例如数据块、inode等）顺序写入（<em>缓存一段再写入</em>）磁盘的这一基本思想。</p><ul><li><p>inode映射解决了LFS中存在的一个问题：递归更新问题（recursive update problem）。</p><ul><li><blockquote><p>任何永远不会原地更新的文件系统（例如LFS）都会遇到该问题，它们将更新移到新位置。</p></blockquote></li><li><p>递归更新问题</p><ul><li>每当更新inode时，它在磁盘上的位置都会发生变化。如果我们不小心，这也会导致对指向该文件的目录的更新，然后必须更改该目录的父目录，一次类推，一路沿文件系统树向上。</li></ul></li><li><p>LFS巧妙地避免了inode映射地这个问题。即使inode地位置可能会发生变化，更改也不会反映在目录本身。事实上，imap结构被更新，而目录保持相同地名称到inumber地映射。因此，通过间接，LFS避免了递归更新问题。</p></li></ul></li><li><p>版本记录</p><ul><li>更新的文件不会覆盖旧文件</li><li>需要定期清理这些旧文件</li></ul></li></ul><p><strong>LSE</strong></p><blockquote><p>p407</p></blockquote><h2 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h2><h3 id="磁盘、磁道、扇区"><a href="#磁盘、磁道、扇区" class="headerlink" title="磁盘、磁道、扇区"></a>磁盘、磁道、扇区</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002155230769.png" alt="image-20221002155230769"></p><h3 id="如何在磁盘中读数据"><a href="#如何在磁盘中读数据" class="headerlink" title="如何在磁盘中读数据"></a>如何在磁盘中读数据</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002155334555.png" alt="image-20221002155334555"></p><h3 id="磁盘的物理地址"><a href="#磁盘的物理地址" class="headerlink" title="磁盘的物理地址"></a>磁盘的物理地址</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002155630315.png" alt="image-20221002155630315"></p><h3 id="磁盘的分类"><a href="#磁盘的分类" class="headerlink" title="磁盘的分类"></a>磁盘的分类</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002155722939.png" alt="image-20221002155722939"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002155744610.png" alt="image-20221002155744610"></p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li>顺序的使用磁盘<ul><li>尽可能以顺序方式将数据传输到磁盘，并从磁盘传输数据。如果顺序不可行，至少考虑以大块传输数据：越大越好。如果I&#x2F;O是以小而随机的方式完成的，则I&#x2F;O性能将受到显著的影响。</li></ul></li></ul><h3 id="总结-43"><a href="#总结-43" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002155808290.png" alt="image-20221002155808290"></p><h2 id="磁盘调度算法-寻道时间"><a href="#磁盘调度算法-寻道时间" class="headerlink" title="磁盘调度算法 寻道时间"></a>磁盘调度算法 <del>寻道时间</del></h2><h3 id="一次磁盘读-写操作需要的时间"><a href="#一次磁盘读-写操作需要的时间" class="headerlink" title="一次磁盘读&#x2F;写操作需要的时间"></a>一次磁盘读&#x2F;写操作需要的时间</h3><blockquote><p>平均寻道时间是完整时间的1&#x2F;3——证明：p320（积分）</p></blockquote><img src="操作系统(王道+操作系统导论).assets/image-20221002160742415.png" alt="image-20221002160742415" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221002160759249.png" alt="image-20221002160759249" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221002160919375.png" alt="image-20221002160919375" style="zoom:50%;" /><ul><li><p><strong>延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间</strong></p></li><li><p><strong>但是操作系统的磁盘调度算法会影响寻道时间</strong></p></li></ul><h3 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002161536129.png" alt="image-20221002161536129"></p><h3 id="最短寻找时间优先算法（SSTF）"><a href="#最短寻找时间优先算法（SSTF）" class="headerlink" title="最短寻找时间优先算法（SSTF）"></a>最短寻找时间优先算法（SSTF）</h3><blockquote><p>问题：主机操作系统无法利用驱动器的几何结构而只会看到一系列块。</p><p>解决：操作系统可以简单地实现最近快优先（Nearest-Block-First,NBF）,而不是SSTF，然后用最近的快地址来调度请求</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002161923907.png" alt="image-20221002161923907"></p><h3 id="最短定位时间优先（SPTF）"><a href="#最短定位时间优先（SPTF）" class="headerlink" title="最短定位时间优先（SPTF）"></a>最短定位时间优先（SPTF）</h3><blockquote><p>Shortest Positioning Time First</p></blockquote><ul><li>考虑旋转时间和寻道时间的相对时间来判断要移到哪里</li></ul><h3 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h3><blockquote><p>SSTF算法会产生饥饿现象的原因在于：磁头有可能在一个小区域内来回来去地移动。</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002162200751.png" alt="image-20221002162200751"></p><h3 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h3><blockquote><p>解决扫描算法的第一个缺点</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002162423221.png" alt="image-20221002162423221"></p><h3 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h3><blockquote><p>解决扫描算法的第二个缺点</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002162812459.png" alt="image-20221002162812459"></p><h3 id="C-LOOK算法"><a href="#C-LOOK算法" class="headerlink" title="C-LOOK算法"></a>C-LOOK算法</h3><blockquote><p>解决C-SCAN的缺点</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002162927181.png" alt="image-20221002162927181"></p><h3 id="其他调度问题"><a href="#其他调度问题" class="headerlink" title="其他调度问题"></a>其他调度问题</h3><ul><li>在早期的操作系统中<ul><li>操作系统完成了所有的调度</li></ul></li><li>在现代操作系统中<ul><li>磁盘可以接受多个分离的请求，它们本身具有复杂的调度程序（它们可以准确地实现SPFT）</li></ul></li><li>磁盘调度程序执行的另外一个重要的相关任务是&#x3D;&#x3D;I&#x2F;O合并&#x3D;&#x3D;（I&#x2F;O merging）<ul><li>例如：假设一系列请求读取块33，然后是8，然后是34。这种情况下，调度程序应该将33和34的请求合并。</li><li>减少了发送到磁盘的请求数量，从而降低了开销</li></ul></li></ul><h3 id="总结-44"><a href="#总结-44" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002163052962.png" alt="image-20221002163052962"></p><h2 id="减少延迟时间的方法"><a href="#减少延迟时间的方法" class="headerlink" title="减少延迟时间的方法"></a>减少<del>延迟时间</del>的方法</h2><blockquote><p>延迟时间：将目标扇区转到磁头下面所花的时间</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002163520340.png" alt="image-20221002163520340"></p><h3 id="交换编号-相同磁盘号下"><a href="#交换编号-相同磁盘号下" class="headerlink" title="交换编号 相同磁盘号下"></a>交换编号 <del>相同磁盘号下</del></h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002163712315.png" alt="image-20221002163712315"></p><h3 id="磁道缓冲区"><a href="#磁道缓冲区" class="headerlink" title="磁道缓冲区"></a>磁道缓冲区</h3><blockquote><p> 现代磁盘更加智能：它们在内部读取整个磁道并将其缓冲在内部磁盘的缓冲中（由于这个原因，通常称为磁道缓冲区，tracker buffer）。然后，在对轨道后续的读取中，磁盘就从前高速缓存中返回所需数据。</p></blockquote><h3 id="错位命名-不同磁盘号下"><a href="#错位命名-不同磁盘号下" class="headerlink" title="错位命名 不同磁盘号下"></a>错位命名 <del>不同磁盘号下</del></h3><h4 id="背景知识：磁盘地址结构的设计"><a href="#背景知识：磁盘地址结构的设计" class="headerlink" title="背景知识：磁盘地址结构的设计"></a>背景知识：磁盘地址结构的设计</h4><blockquote><p>二者在读取相邻地址时的优劣</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002164026844.png" alt="image-20221002164026844"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002164234238.png" alt="image-20221002164234238"></p><img src="操作系统(王道+操作系统导论).assets/image-20221002164335218.png" alt="image-20221002164335218" style="zoom:50%;" /><h4 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002165114374.png" alt="image-20221002165114374"></p><hr><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002165046955.png" alt="image-20221002165046955"></p><h3 id="总结-45"><a href="#总结-45" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002165447801.png" alt="image-20221002165447801"></p><h2 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h2><h3 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002171644188.png" alt="image-20221002171644188"></p><h3 id="数据完整性和保护"><a href="#数据完整性和保护" class="headerlink" title="数据完整性和保护"></a>数据完整性和保护</h3><h4 id="检测讹误：检验吗"><a href="#检测讹误：检验吗" class="headerlink" title="检测讹误：检验吗"></a>检测讹误：检验吗</h4><h5 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h5><blockquote><p>是&#x3D;&#x3D;数据通信领域（只要是数据传输，计算机内部，端到端等）&#x3D;&#x3D;常用的一种数据传输检错技术，通过在发送端对数据按照某种算法计算出校验码，并将得到的校验码附在数据帧的后面，一起发送到接收端。接收端对收到的数据和校验码按照相同算法进行验证，以此判断接收到的数据是否正确、完整。</p></blockquote><h5 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h5><p><a href="https://baike.baidu.com/item/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C/8090811">奇偶校验码详解</a></p><ul><li><p>磁盘扇区校验和的一种形式是基于扇区内所有二进制位的奇偶性。</p></li><li><p>如果所有二进制位中的1的个数为奇数，比如11001，则在其后面增加值为1的奇偶位，变成110011；如果所有二进制位中的1的个数为偶数，比如11000，则在其后面增加值为0的奇偶位，变成110000，这样使得整个扇区的二进制位中的1的个数为偶数。</p></li><li><p>如果扇区中有奇数位出错，则我们能检验出来，如果扇区中有偶数位出错，则我们检验不出来。也就是说，如果磁盘扇区出现了错误，我们有1&#x2F;2的可能性能检验不出来。</p></li><li><p>增加奇偶校验位数能提高检验出错误的概率。</p></li><li><p>如果有两位校验位，第一位检验扇区的每一个字节的奇数位，第二位检验扇区的每个字节的偶数位，我们可以看成：每一个校验位检验一半扇区，那么每一个校验为检验不出错误的概率是1&#x2F;2，两个校验位检验不出错误的概率就是1&#x2F;4.</p></li><li><p>如果一个扇区（假设有4096个字节）用4个字节作为检验码（32位校验位），那么只有40亿分之一的可能性检验不出错误。</p></li><li><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li>奇偶校验是在通信过程中确保节点之间准确数据传输的过程。奇偶校验位<strong>附加到原始数据位以创建偶数&#x3D;&#x3D;或&#x3D;&#x3D;奇数位</strong>。内存中最小的单位是比特，也称为“位”，位只有两种状态分别以1和0来标示，每8个连续的比特叫做一个字节（byte）。不带奇偶校验的内存每个字节只有8位，如果其某一位存储了错误的值，就会导致其存储的相应数据发生变化，进而导致应用程序发生错误。而奇偶校验就是在每一字节（8位）之外又增加了一位作为错误检测位。在某字节中存储数据之后，在其8个位上存储的数据是固定的，因为位只能有两种状态1或0，假设存储的数据用位标示为1、1、1、0、0、1、0、1，那么把每个位相加（1+1+1+0+0+1+0+1&#x3D;5），结果是奇数。对于偶校验，校验位就定义为1；对于奇校验，则相反。<em><em>当CPU读取存储的数据时，它会&#x3D;&#x3D;再次&#x3D;&#x3D;把前8位中存储的数据相加，计算结果&#x3D;&#x3D;是否与校验位相一致&#x3D;&#x3D;<strong>。从而一定程度上能检测出内存错误，奇偶校验</strong></em>只能检测出错误而无法对其进行修正</em><strong>，</strong>同时虽然双位同时发生错误的概率相当低，但奇偶校验却&#x3D;&#x3D;无法&#x3D;&#x3D;检测出双位错误。**</li></ul></li><li><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>奇偶校验有两种类型：奇校验和偶校验。奇偶校验位是一个表示给定位数的二进制数中1的个数是奇数或者偶数的二进制数，奇偶校验位是<strong>最简单的错误检测码</strong>。如果传输过程中包括校验位在内的奇数个数据位发生改变，那么奇偶校验位将出错表示传输过程有错误发生。因此，<strong>奇偶校验位是一种错误检测码，但是由于没有办法确定哪一位出错，所以它不能进行错误校正</strong>。**发生错误时必须&#x3D;&#x3D;扔掉全部的数据&#x3D;&#x3D;，然后&#x3D;&#x3D;从头开始传输数据&#x3D;&#x3D;**。在噪声很多的媒介上成功传输数据可能要花费很长的时间，甚至根本无法实现。但是奇偶校验位也有它的优点，它是使用一位数据能够达到的最好的校验码，并且它仅仅需要一些异或门就能够生成。奇偶校验被广泛应用。</li></ul></li></ul><h5 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h5><blockquote><p>异或</p><p>直接加法，忽略溢出</p><p>Fletcher校验</p></blockquote><h5 id="循环冗余校验（CRC）"><a href="#循环冗余校验（CRC）" class="headerlink" title="循环冗余校验（CRC）"></a>循环冗余校验（CRC）</h5><blockquote><p>假设你希望计算数据块D的校验和。你所做的只是将D视为一个很大的二进制数并将其除以约定的值（k）。该除法的其余部分是CRC的值。</p></blockquote><h5 id="校验和布局"><a href="#校验和布局" class="headerlink" title="校验和布局"></a>校验和布局</h5><blockquote><p>如何将校验和存储到磁盘上</p></blockquote><ul><li>每个磁盘扇区（或块）存储校验和</li><li>驱动器制造商采用的一种方法是使用520字节扇区格式化驱动器，每个扇区额外的8个字节可用于存储校验和<ul><li>缺点是，假设要覆盖某个扇区（或块）时，需要执行<strong>两次</strong>写操作</li></ul></li></ul><h4 id="讹误：错误的写入"><a href="#讹误：错误的写入" class="headerlink" title="讹误：错误的写入"></a>讹误：错误的写入</h4><blockquote><p>写入磁盘成功，但是写入的位置错了</p></blockquote><ul><li>只需要对比要访问的块，与实际访问的块的信息做对比就可以看出是否出现错误的写入</li></ul><h4 id="讹误：丢失的写入"><a href="#讹误：丢失的写入" class="headerlink" title="讹误：丢失的写入"></a>讹误：丢失的写入</h4><blockquote><p>在写数据时，实际没有完成写入，但是向上层汇报写入（假设），磁盘上留下的时该块的旧内容，而不是更新的新内容。</p><p>旧块很可能具有匹配的校验和，上面使用的物理ID（磁盘号和块偏移都是正确的）。</p></blockquote><ul><li>解决<ul><li>写入后立即读数据，看是否写入<ul><li>I&#x2F;O翻倍</li></ul></li><li>在其他位置添加校验和，以检测丢失的写入</li><li>只有当inode和数据的写入都丢失时才会失败（不太可能）</li></ul></li></ul><h3 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002171817345.png" alt="image-20221002171817345"></p><ul><li><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a><strong>解决</strong></h4></li></ul><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002172032235.png" alt="image-20221002172032235"></p><h3 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002172808526.png" alt="image-20221002172808526"></p><h3 id="廉价冗余磁盘阵列（RAID）"><a href="#廉价冗余磁盘阵列（RAID）" class="headerlink" title="廉价冗余磁盘阵列（RAID）"></a>廉价冗余磁盘阵列（RAID）</h3><p>资源：<a href="https://zhuanlan.zhihu.com/p/51170719">RAID详解</a></p><blockquote><p>书p326</p></blockquote><h3 id="总结-46"><a href="#总结-46" class="headerlink" title="总结"></a>总结</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221002172836454.png" alt="image-20221002172836454"></p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="I-O设备的概念个分类"><a href="#I-O设备的概念个分类" class="headerlink" title="I&#x2F;O设备的概念个分类"></a>I&#x2F;O设备的概念个分类</h2><h3 id="什么是I-O设备"><a href="#什么是I-O设备" class="headerlink" title="什么是I&#x2F;O设备"></a>什么是I&#x2F;O设备</h3><blockquote><p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003093009237.png" alt="image-20221003093009237"></p><ul><li>站在操作系统的视角（my understanding）</li></ul><h3 id="I-O设备的分类"><a href="#I-O设备的分类" class="headerlink" title="I&#x2F;O设备的分类"></a>I&#x2F;O设备的分类</h3><h4 id="按使用特性"><a href="#按使用特性" class="headerlink" title="按使用特性"></a>按使用特性</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003093131867.png" alt="image-20221003093131867"></p><h4 id="按传输速率分类"><a href="#按传输速率分类" class="headerlink" title="按传输速率分类"></a>按传输速率分类</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003093801632.png" alt="image-20221003093801632"></p><h4 id="按信息交换方式分类"><a href="#按信息交换方式分类" class="headerlink" title="按信息交换方式分类"></a>按信息交换方式分类</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003093852378.png" alt="image-20221003093852378"></p><h3 id="总结-47"><a href="#总结-47" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003093905347.png" alt="image-20221003093905347"></p><h2 id="I-O控制器-硬件层"><a href="#I-O控制器-硬件层" class="headerlink" title="I&#x2F;O控制器 硬件层"></a>I&#x2F;O控制器 <del>硬件层</del></h2><h3 id="I-O的机械硬件"><a href="#I-O的机械硬件" class="headerlink" title="I&#x2F;O的机械硬件"></a>I&#x2F;O的机械硬件</h3><blockquote><p>磁盘等</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003094122353.png" alt="image-20221003094122353"></p><h3 id="I-O设备的电子部件-I-O控制器"><a href="#I-O设备的电子部件-I-O控制器" class="headerlink" title="I&#x2F;O设备的电子部件 I&#x2F;O控制器"></a>I&#x2F;O设备的电子部件 <del>I&#x2F;O控制器</del></h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003094356186.png" alt="image-20221003094356186"></p><h3 id="I-O控制器的组成"><a href="#I-O控制器的组成" class="headerlink" title="I&#x2F;O控制器的组成"></a>I&#x2F;O控制器的组成</h3><blockquote><p>寄存器一般会有很多个</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003094713307.png" alt="image-20221003094713307"></p><img src="操作系统(王道+操作系统导论).assets/image-20221003094829722.png" alt="image-20221003094829722"  /><h3 id="内存映像I-O-v-s-寄存器独立编址"><a href="#内存映像I-O-v-s-寄存器独立编址" class="headerlink" title="内存映像I&#x2F;O v.s. 寄存器独立编址"></a>内存映像I&#x2F;O v.s. 寄存器独立编址</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003095048123.png" alt="image-20221003095048123"></p><h3 id="总结-48"><a href="#总结-48" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003095211065.png" alt="image-20221003095211065"></p><h2 id="I-O控制方式-硬件层"><a href="#I-O控制方式-硬件层" class="headerlink" title="I&#x2F;O控制方式 硬件层"></a>I&#x2F;O控制方式 <del>硬件层</del></h2><blockquote><p>用什么样的方式来控制I&#x2F;O设备的数据读&#x2F;写</p></blockquote><h3 id="程序直接控制方式poll轮询"><a href="#程序直接控制方式poll轮询" class="headerlink" title="程序直接控制方式poll轮询"></a>程序直接控制方式<del>poll轮询</del></h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003095636773.png" alt="image-20221003095636773"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003100218826.png" alt="image-20221003100218826"></p><h4 id="其中为什么要放入存储器内存"><a href="#其中为什么要放入存储器内存" class="headerlink" title="其中为什么要放入存储器内存"></a>其中为什么要放入存储器<del>内存</del></h4><img src="操作系统(王道+操作系统导论).assets/image-20221003100013393.png" alt="image-20221003100013393" style="zoom:50%;" /><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><blockquote><p>解决程序直接控制方式中CPU和I&#x2F;O设备不能并行的问题</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003100359381.png" alt="image-20221003100359381"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003100509853.png" alt="image-20221003100509853"></p><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><blockquote><p>解决中断驱动方式因为传输量小，需要经过CPU，导致&#x3D;&#x3D;频繁&#x3D;&#x3D;中断处理，会花费大量时间的问题</p><p>进一步提升并行性</p><p>每次读写只能是连续的块，且这些块读入内存后在内存中也必须是连续的</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003100841420.png" alt="image-20221003100841420"></p><h4 id="DMA控制器-一种I-O控制器"><a href="#DMA控制器-一种I-O控制器" class="headerlink" title="DMA控制器 一种I&#x2F;O控制器"></a>DMA控制器 <del>一种I&#x2F;O控制器</del></h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003101446297.png" alt="image-20221003101446297"></p><h4 id="DMA方式-1"><a href="#DMA方式-1" class="headerlink" title="DMA方式"></a>DMA方式</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003101731976.png" alt="image-20221003101731976"></p><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><blockquote><p>解决DMA方式中：CPU每发出一条I&#x2F;O指令，只能读&#x2F;写一个或多个&#x3D;&#x3D;连续&#x3D;&#x3D;的数据块</p><p>通道：一种&#x3D;&#x3D;硬件&#x3D;&#x3D;，可以理解为是“&#x3D;&#x3D;弱鸡版的CPU&#x3D;&#x3D;”。通道可以识别并执行一系列通道指令</p><p>一个通道（<em>弱鸡版CPU</em>）可以控制多个I&#x2F;O控制器，一个I&#x2F;O控制器可以控制多个I&#x2F;O设备</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003102242307.png" alt="image-20221003102242307"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003102506737.png" alt="image-20221003102506737"></p><h3 id="总结-49"><a href="#总结-49" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003102905358.png" alt="image-20221003102905358"></p><h2 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I&#x2F;O软件层次结构"></a>I&#x2F;O<del>软件层次</del>结构</h2><h3 id="知识总览-5"><a href="#知识总览-5" class="headerlink" title="知识总览"></a>知识总览</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003103202415.png" alt="image-20221003103202415"></p><h3 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h3><blockquote><p>第一章有讲到系统调用</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003103900764.png" alt="image-20221003103900764"></p><h3 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h3><img src="操作系统(王道+操作系统导论).assets/image-20221003104450849.png" alt="image-20221003104450849" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221003104529746.png" alt="image-20221003104529746" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221003104548319.png" alt="image-20221003104548319" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221003104610817.png" alt="image-20221003104610817" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221003104625154.png" alt="image-20221003104625154" style="zoom:50%;" /><ul><li>给下层</li></ul><img src="操作系统(王道+操作系统导论).assets/image-20221003104653554.png" alt="image-20221003104653554" style="zoom:50%;" /><ul><li><h3 id="逻辑设备表（LUT表）Logical-Unit-Table"><a href="#逻辑设备表（LUT表）Logical-Unit-Table" class="headerlink" title="逻辑设备表（LUT表）Logical Unit Table"></a>逻辑设备表（LUT表）<del>Logical</del> <del>Unit</del> <del>Table</del></h3></li></ul><img src="操作系统(王道+操作系统导论).assets/image-20221003104745475.png" alt="image-20221003104745475" style="zoom:50%;" /><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><blockquote><p>和中断处理程序一样需要与硬件打交道</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003104831098.png" alt="image-20221003104831098"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003105001502.png" alt="image-20221003105001502"></p><h3 id="中断处理程序-第一章讲过"><a href="#中断处理程序-第一章讲过" class="headerlink" title="中断处理程序 第一章讲过"></a>中断处理程序 <del>第一章讲过</del></h3><blockquote><p>此处是I&#x2F;O下的中断处理</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003105705363.png" alt="image-20221003105705363"></p><h3 id="总结-50"><a href="#总结-50" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003105943127.png" alt="image-20221003105943127"></p><h2 id="I-O核心子系统-设备独立软件中功能具体实现"><a href="#I-O核心子系统-设备独立软件中功能具体实现" class="headerlink" title="I&#x2F;O核心子系统 设备独立软件中功能具体实现"></a>I&#x2F;O核心子系统 <del>设备独立软件中功能具体实现</del></h2><h3 id="知识总览-6"><a href="#知识总览-6" class="headerlink" title="知识总览"></a>知识总览</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003110239276.png" alt="image-20221003110239276"></p><ul><li><h3 id="注意-：假脱机技术（SPOOLing技术）是用户层实现的功能"><a href="#注意-：假脱机技术（SPOOLing技术）是用户层实现的功能" class="headerlink" title="&#x3D;&#x3D;注意&#x3D;&#x3D;：假脱机技术（SPOOLing技术）是用户层实现的功能"></a>&#x3D;&#x3D;注意&#x3D;&#x3D;：<strong>假脱机技术（SPOOLing技术）是用户层实现的功能</strong></h3></li></ul><h3 id="I-O调度"><a href="#I-O调度" class="headerlink" title="I&#x2F;O调度"></a>I&#x2F;O调度</h3><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003110756033.png" alt="image-20221003110756033"></p><h3 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h3><blockquote><p>与文件保护类似，可以将设备看做成特殊的文件</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003110942233.png" alt="image-20221003110942233"></p><h3 id="假脱机技术-用户层实现的"><a href="#假脱机技术-用户层实现的" class="headerlink" title="假脱机技术 用户层实现的"></a>假脱机技术 <del>用户层实现的</del></h3><h4 id="什么是-脱机技术"><a href="#什么是-脱机技术" class="headerlink" title="什么是 脱机技术"></a>什么是 脱机技术</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003111615435.png" alt="image-20221003111615435"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003111729333.png" alt="image-20221003111729333"></p><h4 id="假脱机技术原理"><a href="#假脱机技术原理" class="headerlink" title="假脱机技术原理"></a>假脱机技术原理</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003112041222.png" alt="image-20221003112041222"></p><ul><li><h4 id="输入进程、输出进程：类似于-外围控制机"><a href="#输入进程、输出进程：类似于-外围控制机" class="headerlink" title="输入进程、输出进程：类似于&#x3D;&#x3D;外围控制机&#x3D;&#x3D;"></a>输入进程、输出进程：类似于&#x3D;&#x3D;外围控制机&#x3D;&#x3D;</h4></li><li><h4 id="输入井、输出井：类似于-磁带"><a href="#输入井、输出井：类似于-磁带" class="headerlink" title="输入井、输出井：类似于&#x3D;&#x3D;磁带&#x3D;&#x3D;"></a>输入井、输出井：类似于&#x3D;&#x3D;磁带&#x3D;&#x3D;</h4></li></ul><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003112343581.png" alt="image-20221003112343581"></p><h4 id="共享打印机原理-假脱机技术的应用"><a href="#共享打印机原理-假脱机技术的应用" class="headerlink" title="共享打印机原理 假脱机技术的应用"></a>共享打印机原理 <del>假脱机技术的应用</del></h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003112729050.png" alt="image-20221003112729050"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003112852041.png" alt="image-20221003112852041"></p><h4 id="总结-51"><a href="#总结-51" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003112911867.png" alt="image-20221003112911867"></p><h3 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h3><h4 id="设备分配时需要考虑的因素"><a href="#设备分配时需要考虑的因素" class="headerlink" title="设备分配时需要考虑的因素"></a>设备分配时需要考虑的因素</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003113546769.png" alt="image-20221003113546769"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003113534250.png" alt="image-20221003113534250"></p><img src="操作系统(王道+操作系统导论).assets/image-20221003113712016.png" alt="image-20221003113712016" style="zoom:50%;" /><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003113853740.png" alt="image-20221003113853740"></p><h4 id="静态分配和动态分配"><a href="#静态分配和动态分配" class="headerlink" title="静态分配和动态分配"></a>静态分配和动态分配</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003114332920.png" alt="image-20221003114332920"></p><h4 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h4><blockquote><p>可以有多个通道</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003114442036.png" alt="image-20221003114442036"></p><h5 id="设备控制表（DCT）"><a href="#设备控制表（DCT）" class="headerlink" title="设备控制表（DCT）"></a>设备控制表（DCT）</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003114633328.png" alt="image-20221003114633328"></p><h5 id="控制器控制表（COCT）"><a href="#控制器控制表（COCT）" class="headerlink" title="控制器控制表（COCT）"></a>控制器控制表（COCT）</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003114759252.png" alt="image-20221003114759252"></p><h5 id="通道控制表（CHCT）"><a href="#通道控制表（CHCT）" class="headerlink" title="通道控制表（CHCT）"></a>通道控制表（CHCT）</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003115033462.png" alt="image-20221003115033462"></p><h5 id="系统设备表（SDT）"><a href="#系统设备表（SDT）" class="headerlink" title="系统设备表（SDT）"></a>系统设备表（SDT）</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003115131555.png" alt="image-20221003115131555"></p><h4 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003115221542.png" alt="image-20221003115221542"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003115304051.png" alt="image-20221003115304051"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003115349344.png" alt="image-20221003115349344"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003115409750.png" alt="image-20221003115409750"></p><img src="操作系统(王道+操作系统导论).assets/image-20221003115513332.png" alt="image-20221003115513332" style="zoom:50%;" /><h4 id="设备分配的步骤改进"><a href="#设备分配的步骤改进" class="headerlink" title="设备分配的步骤改进"></a>设备分配的步骤改进</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003115716981.png" alt="image-20221003115716981"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003115844682.png" alt="image-20221003115844682"></p><h4 id="总结-52"><a href="#总结-52" class="headerlink" title="总结"></a>总结</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003120131276.png" alt="image-20221003120131276"></p><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><h4 id="什么是缓冲区？有什么作用？"><a href="#什么是缓冲区？有什么作用？" class="headerlink" title="什么是缓冲区？有什么作用？"></a>什么是缓冲区？有什么作用？</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003120430946.png" alt="image-20221003120430946"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003120736182.png" alt="image-20221003120736182"></p><h4 id="缓冲区管理策略"><a href="#缓冲区管理策略" class="headerlink" title="缓冲区管理策略"></a>缓冲区管理策略</h4><h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003121016091.png" alt="image-20221003121016091"></p><h6 id="计算每处理一块数据平均需要多少时间"><a href="#计算每处理一块数据平均需要多少时间" class="headerlink" title="计算每处理一块数据平均需要多少时间"></a>计算每处理一块数据平均需要多少时间</h6><ul><li><h4 id="T-C"><a href="#T-C" class="headerlink" title="T&gt;C"></a>T&gt;C</h4></li></ul><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003121154081.png" alt="image-20221003121154081"></p><ul><li><h4 id="T"><a href="#T" class="headerlink" title="T&lt;C"></a>T&lt;C</h4></li></ul><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003121442512.png" alt="image-20221003121442512"></p><h6 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h6><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003121508518.png" alt="image-20221003121508518"></p><h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003121659988.png" alt="image-20221003121659988"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003122006828.png" alt="image-20221003122006828"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003122024719.png" alt="image-20221003122024719"></p><h5 id="使用单-双缓冲策略在通信时的区别"><a href="#使用单-双缓冲策略在通信时的区别" class="headerlink" title="使用单&#x2F;双缓冲策略在通信时的区别"></a>使用单&#x2F;双缓冲策略在<del>通信时</del>的区别</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003122155154.png" alt="image-20221003122155154"></p><h6 id="管道通信中的管道就是缓冲区"><a href="#管道通信中的管道就是缓冲区" class="headerlink" title="管道通信中的管道就是缓冲区"></a>管道通信中的管道就是缓冲区</h6><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003122232399.png" alt="image-20221003122232399"></p><h5 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003122442325.png" alt="image-20221003122442325"></p><h5 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h5><blockquote><p> 一堆缓冲放一起</p></blockquote><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003123007099.png" alt="image-20221003123007099"></p><img src="操作系统(王道+操作系统导论).assets/image-20221003122932602.png" alt="image-20221003122932602" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221003123047057.png" alt="image-20221003123047057" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221003123102868.png" alt="image-20221003123102868" style="zoom:50%;" /><img src="操作系统(王道+操作系统导论).assets/image-20221003123117175.png" alt="image-20221003123117175" style="zoom:50%;" /><h5 id="总结-53"><a href="#总结-53" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h5><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E7%8E%8B%E9%81%93+%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA).assets/image-20221003123159300.png" alt="image-20221003123159300"></p><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><blockquote><p>p419</p></blockquote><h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><ul><li>丢包现象<ul><li>路由器或者某台机器同时接收了大量的数据，其内存无法容纳所有的数据包，唯一的选择就是丢弃(drop)一个或多个数据包</li><li>丢包现象时网络的基本现象。</li></ul></li></ul><h2 id="不可靠的通信层"><a href="#不可靠的通信层" class="headerlink" title="不可靠的通信层"></a>不可靠的通信层</h2><blockquote><p>UDP&#x2F;IP网络栈</p></blockquote><ul><li>要使用UDP，进程使用套接字(socket)API来创建通信端点（communication endpoint）。其他机器（或同一台机器上）的进程将UDP数据报（datagram）发送到前面的进程（数据报是一个固定大小的消息，有最大大小）</li></ul><h2 id="可靠的通信层"><a href="#可靠的通信层" class="headerlink" title="可靠的通信层"></a>可靠的通信层</h2><blockquote><p>TCP&#x2F;IP</p></blockquote><ul><li>确认</li><li>发送方在第一发送时超时，再发一次。假设接收方两次都接收到了，接收方需避免因重复接收消息而重复发送文件</li></ul><h2 id="通信抽象"><a href="#通信抽象" class="headerlink" title="通信抽象"></a>通信抽象</h2><ul><li>基于多个端系统的虚拟内存</li><li>DSM系统——难以构建可靠的分布式系统</li></ul><p>​</p><h2 id="远程过程调用（RPC）"><a href="#远程过程调用（RPC）" class="headerlink" title="远程过程调用（RPC）"></a>远程过程调用（RPC）</h2><blockquote><p>简单的目标：使在远程机器上执行代码的过程像调用本地函数一样简单直接。因此对客户端来说，进行一个过程调用，并在一段时间后返回结果。服务器只是定义了一些它希望导出的例程。其余的由RPC系统处理，RPC系统通常由两部分：存根生成器（stub generator，有时称为协议编译器，protocol complier）和运行时库（run-time library）。</p></blockquote><ul><li>存根寄存器<ul><li>一系列操作<ul><li>创建消息缓冲区</li><li>将所需信息打包到消息缓冲区中</li><li>将消息发送到目标RPC服务器</li><li>等待回复</li><li>解包返回代码和其他参数</li><li>返回调用者</li><li>解包信息</li><li>调用实际函数</li><li>打包结果</li><li>发送回复</li></ul></li></ul></li><li>运行时库<ul><li>处理RPC系统中的大部分繁重的工作</li><li>例如：处理大多数性能和可靠性问题</li></ul></li><li>其他问题<ul><li>机器之间可能存在不同的字节序（大端序，小端序）</li><li>是否向客户端暴露通信的异步性质</li></ul></li></ul><h1 id="Sun的网络文件系统（NFS）"><a href="#Sun的网络文件系统（NFS）" class="headerlink" title="Sun的网络文件系统（NFS）"></a>Sun的网络文件系统（NFS）</h1><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记</title>
      <link href="/2023/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（自顶向下）"><a href="#计算机网络（自顶向下）" class="headerlink" title="计算机网络（自顶向下）"></a><a href="https://blog.csdn.net/qq_53111905/category_11228995.html">计算机网络（自顶向下）</a></h1><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20221028084452161.png" alt="image-20221028084452161"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20221028091009574.png" alt="image-20221028091009574"></p><ul><li><h1 id="全球网络技术大会"><a href="#全球网络技术大会" class="headerlink" title="全球网络技术大会"></a>全球网络技术大会</h1></li><li><p>2018-2020打开IPv6</p></li></ul><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20221028093200128.png" alt="image-20221028093200128"></p><p>应用层</p><p>传输层</p><p>网络层</p><p>链路层</p><p>物理层</p><h1 id="第1章：概述"><a href="#第1章：概述" class="headerlink" title="第1章：概述"></a>第1章：概述</h1><img src="计算机网络.assets/image-20220903153137968.png" alt="image-20220903153137968" style="zoom:50%;" /><h2 id="1-1-什么是Internet"><a href="#1-1-什么是Internet" class="headerlink" title="1.1 什么是Internet"></a>1.1 什么是Internet</h2><ul><li><p>网络</p><ul><li>点与边构成（与大小形状无关）</li><li>人际关系网络、蜘蛛网、神经元网络……</li></ul></li><li><p>计算机网络</p><ul><li><p>有联网的计算机构成的系统</p></li><li><p>包含节点</p><ul><li><p>▢主机节点：数据的源，也是数据的目标、工作在&#x3D;&#x3D;链路层&#x3D;&#x3D;</p></li><li><p>○数据交换机点（路由器、交换机）：数据的中转节点、工作在&#x3D;&#x3D;网络层&#x3D;&#x3D;</p></li><li><p>高层负载均衡设配……………</p></li><li><p>不只是硬件设备,还有设备上的操作系统、应用程序……</p></li></ul></li><li><p>边（通信链路）</p><ul><li>接入网络链路：主机连到互联网的链路</li><li>主干链路：路由器间的链路</li></ul></li><li><p>互联网(大写的Internet)</p><ul><li>以TCP&#x2F;IP协议为一簇的网络(普及广泛的网络)</li></ul></li><li><p>其他网络(intrenet内联网)</p><ul><li>比如银行内网,企业内网</li></ul></li></ul></li><li><p>&#x3D;&#x3D;从具体角度&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;协议&#x3D;&#x3D;（对等层的协议、比如：TCP是传输层的一个协议）控制发送和接收信息</p><ul><li><p>协议定义了在两个或多个通信实体之间的&#x3D;&#x3D;报文格式&#x3D;&#x3D;和&#x3D;&#x3D;次序&#x3D;&#x3D;，以及在报文传输和&#x2F;或接收&#x2F;或其他事件方面所采取的&#x3D;&#x3D;动作&#x3D;&#x3D;</p></li><li><img src="计算机网络.assets/image-20220903164552499.png" alt="image-20220903164552499" style="zoom:50%;" />+ 如TCP、IP、HTTP、FTP、PPP</li><li><p>Internet：（网络的网络）</p><ul><li>松散的层次结构，互连的ISP</li></ul></li><li><p>公共Internet vs intranet</p></li><li><p>Internet标准</p><ul><li>RFC：Request for comments</li></ul></li><li><p>IETF：Internet Engineering Task Force</p></li></ul></li><li><p>&#x3D;&#x3D;从服务角度&#x3D;&#x3D;————<em><strong>我的理解</strong></em>：应用层上不同地方的进程通过应用层之下的为其提供通信服务</p><ul><li>使用通信设施进行通信的<strong>分布式应用</strong><ul><li>Web、VoIP、email、分布式游戏、电子商务、社交网络</li><li><strong>即应用层上的进程</strong></li></ul></li><li><strong>通信基础设施</strong>（<em>应用层之下</em>）为apps提供编程接口（API）（通信服务）<ul><li>将发送和接收数据的apps与互联网连接起来</li><li>（传输层）为app应用（应用层）提供服务选择，类似于邮政服务：<ul><li>无连接不可靠服务（UDP）————————————————————————————————</li><li>面向连接的可靠服务（TCP）——————<em><strong>即两个应用进程在通信之前要不要打招呼</strong></em>————————</li></ul></li></ul></li></ul></li><li><p><strong>网络结构</strong></p></li><li><img src="计算机网络.assets/image-20220904151913860.png" alt="image-20220904151913860" style="zoom: 67%;" />+ ==*网络边缘*==  + 主机  + 应用程序（客户端和服务器）+ ==*网络核心*==  + 互联着的路由器  + 网络的网络+ ==*接入网、物理媒体*==  + 有线或无线通信链路</li></ul><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><img src="计算机网络.assets/image-20220904153836769.png" alt="image-20220904153836769" style="zoom:50%;" /><ul><li><strong>端系统</strong>（主机）<ul><li>运行应用程序</li><li>如Web、email</li><li>在“网络的边缘”</li></ul></li><li><strong>客户</strong>&#x2F;<strong>服务器模式</strong>（client&#x2F;server）<ul><li>客户端向服务器请求、接收服务</li><li>如Web浏览器&#x2F;服务器：email客户端&#x2F;服务器</li></ul></li><li><strong>对等</strong>（<strong>peer</strong>-<strong>peer</strong>）<strong>模式</strong>——————我的理解（即是客户端也是服务器）<ul><li>很少（甚至没有）专门的服务器</li><li>如Gnutella、KaZaA、Emule</li></ul></li></ul><h3 id="采用网络设施的面向连接服务"><a href="#采用网络设施的面向连接服务" class="headerlink" title="采用网络设施的面向连接服务"></a>采用网络设施的面向连接服务</h3><ul><li><p>即端系统知道，但是中间的链路不知道</p></li><li><p><strong>目标</strong>：在端系统之间传输数据</p><ul><li>全双工的：即连接双方的进程可以在此连接上同时进行报文收发</li><li><strong>握手</strong>：在数据传输之前做好准备<ul><li>人类协议中：你好、你好</li><li>两个通信主机之间为&#x3D;&#x3D;连接建立状态&#x3D;&#x3D;</li></ul></li><li><strong>TCP</strong>-传输控制协议（Transmission Control Protocol）<ul><li>Internet上面向连接的服务</li></ul></li></ul></li><li><p><strong>TCP</strong>服务（RFC 793）</p><ul><li><strong>可靠地</strong>（<strong>reliable</strong>）、<strong>按顺序地传送数据</strong><ul><li>确认和重传</li></ul></li><li><strong>流量控制</strong><ul><li>协调发送方的发送速度和接收方的接收速度</li><li>发送方不会淹没接收方</li></ul></li><li><strong>拥塞控制</strong><ul><li>当网络拥塞时，发送方降低发送速率</li><li>当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程（客户端或服务器）</li></ul></li><li><strong>不能提供服务</strong><ul><li>时间保证、最小吞吐(保证和安全)</li></ul></li></ul></li><li><p><strong>TCP应用</strong></p><ul><li>HTTP（Web），FTP（文件传送）、Telnet（远程登陆）、SMTP（email）</li></ul></li></ul><h3 id="采用基础设施的无连接服务"><a href="#采用基础设施的无连接服务" class="headerlink" title="采用基础设施的无连接服务"></a>采用基础设施的无连接服务</h3><ul><li><p>即不需要握手</p></li><li><p><strong>目标</strong>：在端系统之间传输数据</p><ul><li>UDP-用户数据报协议（User Datagram Potocol）<ul><li>无连接服务</li></ul></li></ul></li><li><p><strong>UDP</strong>（RFC 768）：</p><ul><li><strong>无连接</strong></li><li><strong>不可靠数据传输</strong></li><li><strong>无流量控制</strong></li><li><strong>无拥塞控制</strong></li></ul></li><li><p><strong>UDP应用</strong></p><ul><li>流媒体、远程会议、DNS、Internet电话</li></ul></li></ul><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><img src="计算机网络.assets/image-20220904181459049.png" alt="image-20220904181459049" style="zoom:67%;" /><ul><li>路由器的网状网络</li></ul><h3 id="基本问题：数据怎样通过网络进行传输？"><a href="#基本问题：数据怎样通过网络进行传输？" class="headerlink" title="基本问题：数据怎样通过网络进行传输？"></a><strong>基本问题：数据怎样通过网络进行传输？</strong></h3><h3 id="1-电路（线路）交换"><a href="#1-电路（线路）交换" class="headerlink" title="1. 电路（线路）交换"></a>1. <strong>电路（线路）交换</strong></h3><ul><li>为每个呼叫预留一条专有电路（&#x3D;&#x3D;需要线路建立的时间&#x3D;&#x3D;）：如电话线</li></ul><img src="计算机网络.assets/image-20220904182647315.png" alt="image-20220904182647315" style="zoom:50%;" /><img src="计算机网络.assets/image-20220904183432486.png" alt="image-20220904183432486" style="zoom:50%;" /><ul><li>&#x3D;&#x3D;怎么分片&#x3D;&#x3D;</li></ul><img src="计算机网络.assets/image-20220904183552834.png" alt="image-20220904183552834" style="zoom:50%;" /><ul><li><strong>电路交换网络中的复用</strong><ul><li>频分复用</li><li>时分复用</li></ul></li></ul><img src="计算机网络.assets/image-20220904184440839.png" alt="image-20220904184440839" style="zoom:50%;" /><ul><li><p><strong>电路交换不适合计算机之间的通信</strong></p></li><li><p>连接建立时间长</p></li><li><p>计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多</p><ul><li>即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用</li></ul></li><li><p>可靠性不高？</p></li></ul><h3 id="2-分组交换（hop-to-hop）："><a href="#2-分组交换（hop-to-hop）：" class="headerlink" title="2. 分组交换（hop to hop）："></a>2. <strong>分组交换</strong>（hop to hop）：</h3><ul><li>将要传送的数据分成一个一个单位：分组</li><li>将分组从一个路由器传到相邻路由器（hop）（<em>相邻路由之间要前面的先把packet完全存储在转发给下一个——<strong>实现共享</strong></em>），一段段最终从源端传到目标端</li><li>每段：采用链路的最大传输能力（带宽）</li></ul><img src="计算机网络.assets/image-20220904185400782.png" alt="image-20220904185400782" style="zoom:67%;" /><ul><li><p><strong>交换机</strong></p><ul><li>主要有两类：<strong>路由器</strong>，<strong>链路层交换机</strong></li></ul></li><li><p><strong>以分组为单位存储</strong>-<strong>转发方式</strong></p><ul><li>网络带宽资源不在分为一个个片（与电路交换相比），传输时使用全部带宽</li><li>主机之间传输的数据被分为一个个分组</li></ul></li><li><p><strong>资源共享</strong>，&#x3D;&#x3D;<strong>按需使用</strong>&#x3D;&#x3D;</p><ul><li>存储-转发：分组每次移动一跳（hop）<ul><li>再转发之前，节点必须收到整个分组</li><li>延迟比线路交换要大</li><li>排队和延迟（&#x3D;&#x3D;<em>换取了共享性</em>&#x3D;&#x3D;）<ul><li>如果到达速率（输入路由器）&gt;链路的传输速率（路由器输出）<ul><li>分组会<strong>排队</strong>，等待传输</li><li>如果路由器的缓存用完了，分组会被抛弃——&gt;&#x3D;&#x3D;1.6 分组延时、丢失和吞吐量&#x3D;&#x3D;</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>统计多路复用</strong>（一种分片的方式<del>与电路分组的分别类似</del>）</p><ul><li>类似于分时间片，但与电路分组的不同的是，不会固定线路是某个主机使用，**&#x3D;&#x3D;按时间段&#x3D;&#x3D;**随机分配给不同主机使用</li></ul></li><li><p><strong>分组交换按有没有网络层的连接分为</strong></p><ul><li><strong>数据报网络</strong>——<em>无连接</em>（两个主机在通讯之前不需要握手）<ul><li>分组的目标地址决定下一跳（携带了目标主机的完整地址）</li><li>在不同的阶段，（<em>IP虽然没变</em>）路由表可以改变——导致路线不同</li><li>类似：网络</li><li>Internet</li></ul></li><li><strong>虚电路网络</strong>——先建立起虚电路（vc，利用信令）（两个主机要握手，保持通讯的状态）<ul><li>每个分组都带标签（虚电路号，而非目标主机地址）</li></ul></li></ul></li></ul><h3 id="网络核心关键功能"><a href="#网络核心关键功能" class="headerlink" title="网络核心关键功能"></a><strong>网络核心关键功能</strong></h3><ul><li>路由：决定分组采用的源到目标的路径<ul><li>路由算法</li></ul></li><li>转发：将分组从路由的输入链路转移到输出链路</li></ul><h2 id="1-4-接入网和物理媒体"><a href="#1-4-接入网和物理媒体" class="headerlink" title="1.4 接入网和物理媒体"></a>1.4 接入网和物理媒体</h2><h3 id="怎样将端系统和边缘路由器连接"><a href="#怎样将端系统和边缘路由器连接" class="headerlink" title="怎样将端系统和边缘路由器连接"></a><strong>怎样将端系统和边缘路由器连接</strong></h3><ul><li>住宅接入网络</li><li>单位接入网络（学校、公司）</li><li>无线接入网络</li><li><strong>注意</strong><ul><li>接入网络的带宽（bits per second）</li><li>共享&#x2F;专用？</li></ul></li></ul><h4 id="住宅接入：modem"><a href="#住宅接入：modem" class="headerlink" title="住宅接入：modem"></a><strong>住宅接入</strong>：<strong>modem</strong></h4><ul><li>将上网数据调制加载音频信号上， 在电话线上传输，在局端将其中的 数据解调出来；反之亦然<br> 调频  调幅  调相位  综合调制</li><li>拨号调制解调器<ul><li>56Kbps 的速率直接接入路由器 (通常更低)</li><li>不能同时上网和打电话：不能 总是在线</li></ul></li><li><strong>接入网: digital subscriber line (DSL)</strong></li></ul><img src="计算机网络.assets/647beac70d342b7bd9ccab40b938827c.png" alt="img" style="zoom: 67%;" /><ul><li><p>采用现存的到交换局DSLAM的<strong>电话线</strong></p><ul><li><p>DSL线路上的数据被传到互联网 （&gt;4kHz，上行、下行再分频率）</p><blockquote><p>分频传输不同数据——频分<strong>复用</strong>技术</p></blockquote><ul><li>DSL线路上的语音被传到电话网 （&lt; 4kHz）</li><li>&lt; 2.5 Mbps上行传输速率(typically &lt; 1 Mbps)</li><li>&lt; 24 Mbps下行传输速率(typically &lt; 10 Mbps)</li><li>接入是不对称的</li></ul></li></ul></li><li><p><strong>接入网: 线缆网络</strong></p><ul><li><p><strong>有线电视信号线缆双向改造</strong></p><ul><li><p>FDM: 在不同频段传输不同信道的数据， 数字电视和上网数据（上下行）</p></li><li><p>HFC: hybrid fiber coax</p><ul><li>非对称: 最高30Mbps的<strong>下行</strong>传输速率, 2 Mbps <strong>上行</strong>传输 速率</li></ul></li><li><p>线缆和光纤网络将个家庭用户接入到 ISP 路由器（<em><strong>Internet Service Provider</strong></em>）</p></li><li><p>各用户共享到线缆头端的接入网络</p><ul><li>与DSL不同, DSL每个用户各有一个专用线路到CO（central office）</li></ul></li><li><p>接入是不对称的</p></li></ul></li></ul></li><li><p><strong>住宅接入：电缆模式</strong></p><ul><li>光纤到户：Fiber To The Home，FTTH</li><li>fiber optic transport——光纤传输</li></ul></li><li><p><strong>接入网：家庭网络</strong></p><ul><li>无线路由器</li></ul></li></ul><h4 id="企业接入网络"><a href="#企业接入网络" class="headerlink" title="企业接入网络"></a>企业接入网络</h4><ul><li><p>局域网LAN</p><blockquote><p>Local Area Network</p></blockquote></li><li><p>Ethernet(以太网）是一种传输速率为10Mbps的常用局域网（LAN）标准。</p></li></ul><img src="计算机网络.assets/image-20220907154501303.png" alt="image-20220907154501303" style="zoom:50%;" /><h4 id="无线接入网络"><a href="#无线接入网络" class="headerlink" title="无线接入网络"></a>无线接入网络</h4><ul><li>无线LAN</li><li>广域无线接入</li></ul><img src="计算机网络.assets/image-20220907154322100.png" alt="image-20220907154322100" style="zoom:67%;" /><h3 id="物理媒体（第0层）"><a href="#物理媒体（第0层）" class="headerlink" title="物理媒体（第0层）"></a>物理媒体（第0层）</h3><ul><li><strong>Bit</strong>：<ul><li>在传输-接收对时间传播</li></ul></li><li><strong>物理链路</strong><ul><li>在每个传输-接收对，跨越一种物理媒体</li></ul></li></ul><h4 id="导引型媒体"><a href="#导引型媒体" class="headerlink" title="导引型媒体"></a><strong>导引型媒体</strong></h4><ul><li>信号沿着固体媒介被引导；同轴电缆、光纤、双绞线<ul><li>双绞线<ul><li>两根绝缘铜线<ul><li>5类：100Mbps Ethernet Gbps 以太网</li><li>6类：10Gbps</li></ul></li></ul></li></ul></li></ul><h4 id="非导引型媒体"><a href="#非导引型媒体" class="headerlink" title="非导引型媒体"></a>非导引型媒体</h4><ul><li>信号自由传播：如无线电</li></ul><h4 id="物理媒体：双绞铜线"><a href="#物理媒体：双绞铜线" class="headerlink" title="物理媒体：双绞铜线"></a>物理媒体：双绞铜线</h4><ul><li>已经作为高速LAN联网的主导性解决方案</li></ul><h4 id="物理媒体：同轴电缆、光纤"><a href="#物理媒体：同轴电缆、光纤" class="headerlink" title="物理媒体：同轴电缆、光纤"></a>物理媒体：同轴电缆、光纤</h4><img src="计算机网络.assets/image-20220907155148863.png" alt="image-20220907155148863" style="zoom:50%;" /><h4 id="物理媒介：无线电路"><a href="#物理媒介：无线电路" class="headerlink" title="物理媒介：无线电路"></a>物理媒介：无线电路</h4><p>无线电信道</p><ul><li>局域无线电信道<ul><li>个人设备如无线头戴式耳机，键盘和医疗设备，无线LAN</li></ul></li><li>广域无线电信道<ul><li>蜂窝接入技术（电话、3G…）</li></ul></li></ul><img src="计算机网络.assets/image-20220907155123211.png" alt="image-20220907155123211" style="zoom:50%;" /><h2 id="1-5-Internet结构和ISP"><a href="#1-5-Internet结构和ISP" class="headerlink" title="1.5 Internet结构和ISP"></a>1.5 Internet结构和ISP</h2><h4 id="互联网结构：网络的网络"><a href="#互联网结构：网络的网络" class="headerlink" title="互联网结构：网络的网络"></a>互联网结构：网络的网络</h4><img src="计算机网络.assets/image-20220907160802308.png" alt="image-20220907160802308" style="zoom:67%;" /><h4 id="ISP-Internet-Service-Provider"><a href="#ISP-Internet-Service-Provider" class="headerlink" title="ISP(Internet Service Provider)"></a>ISP(Internet Service Provider)</h4><ul><li><strong>每两个ISP连接——不可扩展</strong></li></ul><img src="计算机网络.assets/image-20220907161015546.png" alt="image-20220907161015546" style="zoom: 67%;" /><ul><li><strong>global ISP</strong></li></ul><img src="计算机网络.assets/image-20220907161104346.png" alt="image-20220907161104346" style="zoom: 67%;" /><ul><li><strong>&#x3D;&#x3D;竞争&#x3D;&#x3D;：多个global ISP &amp;&#x3D;&#x3D;合作：&#x3D;&#x3D; peering link</strong></li></ul><img src="计算机网络.assets/image-20220907161158736.png" alt="image-20220907161158736" style="zoom: 67%;" /><ul><li><strong>regional net</strong>——局部业务 &amp;&amp; <strong>流量中心 IXP</strong></li></ul><img src="计算机网络.assets/image-20220907161614332.png" alt="image-20220907161614332" style="zoom: 67%;" /><h4 id="ICP-Internet-Content-Providers-e-g-Google"><a href="#ICP-Internet-Content-Providers-e-g-Google" class="headerlink" title="ICP(Internet Content Providers)e.g. Google"></a>ICP(Internet Content Providers)e.g. Google</h4><img src="计算机网络.assets/image-20220907162134884.png" alt="image-20220907162134884" style="zoom: 67%;" /><h4 id="ISP-ICP总览"><a href="#ISP-ICP总览" class="headerlink" title="ISP,ICP总览"></a>ISP,ICP总览</h4><img src="计算机网络.assets/image-20220907162423710.png" alt="image-20220907162423710" style="zoom:67%;" /><h4 id="归纳：Internet的结构：network-of-networks"><a href="#归纳：Internet的结构：network-of-networks" class="headerlink" title="归纳：Internet的结构：network of networks"></a>归纳：Internet的结构：network of networks</h4><h5 id="中心：第一层ISP"><a href="#中心：第一层ISP" class="headerlink" title="中心：第一层ISP"></a>中心：第一层ISP</h5><img src="计算机网络.assets/image-20220907162948700.png" alt="image-20220907162948700" style="zoom:67%;" /><h5 id="第二层ISP"><a href="#第二层ISP" class="headerlink" title="第二层ISP"></a>第二层ISP</h5><img src="计算机网络.assets/image-20220907163617782.png" alt="image-20220907163617782" style="zoom:67%;" /><h5 id="第三层local-ISP"><a href="#第三层local-ISP" class="headerlink" title="第三层local ISP"></a>第三层local ISP</h5><img src="计算机网络.assets/image-20220907163727506.png" alt="image-20220907163727506" style="zoom:67%;" /><h5 id="ISP（include-ICP）之间的联络"><a href="#ISP（include-ICP）之间的联络" class="headerlink" title="ISP（include ICP）之间的联络"></a>ISP（include ICP）之间的联络</h5><img src="计算机网络.assets/image-20220907163849178.png" alt="image-20220907163849178" style="zoom: 67%;" /><ul><li>IXP (Internet Exchange Point, IXP) 因特网交换点</li><li>内容提供商在第一层，e.g. Google<ul><li>减少了像顶层ISP支付费用</li></ul></li></ul><h2 id="1-6-分组延时、丢失和吞吐量"><a href="#1-6-分组延时、丢失和吞吐量" class="headerlink" title="1.6 分组延时、丢失和吞吐量"></a>1.6 分组延时、丢失和吞吐量</h2><h4 id="与网络核心中-分组交换-相联系"><a href="#与网络核心中-分组交换-相联系" class="headerlink" title="与网络核心中&#x3D;&#x3D;分组交换&#x3D;&#x3D;相联系"></a>与网络核心中&#x3D;&#x3D;分组交换&#x3D;&#x3D;相联系</h4><ul><li><strong>分组丢失和延时是怎么发生的</strong></li></ul><img src="计算机网络.assets/image-20220907164737543.png" alt="image-20220907164737543" style="zoom:67%;" /><h3 id="四种分组延时-each-hop"><a href="#四种分组延时-each-hop" class="headerlink" title="四种分组延时(each hop)"></a>四种分组延时(each hop)</h3><img src="计算机网络.assets/image-20220907165040375.png" alt="image-20220907165040375" style="zoom:67%;" /><img src="计算机网络.assets/image-20220907170345622.png" alt="image-20220907170345622" style="zoom:67%;" /><h4 id="1-节点处理延时"><a href="#1-节点处理延时" class="headerlink" title="1. 节点处理延时"></a>1. 节点处理延时</h4><ul><li>检查bit级差错</li><li>检查分组首部和决定将部分组导向何处</li></ul><h4 id="2-排队延时（等待）"><a href="#2-排队延时（等待）" class="headerlink" title="2. 排队延时（等待）"></a>2. 排队延时（等待）</h4><ul><li>在输出链路上等待传输的时间</li><li>依赖于路由器的拥塞程度</li></ul><img src="计算机网络.assets/image-20220907170648932.png" alt="image-20220907170648932" style="zoom:50%;" /><h4 id="3-传输延时（传出）"><a href="#3-传输延时（传出）" class="headerlink" title="3. 传输延时（传出）"></a>3. 传输延时（传出）</h4><ul><li>R&#x3D;链路宽度（bps）</li><li>L&#x3D;分组长度（bits）</li><li>将分组发送到链路上的时间&#x3D;L&#x2F;R</li><li>存储转发延时</li></ul><h4 id="4-传播延时（传中）"><a href="#4-传播延时（传中）" class="headerlink" title="4. 传播延时（传中）"></a>4. 传播延时（传中）</h4><ul><li>d&#x3D;物理链路的长度</li><li>s&#x3D;在媒体上的传播速度（~2*10^8^m&#x2F;sec）</li><li>传播延时&#x3D;d&#x2F;s</li></ul><h3 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h3><img src="计算机网络.assets/image-20220907172427377.png" alt="image-20220907172427377" style="zoom:67%;" /><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><ul><li><strong>有效的数据量（被接收）</strong></li></ul><img src="计算机网络.assets/image-20220907172537820.png" alt="image-20220907172537820" style="zoom:67%;" /><h4 id="平均吞吐量取决于——瓶颈链路"><a href="#平均吞吐量取决于——瓶颈链路" class="headerlink" title="平均吞吐量取决于——瓶颈链路"></a>平均吞吐量取决于——瓶颈链路</h4><img src="计算机网络.assets/image-20220907172745016.png" alt="image-20220907172745016" style="zoom:67%;" /><img src="计算机网络.assets/image-20220907173110630.png" alt="image-20220907173110630" style="zoom:67%;" /><ul><li>具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong></li></ul><h2 id="1-7-协议层次和服务模型"><a href="#1-7-协议层次和服务模型" class="headerlink" title="1.7 协议层次和服务模型"></a>1.7 协议层次和服务模型</h2><h3 id="层次化方式实现复杂网络功能"><a href="#层次化方式实现复杂网络功能" class="headerlink" title="层次化方式实现复杂网络功能"></a>层次化方式实现复杂网络功能</h3><ul><li><p>将网络复杂的功能分层功能明确的层次，每一层实现其中一个或一组功能，功能中有其上层可以使用的功能：&#x3D;&#x3D;服务&#x3D;&#x3D;</p></li><li><p>本层协议实体相互交互执行本层的&#x3D;&#x3D;协议动作&#x3D;&#x3D;，&#x3D;&#x3D;目的&#x3D;&#x3D;是实现本层功能。通过接口为上层提供更好的服务</p></li><li><p>在实现本层协议的时候，直接&#x3D;&#x3D;利用了下层所提供的服务&#x3D;&#x3D;</p></li><li><p>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用）+跟下层所提供的服务</p></li><li><p>改变服务的实现而不影响该系统其他组件是分层的另一个重要优点</p></li></ul><h3 id="服务、SAP-Services-Access-point"><a href="#服务、SAP-Services-Access-point" class="headerlink" title="服务、SAP(Services Access point)"></a>服务、SAP(Services Access point)</h3><img src="计算机网络.assets/image-20220908165737544.png" alt="image-20220908165737544" style="zoom: 67%;" /><h4 id="面向连接的服务TCP"><a href="#面向连接的服务TCP" class="headerlink" title="面向连接的服务TCP"></a>面向连接的服务TCP</h4><h4 id="无连接服务UDP"><a href="#无连接服务UDP" class="headerlink" title="无连接服务UDP"></a>无连接服务UDP</h4><h3 id="服务和协议"><a href="#服务和协议" class="headerlink" title="服务和协议"></a>服务和协议</h3><img src="计算机网络.assets/image-20220908170641352.png" alt="image-20220908170641352" style="zoom:67%;" /><img src="计算机网络.assets/image-20220908171235149.png" alt="image-20220908171235149" style="zoom:67%;" /><h3 id="数据单元"><a href="#数据单元" class="headerlink" title="数据单元"></a>数据单元</h3><img src="计算机网络.assets/image-20220908171028709.png" alt="image-20220908171028709" style="zoom: 80%;" /><h3 id="Internet协议栈"><a href="#Internet协议栈" class="headerlink" title="Internet协议栈"></a>Internet协议栈</h3><img src="计算机网络.assets/image-20220908174247445.png" alt="image-20220908174247445" style="zoom:67%;" /><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><blockquote><p>物理层的任务是将给帧中的一个一个bit从一个节点移动到下一个节点。</p><p>与实际媒体相关（例如：双绞铜线、单模光纤）</p></blockquote><ul><li>在线路上传送bit</li><li>数据单元：<strong>位（bit）</strong></li><li>例如，以太网有许多物理层协议：一个是关于双绞铜线的，另一个是关于同轴电缆的，还有一个是关于光纤的。<ul><li>在每种场合中，跨越这些链路移动一个比特是以不同方式进行的</li></ul></li></ul><h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><blockquote><p>在每一个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在改下一个节点，链路层将数据报上传给网络层</p></blockquote><ul><li>在物理层服务之上在相邻&#x3D;&#x3D;两点之间&#x3D;&#x3D;(主机或路由器之间)传输以帧为单位的数据</li><li><strong>点到点通信</strong>，<strong>可靠或不可靠</strong></li><li>点对点协议<strong>PPP</strong>，<strong>802.11(wifi)<strong>，</strong>Ethernet</strong></li><li>链路层的例子包括以太网，WiFi和电缆接入网的DOCSIS协议</li><li>数据单元：<strong>帧（frame）</strong></li></ul><h4 id="网络层IP层"><a href="#网络层IP层" class="headerlink" title="网络层IP层"></a>网络层<del>IP层</del></h4><blockquote><p>因特网的网络层负责将称为数据报(datagram)的网络层分组从一台主机移动到另一台主机。在一台源主机中的因特网运输层协议(TCP或UDP)向网络层递交运输层报文段和目的地址。</p></blockquote><ul><li><p>为数据报<strong>从源到目的</strong>&#x3D;&#x3D;选择路由&#x3D;&#x3D;</p><ul><li><p>在链路层点到点的基础上提供端到端的数据传输 </p></li><li><p><strong>主机与主机之间的通信</strong>，<strong>端到端的通信</strong>，<strong>不可靠</strong></p></li><li><p>**IP，路由选择协议(多种)**……</p></li></ul></li><li><p>数据单元：<strong>分组（packet）（如果是无连接方式（IP网络）：数据报datagram）</strong></p></li></ul><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><blockquote><p>因特网的 运输层 在应用程序端点之间传送 应用层报文。</p></blockquote><ul><li>主机之间的数据传输<ul><li>在网络层提供的端到端通信基础上，<strong>细分为进程到进程</strong>，将不可靠的通信变成可靠的通信</li><li><strong>TCP，UDP</strong></li></ul></li><li>数据单元：<strong>报文段（segment）：TCP段，UDP段</strong></li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul><li>应用层协议<ul><li>为人类用户或者其他应用进程提供网络应用服务</li><li><strong>HTTP</strong><ul><li>提供了Web文档的请求和传送</li></ul></li><li><strong>SMTP</strong><ul><li>提供了电子邮件报文的传输</li></ul></li><li><strong>FTP</strong><ul><li>提供了两个端系统之间的文件传送</li></ul></li><li><strong>DNS</strong><ul><li>域名系统（解析域名）</li></ul></li></ul></li><li>数据单元：<strong>报文（Message）</strong><ul><li>应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。我们把这种未与应用层的信息分组称为报文(message)。</li></ul></li></ul><h3 id="OSI模型七层"><a href="#OSI模型七层" class="headerlink" title="OSI模型七层"></a>OSI模型<del>七层</del></h3><img src="计算机网络.assets/image-20220908173416816.png" alt="image-20220908173416816" style="zoom:67%;" /><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><img src="计算机网络.assets/image-20220908173753430.png" alt="image-20220908173753430" style="zoom:67%;" /><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li><p>在发送主机端·，一个<strong>应用层报文</strong>被传输个运输层。在最简单的情况下，运输层收取到报文并附上附加信息（所谓运输层首部信息，H<del>t</del>）给首部被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层<strong>报文段</strong>，运输层报文段因此封装了应用层报文。</p></li><li><p>附加信息包括允许接收端运输层向上适当的应用程序交付报文信息；差错检测位信息，该信息让接收方能过判断报文中的bit是否在途中已被改变。</p></li><li><p>运输层则向网络层传递该报文段，网络层增加了如源到目的端系统地址等网络层首部信息（H<del>n</del>），生成了<strong>网络层数据报</strong>。</p></li><li><p>该数据报接下来被传递给链路层，链路层（自然而然地）增加它自己的链路层首部信息并生成<strong>链路层帧</strong>。</p></li><li><p>在每一层，一个分组具有两种类型的字段：首部字段和<strong>有效载荷字段</strong>。有效载荷通常是来自上一层的分组</p></li><li><p>一个大报文可能被划分为多个运输层的报文段（这些报文段每个可能被划分为多个网络层数据报）。在接收端，则必须从其连续的数据报中重构这样一个报文段</p></li></ul><h1 id="第2章：应用层"><a href="#第2章：应用层" class="headerlink" title="第2章：应用层"></a>第2章：应用层</h1><h2 id="2-0-应用层概述"><a href="#2-0-应用层概述" class="headerlink" title="2.0 应用层概述"></a>2.0 应用层概述</h2><img src="计算机网络.assets/image-20220910153838304.png" alt="image-20220910153838304" style="zoom: 67%;" /><ul><li>网络核心设备不在应用层起作用，而仅在较低层起作用，特别是网络层及下面层次起作用。这种基本设计，即将应用软件限制在端系统的方法，促进了大量的网络应用程序的迅速研发和部署</li></ul><h2 id="2-1-应用层原理"><a href="#2-1-应用层原理" class="headerlink" title="2.1 应用层原理"></a>2.1 应用层原理</h2><h3 id="网络应用例子"><a href="#网络应用例子" class="headerlink" title="网络应用例子"></a>网络应用例子</h3><img src="计算机网络.assets/image-20220910154230499.png" alt="image-20220910154230499" style="zoom: 67%;" /><h3 id="创建一个新的网络应用"><a href="#创建一个新的网络应用" class="headerlink" title="创建一个新的网络应用"></a>创建一个新的网络应用</h3><img src="计算机网络.assets/image-20220910154337643.png" alt="image-20220910154337643" style="zoom: 67%;" /><img src="计算机网络.assets/image-20220910154509604.png" alt="image-20220910154509604" style="zoom:67%;" /><h3 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h3><h4 id="客户端-服务器模式（C-S-client-server）"><a href="#客户端-服务器模式（C-S-client-server）" class="headerlink" title="客户端-服务器模式（C&#x2F;S:client&#x2F;server）"></a>客户端-服务器模式（C&#x2F;S:client&#x2F;server）</h4><img src="计算机网络.assets/image-20220910155128275.png" alt="image-20220910155128275" style="zoom:67%;" /><p><em><strong>随着访问用户增多，达到一定值服务器性能呈现断崖式缩减</strong></em></p><ul><li>为此，配备大量主机的数据中心（data center）常被用于创建强大的虚拟服务器</li></ul><h4 id="对等模式（P2P-Peer-To-Peer）"><a href="#对等模式（P2P-Peer-To-Peer）" class="headerlink" title="对等模式（P2P:Peer To Peer）"></a>对等模式（P2P:Peer To Peer）</h4><img src="计算机网络.assets/image-20220910155055285.png" alt="image-20220910155055285" style="zoom:67%;" /><h4 id="混合体：客户-服务器和对等模式体系结构"><a href="#混合体：客户-服务器和对等模式体系结构" class="headerlink" title="混合体：客户-服务器和对等模式体系结构"></a>混合体：客户-服务器和对等模式体系结构</h4><img src="计算机网络.assets/image-20220910155302281.png" alt="image-20220910155302281" style="zoom:67%;" /><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><img src="计算机网络.assets/image-20220910160236057.png" alt="image-20220910160236057" style="zoom: 67%;" /><h4 id="分布式进程通信需要解决的问题（假设传输层的服务已经被调用）"><a href="#分布式进程通信需要解决的问题（假设传输层的服务已经被调用）" class="headerlink" title="分布式进程通信需要解决的问题（假设传输层的服务已经被调用）"></a>分布式进程通信需要解决的问题（假设传输层的服务已经被调用）</h4><img src="计算机网络.assets/image-20220910160619255.png" alt="image-20220910160619255" style="zoom:67%;" /><h5 id="问题1：对进程进行编址"><a href="#问题1：对进程进行编址" class="headerlink" title="问题1：对进程进行编址"></a>问题1：对进程进行编址</h5><ul><li>IP+port number（端口号）</li></ul><img src="计算机网络.assets/image-20220910161048358.png" alt="image-20220910161048358" style="zoom:67%;" /><h5 id="问题2-1：传输层提供的服务-需要穿过层间的信息"><a href="#问题2-1：传输层提供的服务-需要穿过层间的信息" class="headerlink" title="问题2.1：传输层提供的服务-需要穿过层间的信息"></a>问题2.1：传输层提供的服务-需要穿过层间的信息</h5><img src="计算机网络.assets/image-20220910162023017.png" alt="image-20220910162023017" style="zoom: 67%;" /><h5 id="问题2-2：传输层提供的服务-层间信息的代表"><a href="#问题2-2：传输层提供的服务-层间信息的代表" class="headerlink" title="问题2.2：传输层提供的服务-层间信息的代表"></a>问题2.2：传输层提供的服务-层间信息的代表</h5><img src="计算机网络.assets/image-20220910162459621.png" alt="image-20220910162459621" style="zoom:67%;" /><blockquote><p>套接字是应用程序进程和运输层之间的接口</p><p>在发送端的应用程序将报文推进该套接字。在套接字的另一侧，运输层协议负责从接受进程的套接字得到该报文</p></blockquote><h6 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h6><blockquote><p>安全套接字层（Secure Sockets Layer，SSL）</p><p>​用SSL加强后的TCP不仅能够做传统TCP所做的一切，而且还提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别</p></blockquote><ul><li><em><strong>TCP之上的套接字（socket）——两两之间的会话标识</strong></em></li></ul><img src="计算机网络.assets/image-20220910163018198.png" alt="image-20220910163018198" style="zoom:67%;" /><ul><li><em><strong>4元组，包含自己和对方的IP，端口</strong></em><ul><li><em><strong>传输的时候只用传&#x3D;&#x3D;socket和数据&#x3D;&#x3D;</strong></em></li></ul></li></ul><img src="计算机网络.assets/image-20220910163315270.png" alt="image-20220910163315270" style="zoom:67%;" /><img src="计算机网络.assets/image-20220910163347194.png" alt="image-20220910163347194" style="zoom:67%;" /><h6 id="UDP-socket"><a href="#UDP-socket" class="headerlink" title="UDP socket"></a>UDP socket</h6><img src="计算机网络.assets/image-20220910163634461.png" alt="image-20220910163634461" style="zoom:67%;" /><p><em><strong>2元组，只包含自己的IP，端口</strong></em></p><ul><li><em><strong>所以打包数据的时候，要传&#x3D;&#x3D;socket和对方IP，端口和数据&#x3D;&#x3D;</strong></em></li></ul><img src="计算机网络.assets/image-20220910164201392.png" alt="image-20220910164201392" style="zoom: 67%;" /><img src="计算机网络.assets/image-20220910164348248.png" alt="image-20220910164348248" style="zoom:67%;" /><h6 id="套接字（socket）"><a href="#套接字（socket）" class="headerlink" title="套接字（socket）"></a>套接字（socket）</h6><img src="计算机网络.assets/image-20220910164538619.png" alt="image-20220910164538619" style="zoom:67%;" /><h5 id="问题3：如何使用传输层提供的服务实现应用"><a href="#问题3：如何使用传输层提供的服务实现应用" class="headerlink" title="问题3：如何使用传输层提供的服务实现应用"></a>问题3：如何使用传输层提供的服务实现应用</h5><img src="计算机网络.assets/image-20220910164957213.png" alt="image-20220910164957213" style="zoom:67%;" /><h6 id="应用层协议（应用实体）"><a href="#应用层协议（应用实体）" class="headerlink" title="应用层协议（应用实体）"></a>应用层协议（应用实体）</h6><img src="计算机网络.assets/image-20220910165434690.png" alt="image-20220910165434690" style="zoom:67%;" /><h6 id="应用层需要像传输层提供的服务"><a href="#应用层需要像传输层提供的服务" class="headerlink" title="应用层需要像传输层提供的服务"></a>应用层需要像传输层提供的服务</h6><img src="计算机网络.assets/image-20220910165747665.png" alt="image-20220910165747665" style="zoom:67%;" /><h6 id="Internet应用及其应用层协议和传输层协议"><a href="#Internet应用及其应用层协议和传输层协议" class="headerlink" title="Internet应用及其应用层协议和传输层协议"></a>Internet应用及其应用层协议和传输层协议</h6><img src="计算机网络.assets/image-20220910171112109.png" alt="image-20220910171112109" style="zoom:67%;" /><h6 id="安全TCP"><a href="#安全TCP" class="headerlink" title="安全TCP"></a>安全TCP</h6><img src="计算机网络.assets/image-20220910171454837.png" alt="image-20220910171454837" style="zoom:67%;" /><h2 id="2-2-Web-and-Http"><a href="#2-2-Web-and-Http" class="headerlink" title="2.2 Web and Http"></a>2.2 Web and Http</h2><blockquote><p>1、Web服务器用于存储网站的所有信息和数据；而Web浏览器是用来访问和定位这些信息和数据。</p><p>2、Web浏览器发送HTTP请求，获取HTTP响应，并向客户端显示Web文档，它充当客户端和显示Web内容的服务器之间的接口。 而Web服务器获取HTTP请求，生成响应，并接受客户端数据</p></blockquote><h3 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><img src="计算机网络.assets/image-20220911151459658.png" alt="image-20220911151459658" style="zoom: 67%;" /><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><blockquote><p>超文本传输协议</p></blockquote><blockquote><p>HTTP是无状态协议——HTTP服务器不保存关于客户的任何信息</p><p>Web服务器总是一直打开的，具有一个固定的IP地址，且它服务于来自数以万计的不同浏览器的请求</p></blockquote><img src="计算机网络.assets/image-20220911152204827.png" alt="image-20220911152204827" style="zoom:67%;" /><img src="计算机网络.assets/image-20220911152755848.png" alt="image-20220911152755848" style="zoom:67%;" /><h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><blockquote><p>持续连接和非持续连接</p><p>当浏览器收到Web页面后，向用户展示该页面。两个不同的浏览器也许会用不同的方式解释（即向用户显示）该页面。HTTP与客户如何解释一个Web页面毫无关系。HTTP范式（[RFC 1945] [RFC 2616]）仅定义了在HTTP客户程序与HTTP服务器程序之间的通信协议</p></blockquote><img src="计算机网络.assets/image-20220911153953442.png" alt="image-20220911153953442" style="zoom:67%;" /><h4 id="非持久HTTP"><a href="#非持久HTTP" class="headerlink" title="非持久HTTP"></a>非持久HTTP</h4><img src="计算机网络.assets/image-20220911154217148.png" alt="image-20220911154217148" style="zoom:67%;" /><img src="计算机网络.assets/image-20220911154339222.png" alt="image-20220911154339222" style="zoom: 80%;" /><h5 id="响应时间模型"><a href="#响应时间模型" class="headerlink" title="响应时间模型"></a>响应时间模型</h5><blockquote><p>这涉及依次“&#x3D;&#x3D;三次握手&#x3D;&#x3D;”过程</p><p>​即客户向服务器发送一个小TCP报文段，服务器用一个小TCP报文段做出确认和响应，最后，客户向服务器返回确认。</p><p>​三次握手中前两个部分所耗费的时间占用了一个RTT(Round-time trip)。完成了三次握手的前两个部分后，客户结合三次握手的第三部分（确认）向该TCP连接发送一个HTTP请求报文。一旦该请求报文到达服务器。服务器就在该TCP连接上发送HTML文件。该HTTP请求&#x2F;响应用去了另一个RRT。</p></blockquote><img src="计算机网络.assets/image-20220911154537619.png" alt="image-20220911154537619" style="zoom:67%;" /><h4 id="持久HTTP"><a href="#持久HTTP" class="headerlink" title="持久HTTP"></a>持久HTTP</h4><img src="计算机网络.assets/image-20220911154838544.png" alt="image-20220911154838544" style="zoom:67%;" /><ul><li><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><ul><li><strong>URL</strong> 代表着是统一资源定位符（Uniform Resource Locator）。URL 无非就是一个给定的独特资源在 Web 上的地址。理论上说，每个有效的 URL 都指向一个唯一的资源。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等。而在实际中，也有一些例外，最常见的情况就是一个 URL 指向了不存在的或是被移动过的资源。由于通过 URL 呈现的资源和 URL 本身由 Web 服务器处理，因此 web 服务器的拥有者需要认真地维护资源以及与它关联的 URL。</li></ul></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/URL">URL</a>, 跟踪 Web 文档的地址系统</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a>, 一个传输协议，以便在给定 URL 时查找文档</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTML">HTML</a>, 允许嵌入超链接的文档格式</p></li></ul><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><img src="计算机网络.assets/image-20220911155444892.png" alt="image-20220911155444892" style="zoom:67%;" /><ul><li><p>GET 向客户端请求——head和body都要</p></li><li><p><em><strong>PST 向客户端上载</strong></em></p></li><li><p>HEAD 只拿头部信息（HTML）——一般搜索引擎用</p></li><li><p>HOST —— 主机名</p></li><li><p>User-agent 用户代理程序及版本</p><ul><li>即向服务器发送请求的浏览器类型</li></ul></li><li><p>Connection——是否建立连接（持久与非持久）</p></li></ul><h4 id="HTTP请求报文：通用格式"><a href="#HTTP请求报文：通用格式" class="headerlink" title="HTTP请求报文：通用格式"></a>HTTP请求报文：通用格式</h4><img src="计算机网络.assets/image-20220911160459353.png" alt="image-20220911160459353" style="zoom:67%;" /><ul><li>cr if —— 回车符</li></ul><h3 id="方法类型"><a href="#方法类型" class="headerlink" title="方法类型"></a>方法类型</h3><img src="计算机网络.assets/image-20220911161343878.png" alt="image-20220911161343878" style="zoom:67%;" /><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><img src="计算机网络.assets/image-20220911161657624.png" alt="image-20220911161657624" style="zoom:67%;" /><ul><li><p>HTTP：Content-Length——用于进程之间的划界限</p><blockquote><p>Content-Length: 首部行指示了发送对象中的字节数</p></blockquote><ul><li>因为TCP不会维护进程间的界限，例如传了两个15k，对方TCP收到时是30k交给上层</li><li>所以要让HTTP自己维护</li></ul></li></ul><h3 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h3><img src="计算机网络.assets/image-20220911162118325.png" alt="image-20220911162118325" style="zoom:67%;" /><h3 id="用户-服务器状态"><a href="#用户-服务器状态" class="headerlink" title="用户-服务器状态"></a>用户-服务器状态</h3><blockquote><p> 用户与服务器的交互</p></blockquote><img src="计算机网络.assets/image-20220911162750345.png" alt="image-20220911162750345" style="zoom:67%;" /><h4 id="cookie维护文件"><a href="#cookie维护文件" class="headerlink" title="cookie维护文件"></a>cookie维护文件</h4><blockquote><p>cookie可以在无状态的HTTP上建立一个用户会话层</p></blockquote><img src="计算机网络.assets/image-20220911162820160.png" alt="image-20220911162820160" style="zoom:67%;" /><img src="计算机网络.assets/image-20220911163447481.png" alt="image-20220911163447481" style="zoom:67%;" /><h3 id="Web缓存（代理服务器）"><a href="#Web缓存（代理服务器）" class="headerlink" title="Web缓存（代理服务器）"></a>Web缓存（代理服务器）</h3><blockquote><p>[代理服务器与反向代理服务器][<a href="https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/]">https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/]</a></p></blockquote><blockquote><p>Web cache（proxy server）</p></blockquote><img src="计算机网络.assets/image-20220911163656904.png" alt="image-20220911163656904" style="zoom:67%;" /><img src="计算机网络.assets/image-20220911163745366.png" alt="image-20220911163745366" style="zoom:67%;" /><ul><li><h4 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h4></li></ul><blockquote><p>Internet Content Provider</p></blockquote><h4 id="缓存例子"><a href="#缓存例子" class="headerlink" title="缓存例子"></a>缓存例子</h4><img src="计算机网络.assets/image-20220911165335959.png" alt="image-20220911165335959" style="zoom:67%;" /><h4 id="如何更新缓冲信息"><a href="#如何更新缓冲信息" class="headerlink" title="如何更新缓冲信息"></a>如何更新缓冲信息</h4><img src="计算机网络.assets/image-20220911165840224.png" alt="image-20220911165840224" style="zoom:67%;" /><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>大大减少对客户请求的响应时间<ul><li>特别是当客户与服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时更是如此</li></ul></li><li>Web缓存器能够大大减少一个机构的接入链路到因特网的通信量。<ul><li>通过减少通信量，就不必增加带宽，因此降低了费用。</li></ul></li><li>此外，Web缓存器能从整体上大大减低因特网上的Web流量，从而改善了所有应用的性能</li><li>通过使用<strong>内容分发网络</strong>(Content Distribution Network, CDN)，Web缓存器正在因特网中发挥越来越重要的作用</li></ul><h3 id="Web浏览器是什么？"><a href="#Web浏览器是什么？" class="headerlink" title="Web浏览器是什么？"></a>Web浏览器是什么？</h3><blockquote><p>即基于HTTP协议的客户</p></blockquote><p>Web浏览器可以被认为是客户端用来从服务器访问Web服务和文档的的一种应用程序软件，<strong>充当服务器和客户端之间的接口</strong>，其基本工作就是<strong>显示Web文档</strong>，允许我们在Internet上查看和浏览文档。</p><p>Web浏览器有很多种，例：internet explorer，谷歌Chrome、火狐Firefox等等</p><h3 id="Web服务器是什么？"><a href="#Web服务器是什么？" class="headerlink" title="Web服务器是什么？"></a>Web服务器是什么？</h3><p>Web服务器是在计算机上运行的一个软件，用于存储和托管web内容的计算机。其主要工作是在用户需要时向用户分发网页，并提供存储和组织网站页面的区域。</p><h3 id="Web浏览器和Web服务器的区别"><a href="#Web浏览器和Web服务器的区别" class="headerlink" title="Web浏览器和Web服务器的区别"></a>Web浏览器和Web服务器的区别</h3><p>1、Web服务器用于<strong>存储</strong>网站的所有信息和数据；而Web浏览器是用来<strong>访问和定位</strong>这些信息和数据。</p><p>2、Web浏览器发送HTTP请求，获取HTTP响应，并向客户端显示Web文档，它充当客户端和显示Web内容的服务器之间的接口。而Web服务器获取HTTP请求，生成响应，并接受客户端数据。</p><p>3、Web浏览器用于通过网站在Internet上搜索内容。而，Web服务器用于建立网站和Web浏览器之间的链接。</p><p>4、Web服务器的主要组件是服务器核心，服务器核心64位二进制文??件，示例应用程序，管理命令行界面等；而，Web浏览器的组件是用户界面，UI后端，布局和渲染引擎，以及网络和数据持久性零件。</p><h2 id="2-3-FTP（文件传输协议）-C-S"><a href="#2-3-FTP（文件传输协议）-C-S" class="headerlink" title="2.3 FTP（文件传输协议）(C&#x2F;S)"></a>2.3 FTP（文件传输协议）(C&#x2F;S)</h2><ul><li><strong>有状态协议</strong></li></ul><img src="计算机网络.assets/image-20220912160858256.png" alt="image-20220912160858256" style="zoom: 67%;" /><h3 id="控制连接与数据连接分开"><a href="#控制连接与数据连接分开" class="headerlink" title="控制连接与数据连接分开"></a>控制连接与数据连接分开</h3><img src="计算机网络.assets/image-20220912161135657.png" alt="image-20220912161135657" style="zoom:67%;" /><ul><li><em><strong>控制连接和数据连接在不同的TCP端口进行</strong></em></li></ul><h3 id="FTP命令、响应"><a href="#FTP命令、响应" class="headerlink" title="FTP命令、响应"></a>FTP命令、响应</h3><img src="计算机网络.assets/image-20220912161935553.png" alt="image-20220912161935553" style="zoom:67%;" /><h2 id="2-4-Email（应用）-C-S"><a href="#2-4-Email（应用）-C-S" class="headerlink" title="2.4 Email（应用）(C&#x2F;S)"></a>2.4 Email（应用）(C&#x2F;S)</h2><img src="计算机网络.assets/image-20220912162450755.png" alt="image-20220912162450755" style="zoom:67%;" /><img src="计算机网络.assets/image-20220912162641870.png" alt="image-20220912162641870" style="zoom:67%;" /><ul><li><strong>从邮件服务器到用户代理器之间，用户代理器（e.g.outlook）还要通过 协议 将邮件从邮箱拉过来呈现给用户</strong><ul><li>&#x3D;&#x3D;看邮件访问协议&#x3D;&#x3D;</li></ul></li></ul><h3 id="Email：SMTP"><a href="#Email：SMTP" class="headerlink" title="Email：SMTP"></a>Email：SMTP</h3><blockquote><p>异步通信媒介</p><p>简单邮件传输协议 Simple Mail Transfer Protocol</p></blockquote><ul><li><strong>持久连接</strong></li></ul><img src="计算机网络.assets/image-20220912163142391.png" alt="image-20220912163142391" style="zoom:67%;" /><img src="计算机网络.assets/image-20220912163310759.png" alt="image-20220912163310759" style="zoom:67%;" /><img src="计算机网络.assets/image-20220912163441737.png" alt="image-20220912163441737" style="zoom:67%;" /><h4 id="SMTP总结"><a href="#SMTP总结" class="headerlink" title="SMTP总结"></a>SMTP总结</h4><ul><li><p>SMTP限制所有邮件的体部分（不只是其首部）只能采用简单的7比特ASCII表示</p><blockquote><p>即在用SMTP传送邮件前需要将二进制多媒体数据编码为ASCII码，并且在使用SMTP传输后要求将相应的ASCII码邮件解码还原为多媒体数据。（HTTP传送前不需要将多媒体数据编码为ASCII码）</p></blockquote></li><li><p>SMTP一般不使用中间邮件服务器发送邮件，即使这两个邮件服务器位于地球的两端也是这样</p></li><li><p>一旦TCP建立连接，服务器和客户执行某些&#x3D;&#x3D;应用层的握手&#x3D;&#x3D;</p><blockquote><p>就像人们在相互交流前进行自我介绍一样</p></blockquote></li></ul><img src="计算机网络.assets/image-20220912163712680.png" alt="image-20220912163712680" style="zoom:67%;" /><h4 id="SMTP与HTTP的对比"><a href="#SMTP与HTTP的对比" class="headerlink" title="SMTP与HTTP的对比"></a>SMTP与HTTP的对比</h4><ul><li>HTTP从Web服务器向Web客户（通常是一个浏览器）传送文件（也称为对象）；SMTP从一个邮件服务器向另一个邮件服务器传送文件（即电子邮件报文）</li><li>当进行文件传送时，持续的HTTP和SMTP都使用持续连接。</li><li>重要的区别<ul><li>HTTP主要是一个<strong>拉协议</strong>(pull protocol)，即在方便的时候，某些人在Web服务器上装载信息，用户使用HTTP从该服务器拉取这些信息。特别是TCP连接时是<em><strong>想接收文件的机器</strong></em>发起的。</li><li>SMTP基本上是一个<strong>推协议</strong>(push protocol)，即发送邮件服务器把文件推向接收邮件服务器。特别是，这个TCP连接是由要<em><strong>发送该文件的机器</strong></em>发送的。</li></ul></li><li>第二个区别<ul><li>即在用SMTP传送邮件前需要将二进制多媒体数据编码为ASCII码，并且在使用SMTP传输后要求将相应的ASCII码邮件解码还原为多媒体数据。（HTTP传送前不需要将多媒体数据编码为ASCII码）</li></ul></li><li>第三个区别<ul><li>如何处理既包含文本又包含图形（也有可能是其他媒体类型）的文档。<ul><li>HTTP把每个对象封装到它自己的HTTP响应报文中</li><li>SMTP则把所有报文对象放在一个报文之中</li></ul></li></ul></li></ul><h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><blockquote><p>这些首部行是邮件报文本身的一部分（不同于SMTP的命令）</p></blockquote><img src="计算机网络.assets/image-20220912163825620.png" alt="image-20220912163825620" style="zoom:67%;" /><h3 id="报文格式：多媒体扩展"><a href="#报文格式：多媒体扩展" class="headerlink" title="报文格式：多媒体扩展"></a>报文格式：多媒体扩展</h3><img src="计算机网络.assets/image-20220912163940291.png" alt="image-20220912163940291" style="zoom:67%;" /><ul><li>通过（base64）将不在ASCLL范围内的字符（e.g. 中文，图片…）映射到ASCLL码进行传输<ul><li>因为只能传ASCLL码</li></ul></li></ul><h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><blockquote><p>SMTP是一个push protocol，而邮件访问需要一个pull protocol</p></blockquote><img src="计算机网络.assets/image-20220912164513721.png" alt="image-20220912164513721" style="zoom:67%;" /><ul><li><p><strong>IMAP</strong></p><blockquote><p>Internet Mail Access Protocol</p></blockquote><ul><li>远程目录维护</li></ul></li><li><p>POP3</p><ul><li>将邮件从接收方的邮件服务器传送到接收方的用户代理</li></ul></li></ul><h4 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h4><blockquote><p>Post Office Protocol—Version 3</p></blockquote><img src="计算机网络.assets/image-20220912164820929.png" alt="image-20220912164820929" style="zoom:67%;" /><h4 id="POP3协议（续）与IMAP"><a href="#POP3协议（续）与IMAP" class="headerlink" title="POP3协议（续）与IMAP"></a>POP3协议（续）与IMAP</h4><img src="计算机网络.assets/image-20220912165050359.png" alt="image-20220912165050359" style="zoom:67%;" /><h4 id="基于Web的电子邮件"><a href="#基于Web的电子邮件" class="headerlink" title="基于Web的电子邮件"></a>基于Web的电子邮件</h4><ul><li>浏览器(用户代理)—HTTP— 发送邮件服务器 —SMTP— 接收邮件服务器 —HTTP— 浏览器(用户代理)</li></ul><h2 id="2-5-DNS（C-S）"><a href="#2-5-DNS（C-S）" class="headerlink" title="2.5 DNS（C&#x2F;S）"></a>2.5 DNS（C&#x2F;S）</h2><blockquote><p>Domain Name System 域名解析系统</p><p>DNS：</p><pre><code>1. 一个由分层的**DNS服务器**(DNS server)实现的分布式数据库1. 一个使得主机能够查询分布式数据库的应用层协议1. 运行在UDP之上</code></pre></blockquote><img src="计算机网络.assets/image-20220913142455572.png" alt="image-20220913142455572" style="zoom: 67%;" /><h3 id="DNS的历史"><a href="#DNS的历史" class="headerlink" title="DNS的历史"></a>DNS的历史</h3><img src="计算机网络.assets/image-20220913143953473.png" alt="image-20220913143953473" style="zoom:67%;" /><ul><li><h4 id="主机别名"><a href="#主机别名" class="headerlink" title="主机别名"></a>主机别名</h4><blockquote><p>p84</p></blockquote><ul><li>规范主机名</li><li>主机别名</li></ul></li><li><h4 id="邮件服务器别名"><a href="#邮件服务器别名" class="headerlink" title="邮件服务器别名"></a>邮件服务器别名</h4></li><li><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>DNS用于冗余的Web服务器等</li><li>繁忙的站点被冗余分布在多台服务器上，每台服务器运行在不同的端系统上，每个都有不同的IP地址</li><li>一个IP地址集合于同一个规范主机名相联系。</li></ul></li><li><h4 id="本地DNS服务器"><a href="#本地DNS服务器" class="headerlink" title="本地DNS服务器"></a>本地DNS服务器</h4><ul><li>与Web缓存服务器类似，是代理服务器</li></ul></li><li><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><ul><li>一段时间后丢弃缓存信息（避免缓存IP地址的更改造成失败）</li><li>在DNS服务器中缓存查询过的IP地址</li><li>因为缓存，除了少数DNS查询以外，根服务器被绕过了</li></ul></li></ul><h3 id="DNS系统需要解决的问题"><a href="#DNS系统需要解决的问题" class="headerlink" title="DNS系统需要解决的问题"></a>DNS系统需要解决的问题</h3><img src="计算机网络.assets/image-20220913143046959.png" alt="image-20220913143046959" style="zoom:67%;" /><h4 id="问题1：-如何命名设备"><a href="#问题1：-如何命名设备" class="headerlink" title="问题1： 如何命名设备"></a>问题1： 如何命名设备</h4><img src="计算机网络.assets/image-20220913145118272.png" alt="image-20220913145118272" style="zoom: 67%;" /><h5 id="DNS的名字空间"><a href="#DNS的名字空间" class="headerlink" title="DNS的名字空间"></a>DNS的名字空间</h5><img src="计算机网络.assets/image-20220913150726677.png" alt="image-20220913150726677" style="zoom:67%;" /><img src="计算机网络.assets/image-20220913150710161.png" alt="image-20220913150710161" style="zoom:67%;" /><ul><li><em><strong>域名是逻辑上的，与不是物理网络</strong></em></li></ul><img src="计算机网络.assets/image-20220913150810522.png" alt="image-20220913150810522" style="zoom:67%;" /><h4 id="问题2：解析问题-名字服务器（Name-Server）"><a href="#问题2：解析问题-名字服务器（Name-Server）" class="headerlink" title="问题2：解析问题-名字服务器（Name Server）"></a>问题2：解析问题-名字服务器（Name Server）</h4><img src="计算机网络.assets/image-20220913152048969.png" alt="image-20220913152048969" style="zoom:67%;" /><img src="计算机网络.assets/image-20220913152314431.png" alt="image-20220913152314431" style="zoom:67%;" /><h5 id="区域名字服务器维护资源记录"><a href="#区域名字服务器维护资源记录" class="headerlink" title="区域名字服务器维护资源记录"></a>区域名字服务器维护资源记录</h5><img src="计算机网络.assets/image-20220913152612454.png" alt="image-20220913152612454" style="zoom:67%;" /><h5 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h5><img src="计算机网络.assets/image-20220913153513103.png" alt="image-20220913153513103" style="zoom:67%;" /><h6 id="DNS大致工作流程"><a href="#DNS大致工作流程" class="headerlink" title="DNS大致工作流程"></a>DNS大致工作流程</h6><img src="计算机网络.assets/image-20220913154339060.png" alt="image-20220913154339060" style="zoom:67%;" /><h6 id="本地服务器（Local-Name-Server）"><a href="#本地服务器（Local-Name-Server）" class="headerlink" title="本地服务器（Local Name Server）"></a>本地服务器（Local Name Server）</h6><img src="计算机网络.assets/image-20220913154500673.png" alt="image-20220913154500673" style="zoom:67%;" /><h6 id="本地服务器没有缓存"><a href="#本地服务器没有缓存" class="headerlink" title="本地服务器没有缓存"></a>本地服务器没有缓存</h6><ul><li><strong>递归查询</strong></li></ul><img src="计算机网络.assets/image-20220913155038813.png" alt="image-20220913155038813" style="zoom:67%;" /><ul><li><strong>迭代查询</strong></li></ul><img src="计算机网络.assets/image-20220913155234207.png" alt="image-20220913155234207" style="zoom:67%;" /><h5 id="DNS协议-报文"><a href="#DNS协议-报文" class="headerlink" title="DNS协议&#x2F;报文"></a>DNS协议&#x2F;报文</h5><img src="计算机网络.assets/image-20220913155741812.png" alt="image-20220913155741812" style="zoom:67%;" /><h5 id="提高性能：缓存"><a href="#提高性能：缓存" class="headerlink" title="提高性能：缓存"></a>提高性能：缓存</h5><img src="计算机网络.assets/image-20220913155911170.png" alt="image-20220913155911170" style="zoom:67%;" /><h4 id="问题三：维护问题：新增一个域"><a href="#问题三：维护问题：新增一个域" class="headerlink" title="问题三：维护问题：新增一个域"></a>问题三：维护问题：新增一个域</h4><img src="计算机网络.assets/image-20220913160250777.png" alt="image-20220913160250777" style="zoom:67%;" /><h3 id="攻击DNS"><a href="#攻击DNS" class="headerlink" title="攻击DNS"></a>攻击DNS</h3><img src="计算机网络.assets/image-20220913160621180.png" alt="image-20220913160621180" style="zoom:67%;" /><h2 id="2-6-P2P"><a href="#2-6-P2P" class="headerlink" title="2.6 P2P"></a>2.6 P2P</h2><h3 id="纯P2P"><a href="#纯P2P" class="headerlink" title="纯P2P"></a>纯P2P</h3><img src="计算机网络.assets/image-20220914161834101.png" alt="image-20220914161834101" style="zoom: 67%;" /><h3 id="文件分发：C-S-vs-P2P"><a href="#文件分发：C-S-vs-P2P" class="headerlink" title="文件分发：C&#x2F;S vs. P2P"></a>文件分发：C&#x2F;S vs. P2P</h3><h4 id="C-S"><a href="#C-S" class="headerlink" title="C&#x2F;S"></a>C&#x2F;S</h4><img src="计算机网络.assets/image-20220914162816937.png" alt="image-20220914162816937" style="zoom:67%;" /><h4 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h4><img src="计算机网络.assets/image-20220914163119049.png" alt="image-20220914163119049" style="zoom:67%;" /><h4 id="Client-server-vs-P2P-例子"><a href="#Client-server-vs-P2P-例子" class="headerlink" title="Client-server vs. P2P:例子"></a>Client-server vs. P2P:例子</h4><img src="计算机网络.assets/image-20220914162644526.png" alt="image-20220914162644526" style="zoom:67%;" /><h4 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h4><img src="计算机网络.assets/image-20220914170259647.png" alt="image-20220914170259647" style="zoom:67%;" /><img src="计算机网络.assets/image-20220914170735370.png" alt="image-20220914170735370" style="zoom:67%;" /><img src="计算机网络.assets/image-20220914171132959.png" alt="image-20220914171132959" style="zoom:67%;" /><ul><li><h4 id="后面随机选择peer是为了找黑马"><a href="#后面随机选择peer是为了找黑马" class="headerlink" title="后面随机选择peer是为了找黑马"></a>后面随机选择peer是为了找黑马</h4></li></ul><img src="计算机网络.assets/image-20220914171510423.png" alt="image-20220914171510423" style="zoom:67%;" /><h4 id="P2P共享"><a href="#P2P共享" class="headerlink" title="P2P共享"></a>P2P共享</h4><img src="计算机网络.assets/image-20220914164000420.png" alt="image-20220914164000420" style="zoom:67%;" /><img src="计算机网络.assets/image-20220914164503042.png" alt="image-20220914164503042" style="zoom:67%;" /><h5 id="P2P-非结构化"><a href="#P2P-非结构化" class="headerlink" title="P2P 非结构化"></a>P2P 非结构化</h5><h6 id="P2P：集中式目录"><a href="#P2P：集中式目录" class="headerlink" title="P2P：集中式目录"></a>P2P：集中式目录</h6><img src="计算机网络.assets/image-20220914164538926.png" alt="image-20220914164538926" style="zoom:67%;" /><img src="计算机网络.assets/image-20220914164643758.png" alt="image-20220914164643758" style="zoom:67%;" /><h6 id="P2P：完全分布式"><a href="#P2P：完全分布式" class="headerlink" title="P2P：完全分布式"></a>P2P：完全分布式</h6><img src="计算机网络.assets/image-20220914164805228.png" alt="image-20220914164805228" style="zoom:67%;" /><img src="计算机网络.assets/image-20220914164957330.png" alt="image-20220914164957330" style="zoom:67%;" /><img src="计算机网络.assets/image-20220914165239552.png" alt="image-20220914165239552" style="zoom:67%;" /><h6 id="P2P：混合体（小组）"><a href="#P2P：混合体（小组）" class="headerlink" title="P2P：混合体（小组）"></a>P2P：混合体（小组）</h6><img src="计算机网络.assets/image-20220914165513067.png" alt="image-20220914165513067" style="zoom:67%;" /><h5 id="DHT-P2P-结构化"><a href="#DHT-P2P-结构化" class="headerlink" title="DHT P2P 结构化"></a>DHT P2P 结构化</h5><blockquote><p>分布式散列表</p></blockquote><ul><li>分布式散列表是一个简单的数据库，其数据库记录分布在一个P2P系统的多个对等方上。</li></ul><h2 id="2-7-视频流和内容分发网"><a href="#2-7-视频流和内容分发网" class="headerlink" title="2.7 视频流和内容分发网"></a>2.7 视频流和内容分发网</h2><h3 id="HTTP流和DASH"><a href="#HTTP流和DASH" class="headerlink" title="HTTP流和DASH"></a>HTTP流和DASH</h3><blockquote><p>DASH Dynamic Adaptive Streaming over HTTP 经HTPP的动态适应流</p></blockquote><ul><li>DASH允许用户使用的以太网接入速率流式播放具有不同编码的视频<ul><li>DASH允许用户适应可用宽带，用户可以自行选择来自不同版本的块</li><li>HTTP服务器中有各个视频的版本，每个版本有对应的URL。</li><li>HTTP服务器也有一个<strong>告示文件</strong></li></ul></li></ul><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote><p>内容分发网 Content Distribution Network</p></blockquote><ul><li>CDN的管理分布在多个地理位置的服务器上，在它的服务器上存储视频（和其他类型的Web内容，包括文档、图片和音频）</li><li>CDN可以时<strong>专用CDN</strong>，及它由内容提供商自己所拥有<ul><li>例如Google的CDN分发YouTube视频和其他类型的内容。</li></ul></li><li>另一种CDN可以时<strong>第三方CDN</strong>，它代表多个内容提供商分发内容</li></ul><h3 id="CDN服务器安置原则"><a href="#CDN服务器安置原则" class="headerlink" title="CDN服务器安置原则"></a>CDN服务器安置原则</h3><ul><li><p><strong>深入</strong></p><ul><li>目标是靠近端用户，通过减少端用户和CDN集群之间（内容从这里收到）链路和路由器数量，从而改善用户感受的时延和吞吐量</li></ul></li><li><p><strong>邀请做客</strong></p><ul><li>原则时通过少量关键位置建造大集群来邀请到ISP做客<ul><li>不是将集群放在接入ISP中，这些CDN通常将它们的集群放置在因特网的交换节点（IXP）</li><li>通常产生较低的维护和管理开销，可能以对端用户的较高时延和较低吞吐量作为代价</li></ul></li></ul></li></ul><h3 id="CDN操作"><a href="#CDN操作" class="headerlink" title="CDN操作"></a>CDN操作</h3><ol><li>确定此时适合用于该用户的CDN服务器集群</li><li>将该用户的请求重定向到该集群的某台服务器</li></ol><h3 id="集群选择策略"><a href="#集群选择策略" class="headerlink" title="集群选择策略"></a>集群选择策略</h3><blockquote><p>任何CDN部署，其核心是集群选择策略</p></blockquote><ul><li>指派客户到<strong>地理上最为邻近</strong>的集群（通过DNS服务器）<ul><li>每个LDNS IP 地址都映射到一个地理位置</li><li>但对于某些用户而言，该执行方案可能执行效率差<ul><li>因为就网络路径的长度和跳数而言，地理最邻近的集群可能并不是最近的集群。</li><li>此外，一种基于DNS的方法都内在具有的问题是，某些端用户使用位于远地的LDNS</li><li>这种简单的策略忽略了时延和可用带宽随因特网路径时间而变化，总是指定特定的客户指派相同的集群</li></ul></li></ul></li><li>为了基于当前流量条件作为客户决定最好的集群，CDN能够对其集群和客户之间的时延和丢包能执行周期性的<strong>实时测量</strong></li></ul><h3 id="学习案例：-Netflix、YouTube和-“看看”"><a href="#学习案例：-Netflix、YouTube和-“看看”" class="headerlink" title="学习案例： Netflix、YouTube和 “看看”"></a>学习案例： Netflix、YouTube和 “看看”</h3><ul><li><p><strong>Netflix</strong></p><ul><li>其视频分发具有以下两个主要部件：亚马逊云和它自己的专用CDN基础设施</li><li>其CDN只用来分发视频，Web网站完全运行在亚马逊云</li><li>有自适应流和CDN分发</li><li>不需要CDN重定向来将特殊用户连接到一台CDN服务器，相反Netflix软件（运行在亚马逊云中）直接告诉该客户使用一台特定的CDN服务器</li><li>推高速缓存<ul><li>内容在非高峰时段的预定时间被推到服务器，而不是在高速缓存未命中时动态推入</li></ul></li></ul></li><li><p>YouTube</p><ul><li>拉高速缓存和CDN重定向</li><li>为了平衡流经集群的负载，有时客户被定向（经CDN）到更远的集群</li><li>YouTube没有自适应流（例如DASH），要求用户人工选择一个版本</li></ul></li><li><p>看看</p><ul><li>CDN-P2P流模式</li><li>当P2P总流量满足视频播放时吗，该用户将从CDN停止流到对等放获得流</li><li>如果P2P总流量不充分时，该客户重新启动CDN连接并且返回到混合CDN-P2P流模式<ul><li>确保短启动时延，与此同时最小地依赖成本高的基础设施服务器和带宽</li></ul></li></ul></li></ul><h2 id="2-8-套接字编程：生成网络应用"><a href="#2-8-套接字编程：生成网络应用" class="headerlink" title="2.8 套接字编程：生成网络应用"></a>2.8 套接字编程：生成网络应用</h2><ul><li>经典的网络应用是由一对程序（即客户程序和服务器程序）组成的<ul><li>当运行两个程序时，创建了一个客户进程和一个服务器进程</li><li>同时它们通过从套接字读出和写入数据在彼此之间进行通信</li></ul></li></ul><h1 id="第3章：运输层"><a href="#第3章：运输层" class="headerlink" title="第3章：运输层"></a>第3章：运输层</h1><h2 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h2><ul><li>网络路由器仅作用于该数据报的网络层字段，即它们不检查封装在给数据报的运输层报文段的字段</li><li>网络层提供主机之间的逻辑通信，运输层运行在不同主机上的进程之间的逻辑通信</li><li>运输协议能够提供的服务常常受制于底层网络层协议的服务模型</li></ul><h2 id="3-2-多路复用和多路分解"><a href="#3-2-多路复用和多路分解" class="headerlink" title="3.2 多路复用和多路分解"></a>3.2 多路复用和多路分解</h2><blockquote><p>运输层的多路复用和多路分解，也就是将由网络层提供的主机到主机交付服务延伸到为运行在主机上的应用程序提供程序到程序的交付服务</p></blockquote><ul><li><p><strong>多路分解</strong>：将运输层报文段中的数据交付到正确的套接字的工作</p></li><li><p><strong>多路复用</strong>：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层。</p></li><li><p>运输层 多路复用的要求：</p><ul><li>套接字有唯一的标识符</li><li>每个报文段有特殊字段来指示该报文段所要交付到的套接字<ul><li>特殊字段包括：<strong>端源口号字段</strong>和<strong>目的端口号字段</strong></li><li>0~1023范围的端口号称为<strong>周知端口号</strong></li></ul></li></ul></li><li><p>UDP套接字：二元组（目的IP地址，目的端口号）</p></li><li><p>TCP套接字：四元组（源IP地址，源端口号，目的IP地址，目的端口号）</p></li></ul><h2 id="3-3-无连接运输：UDP"><a href="#3-3-无连接运输：UDP" class="headerlink" title="3.3 无连接运输：UDP"></a>3.3 无连接运输：UDP</h2><ul><li><p>运输层最低限度必须提供一种复用&#x2F;分解服务</p></li><li><p>自适应拥塞控制：因为假设UDP传输高比特率使得TCP拥塞控制从而大大减小了TCP传输的速率</p></li><li><p>在UDP上增加可靠通信（应用程序自身建立可靠机制），这样应用程序可以进行可靠通信而无须受制于由TCP拥塞控制强加的传输速率限制</p></li><li><p>UDP报文段结构</p><ul><li><img src="计算机网络.assets/1678266356813.jpg" alt="1678266356813" style="zoom: 25%;" /></li></ul></li><li><p>UDP检验和</p><ul><li>发送方的UDP对报文段中的所有16比特字的和进行反码运算</li><li>虽然UDP提供差错检测，但它对差错恢复无能为力。UDP的某种实现只是丢弃受损的报文段；其他实现是将受损的报文段交给应用程序并给出警告</li></ul></li></ul><h2 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h2><img src="计算机网络.assets/1678266683305.jpg" alt="1678266683305" style="zoom: 25%;" /><h3 id="rtd1-0"><a href="#rtd1-0" class="headerlink" title="rtd1.0"></a>rtd1.0</h3><ul><li>经完全可靠信道的可靠数据传输</li></ul><h3 id="rtd2-0"><a href="#rtd2-0" class="headerlink" title="rtd2.0"></a>rtd2.0</h3><blockquote><p>经具有比特差错信道的可靠数据传输</p></blockquote><ul><li>肯定确认与否定确认</li><li>自动重传机制</li><li>停等协议</li></ul><h3 id="rtd2-1"><a href="#rtd2-1" class="headerlink" title="rtd2.1"></a>rtd2.1</h3><ul><li>增加了序号，给分组编号</li></ul><h3 id="rtd2-2"><a href="#rtd2-2" class="headerlink" title="rtd2.2"></a>rtd2.2</h3><ul><li>只用ACK来确认（例如ACK0&#x3D;&#x3D;NAK1）</li></ul><h3 id="rtd3-0"><a href="#rtd3-0" class="headerlink" title="rtd3.0"></a>rtd3.0</h3><ul><li>经具有比特差错的丢包信道的可靠数据传输</li></ul><h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><img src="计算机网络.assets/1678282227902.jpg" alt="1678282227902" style="zoom:25%;" /><ul><li>解决流水线的差错恢复有两种基本方法：<ul><li><strong>回退N步</strong>（RW&#x3D;1）<ul><li>GBN协议（Go back N）</li></ul></li><li><strong>选择重传</strong>（RW&gt;1）<ul><li>SR协议 （Selected Repeat）</li></ul></li></ul></li></ul><h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><ul><li>发送窗口</li></ul><img src="计算机网络.assets/image-20230308214230634.png" alt="image-20230308214230634" style="zoom: 67%;" /><ul><li>接受窗口</li></ul><img src="计算机网络.assets/image-20230308214937080.png" alt="image-20230308214937080" style="zoom: 80%;" /><img src="计算机网络.assets/image-20230308215026255.png" alt="image-20230308215026255" style="zoom:80%;" /><img src="计算机网络.assets/image-20230308220148293.png" alt="image-20230308220148293" style="zoom:80%;" /><img src="计算机网络.assets/image-20230308220916751.png" alt="image-20230308220916751" style="zoom:80%;" /><img src="计算机网络.assets/image-20230308222342049.png" alt="image-20230308222342049" style="zoom:80%;" /><img src="计算机网络.assets/image-20230308222854494.png" alt="image-20230308222854494" style="zoom:80%;" /><img src="计算机网络.assets/image-20230308223100093.png" alt="image-20230308223100093" style="zoom:80%;" /><img src="计算机网络.assets/image-20230308224531880.png" alt="image-20230308224531880" style="zoom:80%;" /><h2 id="3-5-面向连接的运输：TCP"><a href="#3-5-面向连接的运输：TCP" class="headerlink" title="3.5 面向连接的运输：TCP"></a>3.5 面向连接的运输：TCP</h2><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><ul><li>三次握手：<ul><li>客户首先发送一个特殊的TCP报文段，服务器用一个特殊的TCP报文段作为响应，最后客户再用第三个特殊的报文段作为响应。前两个报文段不承载“有效载荷”，就是不包含应用层数据；而第三个报文段可以承载有效载荷</li></ul></li><li>TCP可以从缓存中取出并放入报文段的数据数量受限于<strong>最大报文段长度</strong>（Maximun Segment Size，MSS）</li><li>MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的<strong>最大传输单元</strong>（Maximun Transmission Unit MTU））</li><li>MSS是指在报文段里应用层数据的最大长度，而不是指包括首部的TCP报文段的最大长度</li><li>TCP的连接组成包括：<ul><li>一台主机上的缓存、变量和与进程连接的套接字</li><li>以及另一台主机的另一组缓存、变量和与进程连接的套接字。</li></ul></li></ul><blockquote><p>在两台主机之间的网络元素（路由器、交换机和中继器）中，没有为该连接分配任何缓存和变量</p></blockquote><img src="计算机网络.assets/1678325164506.jpg" alt="1678325164506" style="zoom:25%;" /><h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><img src="计算机网络.assets/1678325142019.jpg" alt="1678325142019" style="zoom:25%;" /><h3 id="往返时间的估计与超时"><a href="#往返时间的估计与超时" class="headerlink" title="往返时间的估计与超时"></a>往返时间的估计与超时</h3><ul><li>估计往返时间</li><li>设置和管理重传超时间隔</li></ul><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><ul><li>TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是<strong>无损坏、无间隙、非冗余和按序的数据流</strong></li><li>超时间隔加倍<ul><li>每个发送方的重传都是经过越来越长的时间间隔后进行的</li></ul></li><li>快速重传<ul><li>一旦收到三个冗余的ACK，TCP就执行<strong>快速重传</strong></li></ul></li><li>TCP的差错恢复机制也许最好被分类为GBN协议和SR协议的混合体</li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><blockquote><p>如果某应用程序读取数据时相对缓慢，而发送方发送的太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出</p><p>拥塞控制是因为IP网络的拥塞</p></blockquote><img src="计算机网络.assets/1678358972877.jpg" alt="1678358972877" style="zoom:25%;" /><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><ul><li>三次握手</li><li>SYN洪泛攻击<ul><li>解决方案，不记录cookie或任何SYN的其他状态信息</li><li>对于一个合法的ACK，在确认字段中的值等于在SYNACK字段（此时为cookie值）中的值加1.服务器则将使用在SYNACK报文段中的源和目的地址IP地址与端口号（它们与初始的SYN中的相同）以及秘密运行相同的散列函数。如果该函数的结果加1与在客户的SYNACK中的确认（cookie）值相同的话，服务器认为该ACK对应于较早的SYN报文段，因此它时合法的</li></ul></li></ul><h3 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h3><ul><li>拥塞出现的原因<ul><li>当分组的到达速率接近链路容量时，分组经历巨大的排队时延</li><li>发送方在遇到大时延时所进行的不必要重传将会引起路由器利用其链路带宽来转发不必要的分组副本</li><li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发给分组到丢弃该分组而使用的传输容量最终被浪费掉了</li></ul></li><li>拥塞控制的方法<ul><li>端到端拥塞控制<ul><li>端系统通过对网络行为的观察（如分组和时延）来推断。</li><li>TCP报文段的丢失（通过超时或3次冗余确认而得知）被认为是网络拥塞的迹象，TCP会相应地减小其窗口长度</li></ul></li><li>网络辅助的拥塞控制<ul><li>向端系统发送ATM可用比特率，能在输出链路上支持的最大主机发送速率<ul><li>路由器向发送方发送</li><li>接收方向发送方发送</li></ul></li></ul></li></ul></li></ul><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><blockquote><p>TCP必须使用端到端的拥塞控制而不是网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈</p></blockquote><ul><li><p>一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率</p></li><li><p>一个确认报文段只是该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能过增加发送方的速率</p></li><li><p>带宽检测</p><ul><li>增加其速率以响应到达的ACK，除非出现丢包事件，此时才减小发送速率</li></ul></li><li><p><strong>TCP拥塞控制算法</strong></p><ul><li><p>强制部分</p><ul><li><p>慢启动</p><ul><li>cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加一个MSS，再次翻番</li><li>如果存在一个超时指示的丢包事件（即拥塞），用ssthresh记录cwnd的值，TCP发送方将cwnd设置为1并重新开始慢启动过程。</li><li>如果检测到3个冗余的AVK，这时TCP执行一种快速重传，并进入快速恢复状态（cwnd &#x3D; ssthresh + 3）</li></ul></li><li><p>拥塞避免</p><ul><li>一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远，因此TCP无法每过一个RRT再将cwnd翻番，而是每一个RRT增加一个MSS</li></ul></li></ul></li><li><p>非必需</p><ul><li>快速恢复</li></ul></li></ul></li></ul><blockquote><p>TCP分岔</p><p>​在客户近邻搭建服务器，用该服务器建立与数据中心的连接，客户只需要与近邻服务器来间接访问数据中心数据，可以改善性能</p></blockquote><h1 id="第4章：网络层：数据平面"><a href="#第4章：网络层：数据平面" class="headerlink" title="第4章：网络层：数据平面"></a>第4章：网络层：数据平面</h1><blockquote><p>网络层数据平面的功能，即网络层中每台路由器的功能，该数据平面功能决定到达路由器输入链路之一的数据报（即网络层的分组）如何转发到该路由器的输出链路之一</p><p>网络层的控制平面功能，即网络范围的逻辑，该控制平面功能控制数据沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。</p></blockquote><h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><ul><li>每台路由器的<strong>数据平面</strong>的主要作用是从其输入链路向其输出链路转发数据报；</li><li><strong>控制平面</strong>的主要作用是协调这些本地的每路由器转发动作，使得数据报沿着源和目的地之间的路由器路径最终进行端到端的传送</li><li><strong>转发</strong>是指将分组从输入链路接口转移到适当的输出链路接口的路由器本地操作来实现。<ul><li>转发发生的时间尺度很短（通常为几纳秒），因此通常用硬件来实现</li></ul></li><li><strong>路由选择</strong>是指分组从源到目的地所采取的端到端路径的网络范围处理过程。<ul><li>路由器的发生的时间尺度长得多（通常为几秒），因此通常用软件来实现。</li></ul></li></ul><img src="计算机网络.assets/image-20230311213128984.png" alt="image-20230311213128984" style="zoom:50%;" /><h3 id="网络层可能提供的服务"><a href="#网络层可能提供的服务" class="headerlink" title="网络层可能提供的服务"></a>网络层可能提供的服务</h3><ul><li><p>确保交付</p></li><li><p>具有时延上界的确保交付</p></li><li><p>有序分组交付</p></li><li><p>确保最小带宽交付</p></li><li><p>安全性</p></li><li><p>因特网的网络层提供了单一的服务，称为<strong>尽力而为服务</strong>。</p><ul><li>使用尽力而为服务，传送的分组既不能保证以它们的发送顺序被接收，也不能保证它们最终交付；</li><li>既不能保证端到端的时延，也不能保证有最小的带宽</li><li>因特网的基本尽力而为服务模型与适当带宽供给相结合已经被证明超过”足够好“，能够应用于大量应用</li></ul></li><li><p>某些分组交换机称为<strong>链路层交换机</strong>，基于链路层帧中的字段值做出转发决定，这些交换机因此被称为链路层（第2层）设备</p></li><li><p>其他分组交换机被称为<strong>路由器</strong>，基于网络层数据报中的首部字段值做出转发决定。路由器因此是网络层（第3层）设备</p></li></ul><img src="计算机网络.assets/image-20230311213242129.png" alt="image-20230311213242129" style="zoom:50%;" /><h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><h3 id="路由器体系结构"><a href="#路由器体系结构" class="headerlink" title="路由器体系结构"></a>路由器体系结构</h3><img src="计算机网络.assets/1678502743689.jpg" alt="1678502743689" style="zoom:25%;" /><h3 id="输入端口处理和基于目的地转发"><a href="#输入端口处理和基于目的地转发" class="headerlink" title="输入端口处理和基于目的地转发"></a>输入端口处理和基于目的地转发</h3><img src="计算机网络.assets/1678506622648.jpg" alt="1678506622648" style="zoom:25%;" /><h4 id="查找技术"><a href="#查找技术" class="headerlink" title="查找技术"></a>查找技术</h4><ul><li><p>最长前缀匹配规则</p></li><li><p>三态内容可寻址存储器</p></li><li><p>必须采取的其他动作</p><ul><li>必须出现物理层和链路层处理</li><li>必须检查分组的版本号、检验和以及寿命字段，并且重写后两个字段</li><li>必须更新用于网络管理的计数器（如接收到的IP数据报的数目）</li></ul></li></ul><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><img src="计算机网络.assets/1678507332296.jpg" alt="1678507332296" style="zoom:25%;" /><ul><li>经内存交换<ul><li>分组经过内存进行交换</li></ul></li><li>经总线交换<ul><li>一次只有一个分组能够跨越总线</li></ul></li><li>经互联网络交换<ul><li>纵横式交换机式<strong>非阻塞的</strong></li><li>如果来自两个不同输入端口的两个分组其目的地为相同的输出端口，则分组必须在输入端等待</li><li>更为复杂的互联网络使用多级交换元素<ul><li>一个输入端口将一个分组分成K个较小的块，并且通过N个交换结构中的K个发送（”喷射“）这些块到所选择的输出端口，输出端口再将K个块装配成还原成初始的分组</li></ul></li></ul></li></ul><h3 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h3><img src="计算机网络.assets/1678519530797.jpg" alt="1678519530797" style="zoom: 50%;" /><ul><li>排队的位置将取决于</li></ul><h4 id="输入排队"><a href="#输入排队" class="headerlink" title="输入排队"></a>输入排队</h4><ul><li>如果位于两个输出队列前端的两个分组是发往同意输出队列的，则其中的一个分组将被阻塞</li><li>线路前部阻塞</li></ul><h4 id="输出队列"><a href="#输出队列" class="headerlink" title="输出队列"></a>输出队列</h4><ul><li>N个到达分组必须排队等待输出链路传输</li><li>没有足够内存来缓存一个分组时，要么丢弃尾部分组（弃尾），要么删除一个或多个分组</li></ul><h3 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h3><ul><li>先进先出FIFO</li><li>优先权排队<ul><li>同一优先级按FIFO</li></ul></li><li>循环和加权公平排队<ul><li>循环调度不同类的队列</li></ul></li><li>加权公平排队WFQ<ul><li>循环调度不同类的队列</li><li>WFQ与循环排队不同之处在于，每个类在任何时间间隔内可能收到不同数量的服务</li></ul></li></ul><h2 id="网际协议：IPv4、寻址、IPv6及其他"><a href="#网际协议：IPv4、寻址、IPv6及其他" class="headerlink" title="网际协议：IPv4、寻址、IPv6及其他"></a>网际协议：IPv4、寻址、IPv6及其他</h2><h3 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h3><img src="计算机网络.assets/1678521381638.jpg" alt="1678521381638" style="zoom: 25%;" /><ul><li>协议<ul><li>该字段指示了IP数据报的数据部分应交给哪个特定的运输层协议</li><li>IP数据报中的协议号相当于运输层中端口号的作用</li></ul></li><li>首部检验和<ul><li>只对IP首部计算了检验和</li></ul></li><li>IPv6已经去掉了IP选项</li></ul><h3 id="IPv4数据报分片"><a href="#IPv4数据报分片" class="headerlink" title="IPv4数据报分片"></a>IPv4数据报分片</h3><ul><li><p>一个链路层帧能够承载的最大数据量叫做<strong>最大传送单元</strong>（Maximum Transmission Unit，MTU）</p><ul><li>MTU严格限制着IP数据报的长度，对于大于MTU的IP数据报要进行分片</li><li>数据报的重新组装的工作放在端系统中</li></ul></li><li><p>为了让目的主机执行这些重新组装的任务，IPv4的设计者将<em>标识、标志和片偏移</em>字段放在IP数据报的首部中</p></li></ul><h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><ul><li>IP地址按照<strong>点分十进制记法</strong></li><li>子网<ul><li>子网掩码</li></ul></li><li>一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址<ul><li>在这种情况下，该组织内部的设备的IP地址将共享共同的前缀</li><li>当该组织的外部的一台路由器转发一个数据报，且该数据报的目的地址位于该组织内部时，仅需要考虑该地址的前面x比特，这相当大地减小了在这些路由器中转发表的长度</li></ul></li></ul><h4 id="获取一块地址"><a href="#获取一块地址" class="headerlink" title="获取一块地址"></a>获取一块地址</h4><ul><li>ISP将自己分配的地址分组给组织（子网）使用</li><li>ICANN组织<ul><li>分配IP地址，管理DNS根服务器</li></ul></li></ul><h4 id="获取主机地址：动态主机配置协议DHCP"><a href="#获取主机地址：动态主机配置协议DHCP" class="headerlink" title="获取主机地址：动态主机配置协议DHCP"></a>获取主机地址：动态主机配置协议DHCP</h4><ul><li>使某给定主机每次与网络连接时能得到一个相同的IP地址</li><li>或者某主机将被分配一个<strong>临时的IP地址</strong>，每次与网络连接时该地址也许是不同的</li><li>由于DHCP具有将主机连接进一个网络的网络相关方面的自动能力，故它又常被称为<strong>即插即用协议</strong>或<strong>零配置协议</strong></li></ul><h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><ul><li>NAT使能路由器</li></ul><img src="计算机网络.assets/1678524455689-1678524475290-7.jpg" alt="1678524455689" style="zoom:25%;" /><ul><li><p>NAT对外界的行为就如同一个具有单一IP地址的单一设备</p></li><li><p>NAT工作原理</p><ul><li>家庭网络主机请求某台Web服务器上的一个网页，该主机为其指派了一个端口号，NAT接收到该数据报后为其跟换一个新的端口号，将该主机的IP替换为NAT的IP地址。</li><li>当外界报文到达NAT路由器后，路由器使用目的IP地址与目的端口号从NAT转换表中检索出家庭网络浏览器使用的适当IP地址和目的端口号</li></ul></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="IPv6的数据格式"><a href="#IPv6的数据格式" class="headerlink" title="IPv6的数据格式"></a>IPv6的数据格式</h4><img src="计算机网络.assets/1678536732173.jpg" alt="1678536732173" style="zoom:25%;" /><ul><li>流标签<ul><li>能够对一条流中的某些数据报给出优先权，或者它能够用来给来自某些应用（例如IP话音）的数据报给出更高的优先权</li></ul></li><li>跳限制<ul><li>相当于寿命</li></ul></li></ul><h4 id="IPv4到IPv6的迁移"><a href="#IPv4到IPv6的迁移" class="headerlink" title="IPv4到IPv6的迁移"></a>IPv4到IPv6的迁移</h4><ul><li>将两台IPv6路由器之间的中间IPv4路由器的集合称为一个<strong>隧道</strong></li><li>引用应用层协议比引用网络层协议快的多</li></ul><h4 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h4><ul><li>软件定义网络（SDN）</li><li>通用”匹配加动作“范式<ul><li>将分组转发到一个或多个输出端口（就像在基于目的地转发中一样）</li><li>跨越多个通向服务的离开接口进行负载均衡分组（就像在负载均衡一样）</li><li>重写首部值（就像在NAT一样）</li><li>有意识地阻挡&#x2F;丢弃某个分组（就像在防火墙一样）</li><li>为进一步处理和动作而向某一个特定的服务器发送一个分组（就像在DPI一样）</li></ul></li></ul><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><img src="计算机网络.assets/1678539114637.jpg" alt="1678539114637" style="zoom:25%;" /><h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><ul><li>转发<ul><li>一个入分组可以转发到一个特定的物理输出窗口，广播到所有端口（分组到达的端口除外），或通过所选的端口集合进行多播。该分组可能被封装并发送到用于该设备的远程控制器。该控制器则可能（或不可能）对该分组采取某些动作，包括安装新的流表项，以及可能将分组返回给该设备以在更新的流表项规则集合下进行转发</li></ul></li><li>丢弃<ul><li>没有动作的流表项表明某个匹配的分组应当被丢弃</li></ul></li><li>修改字段<ul><li>在分组被转发到所选的输出端口之前，分组首部10个字段（除了IP协议字段外的所有第二、三、四层的字段）中的值可以重写</li></ul></li></ul><h1 id="第5章：网络层：控制平面"><a href="#第5章：网络层：控制平面" class="headerlink" title="第5章：网络层：控制平面"></a>第5章：网络层：控制平面</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><strong>每路由器控制</strong><ul><li>每台路由器中运行一种路由选择算法的情况</li></ul></li><li><strong>逻辑集中式控制</strong><ul><li>逻辑集中式控制器计算并分发转发表以供每台路由器使用的情况</li><li>这种控制器经一种定义良好的协议与每台路由器中的一个控制代理（CA）进行交互，以配置和管理该路由器的转发表</li><li>CA一般具有很少功能，其任务是与控制器通信并按控制器命令行事</li><li>与路由选择算法不同，这些CA不能相互交互，也不能主动参与计算转发表<ul><li>这是每路由器控制和逻辑集中式控制之间的关键差异</li></ul></li></ul></li></ul><h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><ul><li>集中式和分散式<ul><li><strong>集中式路由选择算法</strong><ul><li>以所有节点之间的连通性及所有链路的开销的输入</li><li>具有全局状态的算法通常被称作&#x3D;&#x3D;<strong>链路状态（Link State）算法</strong>&#x3D;&#x3D;</li></ul></li><li><strong>分散式路由选择算法</strong><ul><li>通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径</li><li>例如：&#x3D;&#x3D;<strong>距离向量（Distance-Vector，DV）算法</strong>&#x3D;&#x3D;</li></ul></li></ul></li><li>静态还是动态<ul><li><strong>静态路由选择算法</strong><ul><li>路由随时间的变化非常缓慢，通常是人工进行调整</li></ul></li><li><strong>动态路由选择算法</strong><ul><li>随着网络流量负载或拓扑发生变化而改变路由选择路径</li><li>更容易受到诸如路由选择循环、路由震荡之类问题的影响</li></ul></li></ul></li><li>负载敏感或负载迟钝<ul><li><strong>负载敏感算法</strong></li><li><strong>负载迟钝</strong><ul><li>当今的因特网路由选择算法都是&#x3D;&#x3D;<strong>负载迟钝</strong>&#x3D;&#x3D;的，因为某条链路开销不明确地反映其当前（或最近）的拥塞水平</li></ul></li></ul></li></ul><h3 id="链路状态路由选择算法"><a href="#链路状态路由选择算法" class="headerlink" title="链路状态路由选择算法"></a>链路状态路由选择算法</h3><ul><li>Dijkastra算法</li></ul><h3 id="距离向量路由选择算法"><a href="#距离向量路由选择算法" class="headerlink" title="距离向量路由选择算法"></a>距离向量路由选择算法</h3><ul><li>Bellman-Ford方程<ul><li>d<del>x</del>(y) &#x3D; min<del>v</del> { c(x , v)+ d<del>v</del>(y)}</li><li>方程中min<del>v</del>是对于x的所有邻居的。</li><li>实际上，从x到v遍历完之后，如果我们接下来取从v到y的最低开销路径，则该路径开销将是c(x, v)+d<del>v</del>(y)</li><li>链路开销改变和链路故障</li><li>路由选择环路<ul><li>增加毒性逆转（善意的谎言）</li></ul></li><li>健壮性<ul><li>DV算法中一个不正确的节点计算值会扩散到整个网络</li></ul></li></ul></li></ul><h2 id="因特网中-自治系统内部-的路由选择：OSPF"><a href="#因特网中-自治系统内部-的路由选择：OSPF" class="headerlink" title="因特网中&#x3D;&#x3D;自治系统内部&#x3D;&#x3D;的路由选择：OSPF"></a>因特网中&#x3D;&#x3D;自治系统内部&#x3D;&#x3D;的路由选择：OSPF</h2><ul><li>管理自治<ul><li>因特网是ISP的网络，其中每个ISP都有它自己的路由器网络。ISP通常希望按自己的意愿运行路由器，或对外部隐藏其网络的内部组织面貌</li></ul></li><li>AS（自治系统）<ul><li>通常在一个ISP中的路由器以及与它们互联的链路构成一个AS</li><li>在一个系统内运行的路由选择算法叫做<strong>自治系统内部路由选择协议</strong></li></ul></li><li>开放最短路优先OSPF<ul><li>OSPF是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法</li><li>OSPF协议必须自己实现诸如可靠报文传输、链路状态广播等功能</li><li>OSPF的优点<ul><li>安全</li><li>多条相同开销路径</li><li>对单播与多播路由选择的综合支持</li><li>支持在单个AS中的层次结构</li></ul></li></ul></li></ul><h2 id="ISP之间-的路由选择：BGP"><a href="#ISP之间-的路由选择：BGP" class="headerlink" title="&#x3D;&#x3D;ISP之间&#x3D;&#x3D;的路由选择：BGP"></a>&#x3D;&#x3D;ISP之间&#x3D;&#x3D;的路由选择：BGP</h2><ul><li><p>自治系统间路由选择协议</p><ul><li>因为AS间路由选择协议涉及多个AS之间的写台哦，所以AS通信必须运行相同的AS间路由选择协议，这种协议称为<strong>边界网关协议</strong></li></ul></li><li><p>BGP为每台路由器提供了完成以下任务的手段</p><ul><li>从邻居AS获得前缀的可达性信息</li><li>确定到该前缀的“最好的”路由</li></ul></li></ul><h3 id="通告BGP路由信息"><a href="#通告BGP路由信息" class="headerlink" title="通告BGP路由信息"></a>通告BGP路由信息</h3><ul><li>每台路由器要么是<strong>网关路由器</strong>，要么是一台<strong>内部路由器</strong></li><li>跨越两个AS的BGP连接称为<strong>外部BGP</strong>（eBGP）连接，而在相同AS中的两台路由器之间的BGP会话称为<strong>内部BGP</strong>（iBGP）连接</li><li>热土都路由选择<ul><li>热土豆是自私的算法，尽可能地将分组传给下一个AS</li></ul></li><li>路由选择算法<ul><li>路由被指派一个<strong>本地偏好</strong></li><li>从余下路由中（所有具有相同的最高本地偏好值），将选择具有最短AS-PATH的路由。</li><li>从余下的路由中（所有具有相同的最高本地偏好值和相同的AS-PATH长度）<ul><li>使用热土豆路由选择</li></ul></li><li>如果仍留下多条路由，该路由器使用BGP标识符来选择路由</li></ul></li></ul><h3 id="IP任播"><a href="#IP任播" class="headerlink" title="IP任播"></a>IP任播</h3><ul><li>许多分散的不同地理位置，替换不同服务器上的相同内容</li><li>让每个用户从最靠近的服务器访问内容——&gt;使用BGP</li></ul><h3 id="拼装在一起：在因特网中实现"><a href="#拼装在一起：在因特网中实现" class="headerlink" title="拼装在一起：在因特网中实现"></a>拼装在一起：在因特网中实现</h3><ul><li>p264</li></ul><h2 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h2><ul><li>SDN体系结构具有有4个关键特征<ul><li>基于流转发<ul><li>SDN控制的交换机的分组转发工作，能够基于运输层、网络层或链路层首部中任意数量的首部字段值进行</li></ul></li><li>数据平面与控制平面分离<ul><li><img src="计算机网络.assets/1678762116415.jpg" alt="1678762116415" style="zoom: 25%;" /></li></ul></li><li>网络控制功能：位于数据平面交换机外部<ul><li>控制器是逻辑上集中的，通常在几台服务器上实现，这些服务提供协调的、可扩展的性能和高可用性</li></ul></li><li>可编程的网络</li></ul></li></ul><h3 id="SDN控制平面：SDN控制器和SDN网络控制应用程序"><a href="#SDN控制平面：SDN控制器和SDN网络控制应用程序" class="headerlink" title="SDN控制平面：SDN控制器和SDN网络控制应用程序"></a>SDN控制平面：SDN控制器和SDN网络控制应用程序</h3><img src="计算机网络.assets/1678762842351.jpg" alt="1678762842351" style="zoom:25%;" /><h3 id="OpenFlow协议"><a href="#OpenFlow协议" class="headerlink" title="OpenFlow协议"></a>OpenFlow协议</h3><ul><li>OpenFlow协议运行在SDN控制器和SDN控制的交换机或其他实现OpenFlow API的设备之间</li></ul><h3 id="数据平面和控制平面交互的例子"><a href="#数据平面和控制平面交互的例子" class="headerlink" title="数据平面和控制平面交互的例子"></a>数据平面和控制平面交互的例子</h3><img src="计算机网络.assets/1678763886581.jpg" alt="1678763886581" style="zoom:25%;" /><h2 id="ICMP：因特网控制报文协议"><a href="#ICMP：因特网控制报文协议" class="headerlink" title="ICMP：因特网控制报文协议"></a>ICMP：因特网控制报文协议</h2><ul><li>被主机和路由器用来彼此沟通网络层信息</li><li>最典型用途是差错报告</li><li>Traceroute程序也是用ICMP</li></ul><h1 id="第6章：链路层和局域网"><a href="#第6章：链路层和局域网" class="headerlink" title="第6章：链路层和局域网"></a>第6章：链路层和局域网</h1><h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><ul><li>将运行链路层协议的任何设备称为<strong>节点</strong><ul><li>节点包括：主机、路由器、WiFi接入点和交换机</li></ul></li><li>再通过特定的链路时，传输节点将数据报封装在<strong>链路层帧</strong>中，并将该帧传送到链路中</li><li>点对点链路、广播链路</li></ul><h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><ul><li>成帧<ul><li>一个帧由数据字段和若干首部字段组成</li></ul></li><li>链路接入<ul><li><strong>媒体访问控制</strong>（MAC）协议规定了帧在链路上的传输规则</li></ul></li><li>可靠交付<ul><li>通过确认和重传</li><li>对于无线链路使用可靠交付</li><li>对于有线的链路（如光纤、同轴电缆和许多双绞线链路）</li></ul></li><li>差错检测和纠错<ul><li>使用硬件进行检测</li><li>不仅能检测帧中出现的比特差错，还能精准定位帧中出错的位置</li></ul></li></ul><h3 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h3><ul><li>路由器的线路卡中</li><li>主机体系结构<ul><li>链路层的主体部分是在<strong>网络适配器</strong>中实现的，网络适配器有时称为<strong>网络接口卡</strong></li><li>位于网络适配器核心的是链路层控制器<ul><li>该控制器通常是实现了许多链路层服务（成帧，链路接入、差错检测等）的专用芯片</li><li>链路层控制器很多功能是在硬件实现的</li></ul></li><li>部分链路层实在运行于CPU上的软件实现的<ul><li>链路层软件组件实现了高层链路层功能，如组装链路层寻址信息和激活控制器硬件</li></ul></li></ul></li><li>链路层是软件和硬件的结合体</li></ul><img src="计算机网络.assets/1678869501544.jpg" alt="1678869501544" style="zoom:25%;" /><h2 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h2><ul><li><p>奇偶检验</p><ul><li>p289</li></ul></li><li><p>检验和方法</p><ul><li>p290</li></ul></li><li><p>循环冗余检测</p><ul><li>p291</li></ul></li></ul><h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><ul><li>对于广播链路<ul><li>多个发送节点和多个接收节点都连接到相同的、单一的、共享的广播信道</li></ul></li><li>将任何多路访问协议划分为3种类型之一<ul><li><strong>信道划分协议</strong></li><li><strong>随机接入协议</strong></li><li><strong>轮流协议</strong></li></ul></li></ul><h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><ul><li>时分多路复用（TDM）</li><li>频分多路复用（FDM）</li><li><strong>码分多址</strong><ul><li>CDMA对每个节点分配一种不同的编码。然后每个节点用它唯一的编码来对它发送的数据进行编码</li><li>CDMA的使用于无线信道紧密相关</li></ul></li></ul><h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><ul><li>ALOHA</li><li>CSMA&#x2F;CD</li><li>轮流协议</li><li>DOCSIS<ul><li>用于电缆因特网接入的链路层协议</li></ul></li></ul><h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2><h3 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><ul><li>事实上，并不是主机或路由器具有链路层地址，而是它们的适配器（即网络接口）具有链路层地址</li><li>MAC地址是扁平的，而IP地址层次的（网络部分+主机部分）</li></ul><h4 id="地址解析协议（ARP）"><a href="#地址解析协议（ARP）" class="headerlink" title="地址解析协议（ARP）"></a>地址解析协议（ARP）</h4><ul><li>将网络层地址和链路层地址之间进行转换</li><li>于DNS解析器的区别<ul><li>DNS为在因特网中任何地方的主机解析主机名</li><li>ARP只为在同一个子网上的主机和路由器解析IP地址</li></ul></li><li>子网内方式<ul><li>ARP向子网中发送广播帧来查询</li><li>适配的配置器会发挥响应的标准帧</li></ul></li><li>吧ARP看成是跨越链路层和网络层边界两边的协议</li></ul><h4 id="发送数据报到子网以外"><a href="#发送数据报到子网以外" class="headerlink" title="发送数据报到子网以外"></a>发送数据报到子网以外</h4><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li><p>有线局域网</p></li><li><p>以太网帧结构</p></li></ul><img src="计算机网络.assets/1678869617597.jpg" alt="1678869617597" style="zoom:25%;" /><h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><ul><li>交换机自身对子网中的主机和路由器是<strong>透明的</strong></li><li>自学习</li><li>即插即用设备</li><li>双工的</li><li>性质<ul><li>消除碰撞</li><li>异质的链路<ul><li>将链路彼此隔离</li></ul></li><li>管理</li></ul></li></ul><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><h2 id="链路虚拟化：网络作为链路层"><a href="#链路虚拟化：网络作为链路层" class="headerlink" title="链路虚拟化：网络作为链路层"></a>链路虚拟化：网络作为链路层</h2><h2 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h2><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/25/hello-world/"/>
      <url>/2023/07/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
