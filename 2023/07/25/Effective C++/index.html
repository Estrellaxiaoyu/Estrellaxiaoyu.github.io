<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Effective C++笔记 | Estrella博客</title><meta name="author" content="Estrella"><meta name="copyright" content="Estrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="笔记来自《Effective C++》">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++笔记">
<meta property="og:url" content="https://estrellaxiaoyu.github.io/2023/07/25/Effective%20C++/index.html">
<meta property="og:site_name" content="Estrella博客">
<meta property="og:description" content="笔记来自《Effective C++》">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://estrellaxiaoyu.github.io/img/%E7%AC%94%E8%AE%B0p2.webp">
<meta property="article:published_time" content="2023-07-25T09:54:53.000Z">
<meta property="article:modified_time" content="2023-07-30T05:45:01.907Z">
<meta property="article:author" content="Estrella">
<meta property="article:tag" content="Estrella的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://estrellaxiaoyu.github.io/img/%E7%AC%94%E8%AE%B0p2.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://estrellaxiaoyu.github.io/2023/07/25/Effective%20C++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":100},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective C++笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-30 13:45:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/%E7%AC%94%E8%AE%B0p2.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Estrella博客"><span class="site-name">Estrella博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Effective C++笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-25T09:54:53.000Z" title="发表于 2023-07-25 17:54:53">2023-07-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-30T05:45:01.907Z" title="更新于 2023-07-30 13:45:01">2023-07-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Effective C++笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="条款0：导读"><a href="#条款0：导读" class="headerlink" title="条款0：导读"></a>条款0：导读</h1><ul>
<li>每个函数的声明揭示其签名式（signature），也就是参数和返回类型</li>
<li>除非有一个好理由允许构造函数被用于隐式类型转换，否则把它<strong>声明为explicit</strong></li>
</ul>
<h1 id="1-让自己习惯C"><a href="#1-让自己习惯C" class="headerlink" title="1. 让自己习惯C++"></a>1. 让自己习惯C++</h1><h2 id="条款1：视C-为一个语言联邦"><a href="#条款1：视C-为一个语言联邦" class="headerlink" title="条款1：视C++为一个语言联邦"></a>条款1：视C++为一个语言联邦</h2><ul>
<li><p>C++语言的四个层次：</p>
<ul>
<li>C。没有C++的面向对象，没有模板，没有异常，没有重载等。</li>
<li>Object-Oriented C++。这部分也就是C with Classes。classes、封装、继承、多态、虚函数。这部分是面向对象的特性。</li>
<li>Template C++。这部分是C++的泛型编程部分。这部分带来的是template metaprogramming，也就是所谓的模板元编程。</li>
<li>STL。STL是个template程序库。它对容器、迭代器、算法及函数对象的规约，并且是以templates及程序库的方式构建出来。</li>
</ul>
<p>每个层次应该有自己的最佳实践。例如对于C层次，传入函数最佳的实践应该是传入值，而不是指针，而对于C with classes层次，则以传递引用为最佳的实践。</p>
</li>
</ul>
<h2 id="条款2：尽量以const，enum，inline代替-define"><a href="#条款2：尽量以const，enum，inline代替-define" class="headerlink" title="条款2：尽量以const，enum，inline代替 #define"></a>条款2：尽量以const，enum，inline代替 #define</h2><blockquote>
<p>宁可以编译器代替预处理器</p>
</blockquote>
<ul>
<li>对于单纯常量，最好使用 const 对象或 enums 替代 #defines</li>
<li>对于形似函数的宏（macros），最好使用 inline 函数替换 #defines</li>
</ul>
<ul>
<li><p>对于全局的，用define定义的值，在预处理的时候会被替换成相应的值，这对于调试的符号表不利。并且用define的符号在多处使用都会要替换，会使编译生成的代码量变大。</p>
</li>
<li><p>对于class的常量，为了只提供一份定义，一般用static const。用define无法创建一个class专属常量，因为#define并不重视作用于，一旦宏被定义，它就在其后的编译过程中有效。有时候，<strong>为了不让获取常量的定义地址，则可以用enum来代替#define</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">enum &#123;NumTurns = 5&#125;;</span><br><span class="line">int scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时候需要用模板函数来代替宏</p>
<p>宏的一些副作用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span><br><span class="line">int a = 5, b = 0;</span><br><span class="line">CALL_WITH_MAX(++a, b); //a被累加两次</span><br><span class="line">CALL_WITH_MAX(++a, b+10); //a被累加一次</span><br></pre></td></tr></table></figure>

<p>这时候可以用模板函数来代替</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void callWithMax(const T &amp;a, const T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">  f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了consts、enums和inlines，我们对预处理器的需求降低了，但是不等于没有。#include仍然是必需品，而#ifdef&#x2F;#ifndef也继续扮演控制编译的重要角色。</p>
</li>
</ul>
<ul>
<li>Static 成员必须在 class 定义式之外被定义（除非它是 const 而且是整数型</li>
</ul>
<h2 id="条款3：-尽可能使用const"><a href="#条款3：-尽可能使用const" class="headerlink" title="条款3：&#x3D;&#x3D;尽可能使用const&#x3D;&#x3D;"></a>条款3：&#x3D;&#x3D;尽可能使用const&#x3D;&#x3D;</h2><blockquote>
<p>加了mutable的成员变量可能总是被更改，即使在const成员函数内</p>
</blockquote>
<ul>
<li><p>将某些东西声明成const可帮助编译器侦测出错误用法。const可被施加于任何作用域的对象、函数参数、函数返回类型、成员函数本体</p>
</li>
<li><p>编译器强制实施 bitwise constness，但你编写程序时**应该使用 “概念上的常量性” **（conceptual constness）</p>
</li>
<li><p>当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用 const 版本<strong>避免代码重复</strong></p>
</li>
<li><p>const 修饰的 operator* 的<strong>返回类型</strong>，可以阻止客户因 ”用户自定义类型“而犯错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a * b = c) ... 		<span class="comment">//原意其实是做一次比较操作</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="条款4：确定对象被使用前已被初始化"><a href="#条款4：确定对象被使用前已被初始化" class="headerlink" title="条款4：确定对象被使用前已被初始化"></a>条款4：确定对象被使用前已被初始化</h2><blockquote>
<p>编译单元：指产出单一目标文件（single object file）的那些源码。</p>
<p>基本上它时单一源代码文件加上其所含入的头文件（#include files）</p>
</blockquote>
<ul>
<li>为内置型对象进行手动初始化，因为C++不保证初始化它们</li>
<li>构造函数最好使用成员初值列（ member initialization list ），而不要在构造函数本体内使用赋值操作（ assignment )。初值列列出的成员变量，其排序次序应该和它们在class中的声明次序相同</li>
<li>为免除 “跨编译单元之<strong>初始化次序</strong>” 问题，请以 local static 对象替换 non-local static 对象<ul>
<li>local static：在函数体内定义初始化static对象，然后返回该对象引用，这个是单例模式一个常见的实现手法。</li>
<li>C++对于 “定义在不同编译单元内的 non-local static 对象” 的初始化次序并无明确定义</li>
</ul>
</li>
</ul>
<h1 id="2-构造-析构-赋值运算"><a href="#2-构造-析构-赋值运算" class="headerlink" title="2. 构造&#x2F;析构&#x2F;赋值运算"></a>2. 构造&#x2F;析构&#x2F;赋值运算</h1><h2 id="条款5：了解C-默默编写并调用哪些函数"><a href="#条款5：了解C-默默编写并调用哪些函数" class="headerlink" title="条款5：了解C++默默编写并调用哪些函数"></a>条款5：了解C++默默编写并调用哪些函数</h2><blockquote>
<p>内含 reference 成员和 const 成员，编译器会拒绝生成赋值构造函数</p>
<p>如果某个base classes 将 copy assignment 操作符声明为 private 其 derived classes 编译器会拒绝生成赋值构造函数</p>
</blockquote>
<ul>
<li>编译器可以暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符，以及析构函数</li>
</ul>
<h2 id="条款6：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款6：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款6：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款6：若不想使用编译器自动生成的函数，就该明确拒绝</h2><ul>
<li>为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为private并且不予实现。使用想<strong>Uncopyable</strong>这样的base class也是一种做法<ul>
<li><strong>Uncopyable</strong>：derived class 继承 Uncopyable 来把自身的默认拷贝&#x2F;赋值函数给禁止（因为 Uncopyable 的拷贝&#x2F;复制构造函数时 private 的）</li>
</ul>
</li>
</ul>
<h2 id="条款7：为多态基类声明-virtual-析构函数"><a href="#条款7：为多态基类声明-virtual-析构函数" class="headerlink" title="条款7：为多态基类声明 virtual 析构函数"></a>条款7：为多态基类声明 virtual 析构函数</h2><ul>
<li><p>必须为pure virtual 析构函数提供定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AWOV</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">AWOV</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">AWOV::~<span class="built_in">AWOV</span>()&#123; &#125;	<span class="comment">//pure virtual析构函数的定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>polymorphic（带多态性质）base classes 应该声明一个 virtual 析构函数。如果 class 带有任何 virtual 函数，它就应该拥有一个virtual 析构函数</p>
</li>
<li><p>Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性质（polymorphically），就不应该声明为 virtual 函数</p>
</li>
</ul>
<h2 id="条款8：-别让异常逃离析构函数"><a href="#条款8：-别让异常逃离析构函数" class="headerlink" title="条款8：&#x3D;&#x3D;别让异常逃离析构函数&#x3D;&#x3D;"></a>条款8：&#x3D;&#x3D;别让异常逃离析构函数&#x3D;&#x3D;</h2><ul>
<li><p>析构函数绝对不要突出异常。如果一个被析构函数调用的函数可能抛出异常，<strong>析构函数应该捕捉任何异常</strong>，然后吞下它们（不传播）或结束程序。</p>
</li>
<li><p>如果用户需要对某个操作函数运行期间抛出异常<strong>做出反应</strong>，那么 class 应该<strong>提供一个普通函数</strong>（下文提供的close()）（而非在析构函数中）执行该操作</p>
</li>
<li><p>假设一个数据库连接的类，为了防止客户忘记关闭连接，往往会在析构的时候尝试关闭连接，例如</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class DBCONN</span><br><span class="line">&#123;</span><br><span class="line">~DBCONN()</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">  	db.close();</span><br><span class="line">  &#125;catch </span><br><span class="line">  &#123;</span><br><span class="line">  	//记下错误，继续执行或者调用abort，终止程序</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">	DB db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这种处理方式的缺点是，客户没有太多选择，要么是abort终止程序，要么是继续执行。</p>
</li>
<li><p>为了让客户有选择，可以<strong>单独提供一个close函数</strong>，让用户自己处理异常。如果用户决定自己不处理，那么析构函数的时候再采用一个默认的方式来处理。</p>
</li>
</ul>
<h2 id="条款9：绝不在构造函数和析构函数过程中调用-virtual-函数"><a href="#条款9：绝不在构造函数和析构函数过程中调用-virtual-函数" class="headerlink" title="条款9：绝不在构造函数和析构函数过程中调用 virtual 函数"></a>条款9：绝不在构造函数和析构函数过程中调用 virtual 函数</h2><ul>
<li><p>在构造和析构期间不要调用 virtual 函数，因为这类调用从不下降至 derived class（比起当前执行构造函数和析构函数的那层）</p>
</li>
<li><p>由于无法使用 virtual 函数从 base classes 向下调用，在构造期间你可以籍由“令 derived classes 将必要信息向上传递至 base classes 构造函数”替换之而加以弥补</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//virtual logTranscation(...) const = 0; 在base classes中调用无法向下传递</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Transcation</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">logTranscation</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line">Transcation::<span class="built_in">Transcation</span>(<span class="type">const</span> std::string&amp; logInfo)&#123;</span><br><span class="line">	...</span><br><span class="line">	logTranscation</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTranscation</span>: <span class="keyword">public</span> Transcation&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BuyTrancation</span>( parameters );</span><br><span class="line">	: <span class="built_in">Transcation</span>(<span class="built_in">createLogString</span>( parameters ))	<span class="comment">//将log信息传递给 base classes 构造函数</span></span><br><span class="line">	&#123; ... &#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> std::string <span class="title">createLogString</span><span class="params">( parameters )</span></span>; <span class="comment">//先于其他初始化，所以Transcation的构造函数在之后</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
<li><p>在构造函数中，调用构造函数的顺序是基类-&gt;子类，当基类在构造的时候，子类的部分还没有开始构造，这时候，如果调用虚函数，<strong>只会调用基类版本</strong>的，不符合虚函数的语义。</p>
</li>
<li><p>在析构函数中，调用析构函数的顺序是子类-&gt;基类，当基类在析构的时候，子类的部分已经析构完成，这时候，如果调用虚函数，同样<strong>只会调用基类版本</strong>的，不符合虚函数的语义。</p>
</li>
</ul>
<h2 id="条款10：令-operator-返回一个-reference-to-this"><a href="#条款10：令-operator-返回一个-reference-to-this" class="headerlink" title="条款10：令 operator&#x3D; 返回一个 reference to *this"></a>条款10：令 operator&#x3D; 返回一个 <em>reference to</em> *this</h2><ul>
<li>令赋值（assignment）操作符返回一个reference to *this</li>
</ul>
<h2 id="条款11：在-operator-中-处理“自我赋值“"><a href="#条款11：在-operator-中-处理“自我赋值“" class="headerlink" title="条款11：在 operator&#x3D; 中&#x3D;&#x3D;处理“自我赋值“&#x3D;&#x3D;"></a>条款11：在 operator&#x3D; 中&#x3D;&#x3D;处理“自我赋值“&#x3D;&#x3D;</h2><ul>
<li><p>确保当对象自我赋值时operator&#x3D; 有良好的行为。其中技术包括比较”来源对象“和”目标对象“的地址、精心周到的语句顺序、以及copy and swap</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//比较”来源对象“和”目标对象“的地址</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> = &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;		<span class="comment">//证同测试（identity test），如果是自我赋值就不做任何事</span></span><br><span class="line">	<span class="keyword">delete</span> pb;</span><br><span class="line">	pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//精心周到的语句顺序</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Bitmap* pOring = pb;		<span class="comment">//记住原先的pb</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);	<span class="comment">//令pb指向 *pb的一个复件（副本）</span></span><br><span class="line">    <span class="keyword">delete</span> pOring;				<span class="comment">//删除原先的pb</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//copy and swap</span></span><br><span class="line"><span class="comment">//————1————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>;		<span class="comment">//交换*this和rhs的数据</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp;rhs)&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);			<span class="comment">//temp离开作用域后自动释放了原来的pb</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//————2————</span></span><br><span class="line">Widget&amp; Widget::oprator=(Widget rhs)&#123;	<span class="comment">//rhs是一份拷贝，相当于temp</span></span><br><span class="line">	<span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定任何一个函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确</p>
</li>
</ul>
<h2 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h2><ul>
<li>Copying 函数应该确保复制 ”对象内的所有成员变量“ 以及 ”所有 base classes 成分“</li>
<li>不要尝试以某个 copying 函数 实现另一个 copying（比如赋值） 函数。应该将<strong>共同机能</strong>放进第三个函数中，并由两个copying函数共同调用</li>
</ul>
<h1 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3. 资源管理"></a>3. 资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><blockquote>
<p>RAII：Resource Acquisition Is Initialization</p>
<p>资源取得时机就是初始化时机</p>
</blockquote>
<ul>
<li>为防止资源泄露，请<strong>使用RAII对象</strong>，它们<strong>在构造函数中获得资源并在析构函数中释放资源</strong></li>
<li>两个常被使用的 RAII classes 分别是 tr1::shared_ptr 和 auto_ptr。前者通常是最佳选择，因为copy行为比较直观。若选择 auto_ptr，复制动作会使它（被复制物）指向 null</li>
</ul>
<h2 id="条款14：在资源管理类中小心-copying-行为"><a href="#条款14：在资源管理类中小心-copying-行为" class="headerlink" title="条款14：在资源管理类中小心 copying 行为"></a>条款14：在资源管理类中小心 copying 行为</h2><ul>
<li>复制 RAII 对象必须一并复制它管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为</li>
<li>普遍而常见的 RAII class copying 行为是：<strong>抑制 copying</strong>（继承 Uncopyable base classes）、施行引用计数法（reference counting）。不过其他行为也能被实现</li>
<li>引用计数法—&gt;shared_ptr：可以自定义删除器（客制化析构函数，例如析构操作是释放锁（解开）而不是将锁资源释放）</li>
<li>复制底部资源（heap上的）：需要进行**&#x3D;&#x3D;深度拷贝&#x3D;&#x3D;**，不论指针或其所指内存都会被复制出一个复件（避免重复delete资源）、</li>
<li>转移底部资源的所有权：确保RAII对象指向一个未加工的资源。即使复制，此时资源的拥有权从被复制物转移到目标物（auto_ptr）</li>
</ul>
<h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><ul>
<li><p>APIs往往要求访问原始资源（raw resources），所以每一个 RAII classes 应该提供一个 ”取得其所管理之资源“ 的办法</p>
</li>
<li><p>对原始资源的访问可能经由显示转换或隐式转换。一般而言<strong>显示转换比较安全</strong>，但<strong>隐式转换</strong>对客户<strong>比较方便</strong></p>
</li>
</ul>
<h2 id="条款16：成对使用-new-和-delete-时要采用相同形式"><a href="#条款16：成对使用-new-和-delete-时要采用相同形式" class="headerlink" title="条款16：成对使用 new 和 delete 时要采用相同形式"></a>条款16：成对使用 new 和 delete 时要采用相同形式</h2><ul>
<li><p>如果你在new表达式中使用[]，必须在相应的 delete 表达式中也使用[]。如果你在 new 表达式中不使用[]，一定不要在相应的 delete 表达式中使用[]</p>
<ul>
<li>动态分配的 arrays 可能包含额外的空间存放元素</li>
</ul>
</li>
<li><p>为避免诸如此类的错误，最好尽量不要对数组形式做 typedefs 动作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];	<span class="comment">//每个人的地址有4行，每行都是一个string</span></span><br><span class="line">std::string *pa1 = <span class="keyword">new</span> AddressLines; 	<span class="comment">//注意，”new AddressLines“返回一个string*，就像”new string[4]“一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pa1； 	<span class="comment">//未定义</span></span><br><span class="line"><span class="keyword">delete</span> [] pa1;	 <span class="comment">//很好</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="条款17：-以独立语句将-newed-对象置入智能指针"><a href="#条款17：-以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款17：&#x3D;&#x3D;以独立语句将 newed 对象置入智能指针&#x3D;&#x3D;"></a>条款17：&#x3D;&#x3D;以独立语句将 newed 对象置入智能指针&#x3D;&#x3D;</h2><ul>
<li><p>以独立语句将 newed 对象存储于（置入）智能指针中。如果不这样做，<strong>一旦异常被抛出</strong>，有可能导致<strong>难以察觉的资源泄露</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());  <span class="comment">//shared_ptr的构造函数是explicit的</span></span><br><span class="line"><span class="comment">//new Widget一定在构造函数前发生，如果在调用new Widget之后，先调用了priority()，万一对priority()的调用导致异常，此时new Widget返回的指针将会遗失，引发资源泄漏</span></span><br><span class="line"></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;		<span class="comment">//完成new Widget和调用pw的构造函数两步操作——独立语句</span></span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());						<span class="comment">//和调用priority()分开</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4. 设计与声明"></a>4. 设计与声明</h1><h2 id="条款18：-让接口容易被正确使用，不易被误用"><a href="#条款18：-让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：&#x3D;&#x3D;让接口容易被正确使用，不易被误用&#x3D;&#x3D;"></a>条款18：&#x3D;&#x3D;让接口容易被正确使用，不易被误用&#x3D;&#x3D;</h2><ul>
<li><p>好的接口很容易被正确使用，不容易被勿用。你应该在你的所有接口中努力达成这些性质</p>
<ul>
<li><p>要设计不易被误用的接口</p>
</li>
<li><p>例如，要创建一个时间类型</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date(int month, int year, int day);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面的接口就是容易被误用的接口，因为可能把年月日的顺序给搞错了。</p>
</li>
<li><p>可以给年月日分别设计一个类型，构造函数中传入对应的类型才能正确编译。</p>
</li>
</ul>
</li>
<li><p>”促进正确使用“ 的办法包括<strong>接口一致性</strong>（比如string，vector，list等通过调用相同名字的size()获取长度），以及与内置类型的行为兼容</p>
</li>
<li><p>”阻止误用“ 的办法包括<strong>建立新类型</strong>（12月份-&gt;Month::Dec()）、<strong>限制类型上的操作</strong>（比如opeator *的返回值类型为const），<strong>束缚对象值</strong>（例如返回智能指针，强制用户使用智能指针），以及<strong>消除客户的资源管理责任</strong>（将delete和其他操作<del>引用计数-1</del>封装起来给用户释放资源，如shared_ptr）</p>
</li>
<li><p>tr1::shared_ptr 支持<strong>定制性删除器</strong>（custom deleter）。这可<strong>防范DLL问题</strong>（new&#x2F;delete这对操作在不同动态链接库中，shared_ptr会自动调用本模块的delete函数），可被用来<strong>自动解除互斥锁</strong>（mutexes）等等</p>
</li>
</ul>
<h2 id="条款19：设计-class-犹如设计-type"><a href="#条款19：设计-class-犹如设计-type" class="headerlink" title="条款19：设计 class 犹如设计 type"></a>条款19：设计 class 犹如设计 type</h2><ul>
<li><p>Class 的设计就是 type 的设计。在定义一个新的 type 之前，请确定你已经考虑过本条款覆盖的所有讨论主题</p>
<ul>
<li><p>新type的对象应该如何被创建和销毁</p>
</li>
<li><p>对象的初始化和对象的赋值该有什么样的差别</p>
</li>
<li><p>新type的对象如果被passed by value，意味着什么？即copy构造函数该如何实现</p>
</li>
<li><p>什么是新type的“合法值”？成员函数必须对菲合法值进行必要的错误检查</p>
</li>
<li><p>你的新type需要配合某个继承图系？</p>
</li>
<li><p>你的新type需要什么样的转换？是否需要隐式或者显式转换成其他类型。</p>
</li>
<li><p>什么样的操作符和函数对此新type而言是合理的?该声明哪些函数，哪些应该是member函数，某些则不是。</p>
</li>
<li><p>什么样的标准含税应该驳回？例如，自动生成的拷贝构造函数，赋值函数和析构函数等等。</p>
</li>
<li><p>谁该取用新type的成员？哪些为public、哪些为protected、哪些为private。</p>
</li>
<li><p>什么是新type的“未声明接口”？这个不太懂</p>
</li>
<li><p>你的新type有多么一般化？或许你其实并非定义一个新type，而是定义一整个</p>
<p>types家族。</p>
</li>
<li><p>你真的需要一个新type吗？如果只是定义新的derived class以便为既有的class添加机能，那么说不定单纯定义一个或多个non-member函数或者template更能达到目标。</p>
</li>
</ul>
</li>
</ul>
<h2 id="条款20：宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#条款20：宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款20：宁以 pass-by-reference-to-const 替换 pass-by-value"></a>条款20：宁以 pass-by-reference-to-const 替换 pass-by-value</h2><ul>
<li>尽量以 pass-by-reference-to-const 替换 pass-by-value。前者通常比较高效，并可避免切割问题（slicing problem）<ul>
<li><strong>&#x3D;&#x3D;切割问题&#x3D;&#x3D;<strong>：参数类型为Window w，</strong>如果传递其子类，则其子类的特化信息会被切除</strong></li>
</ul>
</li>
<li>以上规则<strong>并不适用于内置类型</strong>，以及 STL 的迭代器和函数对象。对它们而言，pass-by-value 往往比较合适</li>
</ul>
<h2 id="条款21：必须返回对象时，别妄想返回其-reference"><a href="#条款21：必须返回对象时，别妄想返回其-reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其 reference"></a>条款21：必须返回对象时，别妄想返回其 reference</h2><ul>
<li>绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象（这个需要外部调用delete，而且如果<strong>连续赋值</strong>可能导致内存空间无法释放），或返回 pointer 或 reference 指向一个 local static 对象而<strong>有可能同时需要多个这样的对象</strong>。条款4已经为 ”在单线程模型中合理返回 reference 指向一个 local static 对象“ 提供了一份设计实例</li>
</ul>
<h2 id="条款22：将成员变量声明为-private"><a href="#条款22：将成员变量声明为-private" class="headerlink" title="条款22：将成员变量声明为 private"></a>条款22：将成员变量声明为 private</h2><ul>
<li>切记将变量声明为 private。这可赋予客户<strong>访问数据的一致性</strong>、可细微划分访问控制、允诺约束条件获得保证、并提供 class 作者充分的实现弹性</li>
<li>protected 并不比 public 更具封装性</li>
</ul>
<h2 id="条款23：宁以-non-member、non-friend-替换-member-函数"><a href="#条款23：宁以-non-member、non-friend-替换-member-函数" class="headerlink" title="条款23：宁以 non-member、non-friend 替换 member 函数"></a>条款23：宁以 non-member、non-friend 替换 member 函数</h2><ul>
<li>宁可拿non-member non-friend 函数替换 member 函数。这样做可以<strong>增加封装性、包裹弹性（packaging flexibility）和技能扩展性</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//————1————</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//————2————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser &amp;wb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  wb.<span class="built_in">clearCache</span>();</span><br><span class="line">  wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">  wb.<span class="built_in">removeCookies</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面代码看出，以 non-member-non-friend 函数方式形式来实现 clear 操作会更有封装性，因为它不能访问类里面的数据，更加符合封装的思想。</li>
</ul>
<h2 id="条款24：若所有参数皆需要类型转换，请为此采用-non-member-函数"><a href="#条款24：若所有参数皆需要类型转换，请为此采用-non-member-函数" class="headerlink" title="条款24：若所有参数皆需要类型转换，请为此采用 non-member 函数"></a>条款24：若所有参数皆需要类型转换，请为此采用 non-member 函数</h2><ul>
<li>如果你需要为某个函数的所有参数（<strong>包括被 this 指针所指的那个隐喻参数</strong>）进行类型转换，那么这个函数必须是个 non-member</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational &amp;rhs) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于上面代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rational result = oneHalf * oneEighth;</span><br><span class="line">result = result * oneEighth;</span><br><span class="line">result = oneHalf * <span class="number">2</span>;</span><br><span class="line">result = <span class="number">2</span> * oneHalf; <span class="comment">//有错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>为了使得第四个赋值也能支持，可以把operator*实现成以下<ul>
<li>此函数可以使用 Rational 的 public 接口来实现功能，就不用声明为 friend</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational &amp;lhs, <span class="type">const</span> Rational &amp;rhs);</span><br></pre></td></tr></table></figure>



<h2 id="条款25：-考虑写出一个不抛出异常的-swap-函数"><a href="#条款25：-考虑写出一个不抛出异常的-swap-函数" class="headerlink" title="条款25：&#x3D;&#x3D;考虑写出一个不抛出异常的 swap 函数&#x3D;&#x3D;"></a>条款25：&#x3D;&#x3D;考虑写出一个不抛出异常的 swap 函数&#x3D;&#x3D;</h2><ul>
<li>当 std::swap 对你的类型效率不高时，提供一个swap成员函数，并确定这个函数<strong>不抛出异常</strong></li>
<li>如果你提供一个 <strong>member</strong> swap，也该提供一个 <strong>non-member</strong> swap 用来调用前者。对于 <strong>classes</strong>（而非 <strong>template</strong>），也请<strong>特化std::swap</strong></li>
<li>调用 swap 时应针对 std::swap 使用 using 声明式，然后调用 swap 并且不带任何“命名空间资格修饰”（让编译器自己选择，如果类型匹配，会选择用户自己特化的）</li>
<li>为“用户定义类型”进行 std templates 全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">	...									<span class="comment">//模板化的WidgetImpl等等</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;				<span class="comment">//内含swap成员函数</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		...</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; other)</span></span>&#123;</span><br><span class="line">			<span class="keyword">using</span> std::swap;			<span class="comment">//使用标准库的swap</span></span><br><span class="line">			<span class="built_in">swap</span>(pImpl, other.pImpl);	<span class="comment">//交换的基本数据类型（底层指针），内置类型上的操作绝不会抛出异常</span></span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		WidgetImpl* pImpl;				<span class="comment">//指针，所指对象内含Widget数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span></span>&#123;</span><br><span class="line">		a.<span class="built_in">swap</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::swap;	<span class="comment">//令std::swap在此函数可用</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1, obj2);	<span class="comment">//为T型对象调用最佳的swap版本</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h1><h2 id="条款26：尽可能延后变量定义式的时间"><a href="#条款26：尽可能延后变量定义式的时间" class="headerlink" title="条款26：尽可能延后变量定义式的时间"></a>条款26：尽可能延后变量定义式的时间</h2><ul>
<li>尽可能<strong>延后变量定义式的出现</strong>。这样做可增加程序的清晰度并改善程序的效率<ul>
<li>定义变量会有构造的时间消耗，若之后一段时间没使用，此时中间发生异常，又会有这个变量析构的时间消耗</li>
</ul>
</li>
</ul>
<p>对于循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法A：定义循环外</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  w = 取决于i的某个值;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法B：定义循环内</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Widget <span class="title">w</span><span class="params">(取决于i的某个值)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>做法A：1个构造函数+1个析构函数+n个赋值函数</li>
<li>做法B：n个构造函数+n个析构函数</li>
</ul>
<p>如果classes的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效。尤其当n比较大的时候。否则做法B或许比较好。</p>
<p>另外A带的是w的作用域变大，有时候会对程序的可理解性和易维护性造成冲突。</p>
<p>因此：</p>
<ul>
<li>你知道<strong>赋值成本</strong>比 <strong>“构造+析构” 成本</strong>低</li>
<li>你正在处理代码中效率高度敏感的部分，否则你应该使用做法B</li>
</ul>
<h2 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h2><ul>
<li><strong>const_cast</strong>：通常被用来<strong>将对象的常量性剔除</strong></li>
<li><strong>dynamic_cast</strong>：主要用来执行“<strong>安全向下转型</strong>”，也就是用来判断某对象是否归属继承体系中的某个类型</li>
<li><strong>reinterpret_cast</strong>：意图执行<strong>低级转型</strong>，实际动作及结果可能取决于编译器，这也就表示它不可移植<ul>
<li>允许将任何指针转换为任何其他指针类型。 也允许将任何整数类型转换为任何指针类型以及反向转换。</li>
</ul>
</li>
<li><strong>static_cast</strong>：用来强迫隐式转换，但它无法将const转为non-const</li>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计——virtual：子类override父类，父类指针指向子类实例</li>
<li>如果转型是必要的，试着将它隐藏于某个函数背后。客户可以调用该函数，而不需要将转型放进他们自己的代码内（应该用 “基于virtual 函数调用” 替代 dynamic_cast）</li>
<li>宁可以C++-style转型，不要使用旧式转型。前者很容易辨认出来，而且也比较有着分门别类的职掌</li>
</ul>
<h2 id="条款28：避免返回-handles-指向对象内部成分"><a href="#条款28：避免返回-handles-指向对象内部成分" class="headerlink" title="条款28：避免返回 handles 指向对象内部成分"></a>条款28：避免返回 handles 指向对象内部成分</h2><blockquote>
<p>handles：号码牌，用于获得某个对象</p>
</blockquote>
<ul>
<li><strong>避免返回 handles</strong>（包括 reference 、指针、迭代器）<strong>指向内部对象</strong>。遵守这个条款<strong>可增加封装性</strong>，帮助 const 成员函数的行为像个 const，并将发生 “虚拟号码牌” （dangling handles）的可能性降到最低（返回临时对象的内部对象的引用，一旦临时对象销毁，这个引用就是变成了空悬、虚吊（dangling））</li>
</ul>
<h2 id="条款29：-为-“-异常安全”-而努力是值得的"><a href="#条款29：-为-“-异常安全”-而努力是值得的" class="headerlink" title="条款29：&#x3D;&#x3D;为 “ 异常安全” 而努力是值得的&#x3D;&#x3D;"></a>条款29：&#x3D;&#x3D;为 “ 异常安全” 而努力是值得的&#x3D;&#x3D;</h2><ul>
<li>异常安全函数（Exception-safe functions）即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型<ul>
<li><strong>基本型</strong>：如果异常被抛出，程序内的任何事务仍然保持在有效的状态下（但是不能预料现实状态，<strong>程序可能处于任何状态</strong>——只要这个状态是合法的）</li>
<li><strong>强烈保证型</strong>：如果异常被抛出，程序状态不改变；如果函数成功，则完全成功，如果函数失败，程序会回复到 “调用函数之前” 的状态</li>
<li><strong>不抛掷（nothrow）保证</strong>：承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。作用于<strong>内置类型</strong>（例如 ints，指针等等）身上的所有操作都提供 nothrow 保证。这是异常安全码中一个<strong>必不可少的关键基础材料</strong><ul>
<li><strong>在函数名后面加 throw()</strong> 括号内为空</li>
</ul>
</li>
</ul>
</li>
<li>“强烈保证” 往往能够以 copy-and-swap 实现出来，但 “强烈保证” 并非对所有函数都可实现或具备现实意义</li>
<li>函数提供的 “异常安全保证” 通常最高只等于其所调用之各个函数的 “异常安全保证” 最低者</li>
</ul>
<h2 id="条款30：-透彻了解-inlining-的里里外外"><a href="#条款30：-透彻了解-inlining-的里里外外" class="headerlink" title="条款30：&#x3D;&#x3D;透彻了解 inlining 的里里外外&#x3D;&#x3D;"></a>条款30：&#x3D;&#x3D;透彻了解 inlining 的里里外外&#x3D;&#x3D;</h2><ul>
<li>inline函数如果起作用了，会在每次调用的时候用实现的代码替换它，所以会<strong>造成程序体积变大</strong>。</li>
<li>inline只是向编译器的一个申请，可以<strong>明确用inline关键字</strong>，也可以<strong>在类体内部定义</strong>。</li>
<li>template的实例化和inline无关，如果需要template函数为inline，需要显式地声明它。</li>
<li>inline函数<strong>无法随着程序库的升级而升级</strong>。换句话说如果f是程序库内的一个inline函数，客户讲“f函数本体”编进其程序中，一旦程序库设计者决定改变f，所有用到f的客户端程序都<strong>必须重新编译</strong>。</li>
<li>将大多数inline<strong>限制在小型、被频繁调用的函数身上</strong>。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li>80-20 法则：一个典型的程序有 80% 的执行时间花费在 20%的代码身上</li>
</ul>
<h2 id="条款31：-将文件间的编译依存关系降到最低"><a href="#条款31：-将文件间的编译依存关系降到最低" class="headerlink" title="条款31：&#x3D;&#x3D;将文件间的编译依存关系降到最低&#x3D;&#x3D;"></a>条款31：&#x3D;&#x3D;将文件间的编译依存关系降到最低&#x3D;&#x3D;</h2><ul>
<li><p><strong>解耦</strong>——编译的时候有时候只需要一个声明而不必把定义编译进去</p>
</li>
<li><p>支持 “编译依存性最小化” 的一般构想是：<strong>相依于声明式</strong>，<strong>不要相依于定义式</strong>。基于此构想的两个手段是 Handle classes 和 Interface classes。</p>
</li>
<li><p>程序库头文件应该以 “完全且仅有声明式”（full and declaration-only forms）的形式存在。这种做法不论是否涉及 templates 都适用</p>
<ul>
<li><strong>Handles classes</strong>：将声明和定义分类编写，声明类和定义类有同名成员函数，声明类通过成员智能指针指向实现类，声明类的成员函数通过这个指针调用定义式中的函数</li>
<li><strong>Interface classes</strong>：父类中通过虚函数 “声明” ，子类继承父类重写虚函数提供 “定义”，通过 factory 函数返回一个指向子类的父类智能指针</li>
<li>将声明与定义分离，可以**&#x3D;&#x3D;将 “非真正必要之类型定义” 与 客户端之间的编译依存关系去除掉&#x3D;&#x3D;**</li>
</ul>
</li>
</ul>
<h1 id="6-继承与面向对象设计"><a href="#6-继承与面向对象设计" class="headerlink" title="6. 继承与面向对象设计"></a>6. 继承与面向对象设计</h1><h2 id="条款32：确定你的-public-继承塑模出-is-a-关系"><a href="#条款32：确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="条款32：确定你的 public 继承塑模出 is-a 关系"></a>条款32：确定你的 public 继承塑模出 is-a 关系</h2><ul>
<li>“<strong>public 继承</strong>” 意味着 <strong>is-a</strong>。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class 对象。</li>
</ul>
<h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><ul>
<li>以下代码中加的 virtual 只是为了说明不管成员函数是不是pure virtual 、impure virtual 、non-virtual，<strong>只看名称</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	int x;</span><br><span class="line">public:</span><br><span class="line">	virtual void mf1() = 0;</span><br><span class="line">    virtual void mf1(int);</span><br><span class="line">    virtual void mf2();</span><br><span class="line">    void mf3();</span><br><span class="line">    void mf3(double);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">class Derived : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void mf1();</span><br><span class="line">    void mf3();</span><br><span class="line">    void mf4();</span><br><span class="line">&#125;；</span><br><span class="line">Derived d;</span><br><span class="line">int x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); 	//没问题，调用Dervied::mf1</span><br><span class="line">d.mf1(x); 	//错误，因为Derived::mf1遮掩了Base::mf1</span><br><span class="line">d.mf2();	//没问题，调用Base::mf2</span><br><span class="line">d.mf3(); 	//没问题，调用Dervied::mf3</span><br><span class="line">d.mf3(x); 	//错误！因为Derived::mf3遮掩了Base::mf3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果你正在使用public继承而又不继承那些重载函数，就是违反Base和derived classes之间的is-a关系，而is-a是public的基石。</p>
</li>
<li><p>为了被遮掩的名称再见天日，可<strong>使用using声明式</strong></p>
</li>
</ul>
<h2 id="条款34：区分接口继承还是实现继承"><a href="#条款34：区分接口继承还是实现继承" class="headerlink" title="条款34：区分接口继承还是实现继承"></a>条款34：区分接口继承还是实现继承</h2><ul>
<li>考虑如下一段代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Shape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void draw() const = 0;</span><br><span class="line">    virtual void error(const std::string &amp;msg);</span><br><span class="line">    int objectID() const;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">class Rectangle : public Shape &#123;...&#125;;</span><br><span class="line">class Ellipse : public Shape &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于一个pure virtual函数，且不带定义，目的是为了让derived classes<strong>只继承函数接口</strong>。然后，<strong>继承类必须实现它自身的行为</strong>。</li>
<li>声明impure virtual函数的目的是，让derived classes继承该函数的<strong>接口和缺省实现</strong>。也就是，如果某个集成类不想对该功能做特殊处理的时候，可以采用缺省的默认实现，否则，需要自己提供实现。这种方法可能会造成继承类忘记实现自己该实现的功能，这时候编译照样是过的。</li>
<li>声明pure virtual函数且带定义，也是让derived classes继承该函数的接口和缺省实现。这种方法跟上面的区别是<strong>，它可以防止集成类忘记实现自己功能的情况</strong>，<strong>因为是pure virual</strong>，采用默认实现也得显式地调用基类的函数。</li>
<li>声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份<strong>强制性实现</strong>。</li>
</ul>
<h2 id="条款35：-考虑-virtual-函数以外的其他选择"><a href="#条款35：-考虑-virtual-函数以外的其他选择" class="headerlink" title="条款35：&#x3D;&#x3D;考虑 virtual 函数以外的其他选择&#x3D;&#x3D;"></a>条款35：&#x3D;&#x3D;考虑 virtual 函数以外的其他选择&#x3D;&#x3D;</h2><ul>
<li>场景：假如你打算为游戏内的人物设计一个继承体系。你的游戏属于暴力砍杀类型，剧中人物被伤害或因其他因素而降低健康状态的情况并不罕见。因此，你决定提供一个成员函数healthValue，它会返回一个整数，表示人物的健康程度。由于不同的人物可能已不同的方式计算它们的健康指数，将healthValue声明为virtual似乎是再明白不过的做法。</li>
</ul>
<h3 id="方案1-虚函数方法"><a href="#方案1-虚函数方法" class="headerlink" title="方案1-虚函数方法"></a>方案1-虚函数方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual int healthValue() const; //返回人物的健康指数</span><br><span class="line">                                     //derived classes可重新定义它</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方案2-借由-Non-Virtual-Interface-手法实现-Template-Method-模式"><a href="#方案2-借由-Non-Virtual-Interface-手法实现-Template-Method-模式" class="headerlink" title="方案2-借由 Non-Virtual Interface 手法实现 Template Method 模式"></a>方案2-借由 Non-Virtual Interface 手法实现 Template Method 模式</h3><ul>
<li>这个方案的思路是保留healthValue为public成员函数，但让它成为non-virtual，表调用一个private virtual函数，进行实际工作：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int healthValue() const</span><br><span class="line">    &#123;</span><br><span class="line">  		... //derived classes不重新定义它</span><br><span class="line">        int retVal = doHealthValue(); //做一些事情工作，详下</span><br><span class="line">        ... //做一些事后工作</span><br><span class="line">        return retVal;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	virtual int doHealthValue() const //derived classes可重新定义它</span><br><span class="line">    &#123;</span><br><span class="line">  		... //缺省算法，计算健康指数</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>令客户通过 public non-virtual 成员函数间接调用 private virtual 函数，<strong>称为 non-virtual interface 手法(NVI)<strong>。它是所谓Template Method 设计模式的一个独特表现形式。我把这个 non-virtual 函数称为 virtual 函数的</strong>外覆器</strong>（wrapper）。</p>
</li>
<li><p><strong>优点</strong>：可以使得 virtual 函数在调用的时候，之前<strong>可以设定好适当场景</strong>，并在调用结束后清理场景。事前工作可以是锁定互斥器、制造运转日志记录项目、验证 class 约束条件。<strong>事后工作</strong>可以包括互斥器解除锁定，验证函数的时候条件、再次验证 class 约束条件等等。</p>
</li>
</ul>
<h3 id="方案3-借由-Function-Pointers-实现-Strategy-模式"><a href="#方案3-借由-Function-Pointers-实现-Strategy-模式" class="headerlink" title="方案3-借由 Function Pointers 实现 Strategy 模式"></a>方案3-借由 Function Pointers 实现 Strategy 模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	explict GameCharacter(HealthCalcFunc hcf = defaultHealthCalc);</span><br><span class="line">  	void setHealthCalculator(HealthCalcFunc hcf);</span><br><span class="line">private:</span><br><span class="line">	HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：<strong>运用函数指针替换 virtual 函数</strong>， “每个对象可<strong>各自拥有</strong>自己的健康计算函数” 和 “可在运行期间改变计算函数”</p>
</li>
<li><p>缺点：<strong>降低了封装性</strong>——&gt;如果计算血量，需要依赖non-public的信息，<strong>就需要弱化 class 的封装</strong>，例如 class 可声明这个 non-member 函数为 friends，或为其实现的某一部分提供 public 访问函数</p>
</li>
</ul>
<h3 id="方案4-借由-tr1-function-完成-strategy-模式"><a href="#方案4-借由-tr1-function-完成-strategy-模式" class="headerlink" title="方案4-借由 tr1::function 完成 strategy 模式"></a>方案4-借由 tr1::function 完成 strategy 模式</h3><ul>
<li>tr1::function 对象的行为就像一般函数指针。这样的对象可接纳“与给定的目标标签格式兼容”的所有可调用物，也就是函数指针、函数对象或成员函数指针。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef std::tr1::function&lt;int (const GameCharacter &amp;)&gt; HealthCalcFunc;</span><br><span class="line">private:</span><br><span class="line">    HealthCalcFunc healthCalcFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：灵活性，可以使用<strong>任何可调用的对象</strong>。</li>
</ul>
<h3 id="方案5-古典的-Strategy-策略模式"><a href="#方案5-古典的-Strategy-策略模式" class="headerlink" title="方案5-古典的 Strategy 策略模式"></a>方案5-古典的 Strategy 策略模式</h3><p>![1685202455586](effective C++.assets&#x2F;1685202455586.jpg)</p>
<ul>
<li>这个解法的吸引力在于，熟悉标准 Strategy 模式的人很容易辨认它，而且它还提供 “将一个既有的健康算法纳入使用” 的可能性——只要为 HealthCalcFunc 继承体系添加一个 derived class 即可</li>
</ul>
<h2 id="条款36：绝不重新定义继承而来的-non-virtual-函数"><a href="#条款36：绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="条款36：绝不重新定义继承而来的 non-virtual 函数"></a>条款36：绝不重新定义继承而来的 non-virtual 函数</h2><ul>
<li>绝不重新定义继承而来的non-virtual函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">D x;</span><br><span class="line">B *pb = &amp;x;</span><br><span class="line">pb-&gt;<span class="built_in">mf</span>();<span class="comment">//调用B::mf</span></span><br><span class="line">D *pd = &amp;x;</span><br><span class="line">pd-&gt;<span class="built_in">mf</span>();<span class="comment">//调用D::mf</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在D中重载non-virtual的B类对象中的函数，其实已经违反了在 public 继承下每个D is-a B的约束。即对于non-virtual的接口，继承类应该和基类行为是一致的，否则就不应该设计成non-virtual接口。</li>
</ul>
<h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><ul>
<li><p>virtual函数系动态绑定，而缺省参数值却是静态绑定。</p>
</li>
<li><p>举个例子</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">ShapeColor</span>&#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>有以下代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps;</span><br><span class="line">Shape *pc = <span class="keyword">new</span> Circle;</span><br><span class="line">Shape *pr = <span class="keyword">new</span> Rectangle;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用 pc-&gt;draw() 的时候，采用的默认参数是 Red，是 Shape 类的默认参数，而不是 Derived 的类的默认参数，因为默认参数是静态编译期间绑定的。</p>
</li>
<li><p>即使把 Base class 和 Derived class 设计成相同的默认参数，<strong>如果某一天要修改这个参数，得两个类都需要修改</strong>。</p>
</li>
<li><p>这个问题可以通过 NVI 方法来避免，把函数功能抽象成 private 的 virtual 函数，然后把缺省的默认参数移到 non-virtual 的 public 函数中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">ShapeColor</span>&#123;Red, Green, Blue&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = RED)</span></span>&#123;</span><br><span class="line">        <span class="built_in">doDraw</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="条款38：通过-复合-塑模出-has-a-或-“根据某物实现出”"><a href="#条款38：通过-复合-塑模出-has-a-或-“根据某物实现出”" class="headerlink" title="条款38：通过&#x3D;&#x3D;复合&#x3D;&#x3D;塑模出 has-a 或 “根据某物实现出”"></a>条款38：通过&#x3D;&#x3D;复合&#x3D;&#x3D;塑模出 has-a 或 “根据某物实现出”</h2><ul>
<li><p>复合 （composition）的意义和 public 继承完全不同</p>
</li>
<li><p>在应用域（application domain），复合意味着 has-a（有一个）。在实现域（implementation domain），复合意味着 is-implemented-in-terms-of</p>
</li>
<li><p>例如，我们希望基于std::list来实现一个set，可以，在一个set类里面定义一个std::list作为内部成员，来实现set。</p>
</li>
</ul>
<h2 id="条款39：明智而审慎地使用-private-继承"><a href="#条款39：明智而审慎地使用-private-继承" class="headerlink" title="条款39：明智而审慎地使用 private 继承"></a>条款39：明智而审慎地使用 private 继承</h2><ul>
<li>Private 继承意味着 is-implemented-in-terms-of（根据某物实现出）。它<strong>通常比复合（composition）的级别低</strong>。但是当 derived classes 需要访问 protected base class 的成员，或需要重新定义一个或多个 virtual 函数时，这么设计是合理的</li>
<li>和复合（composition）不同，private 继承可以造成 <strong>empty base 最优化</strong>（EBO：empty base optimization）。这对致力于 “对象尺寸最小化” 的程序库开发者而言，可能很重要</li>
<li>复合和 private 继承都意味着 is-implemented-in-terms-of，但复合比较容易理解，所以无论什么时候，<strong>只要可以，你还是应该选择复合</strong></li>
</ul>
<h2 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h2><ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要</li>
<li>virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes不带任何数据，将是最具使用价值的情况</li>
<li>多重继承的确有正当用途。其中一个情节涉及 “<strong>public 继承某个Interface class</strong>” 和 “<strong>private 继承某个协助实现的class</strong>” 的两相组合<ul>
<li>和条款31相似，不过子类重写的操作交给 private 继承的 class</li>
</ul>
</li>
</ul>
<h1 id="7-模板与泛型编程"><a href="#7-模板与泛型编程" class="headerlink" title="7. 模板与泛型编程"></a>7. 模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款41：了解隐式接口和编译期多态</h2><ul>
<li>class 和 templates 都支持接口（interfaces）和多态（polymorphism）</li>
<li>对 classes 而言<strong>接口是显示的</strong>（explicit），以函数签名为中心，多态则是通过 virtual 函数发生于运行期——<strong>运行期多态</strong></li>
<li>对 template 参数而言，<strong>接口是隐式的</strong>（implici），<strong>奠基于有效表达式</strong>。多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期——<strong>编译器多态</strong></li>
</ul>
<ul>
<li>对于template编程，隐式接口和编译期多态移到了前头，例如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T &amp;W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget)</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">    temp.<span class="built_in">normalize</span>();</span><br><span class="line">    temp.<span class="built_in">swap</span>(w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>w必须支持哪一种接口，系由template中执行于w身上的操作来决定。本例看来w的类型T好像必须支持size，normalize和swap成员函数、copy构造函数、不等比较。</li>
<li>凡涉及w的任何函数调用，例如operator&gt;和operator!&#x3D;，有可能造成template具现化，使得这些调用得以成功。这样的具现行为发生在<strong>编译期</strong>。“以不同的template参数具现化function templates”会导致调用不同的函数，这是<strong>编译期多态</strong>。</li>
</ul>
<h2 id="条款42：了解-typename-的双重意义"><a href="#条款42：了解-typename-的双重意义" class="headerlink" title="条款42：了解 typename 的双重意义"></a>条款42：了解 typename 的双重意义</h2><ul>
<li><p>声明 template 参数时，前缀关键字 class 和 typename 可互换</p>
</li>
<li><p>请使用关键字 typename 标识<strong>嵌套从属类型</strong>名称；但不得在 <strong>base class lists</strong> 或 <strong>member initialization list</strong> 内以它作为 base class 修饰符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;               <span class="comment">//允许使用typename或class</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(<span class="type">const</span> C &amp;container,        <span class="comment">//不允许使用typename</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">typename</span> C::iterator iter)</span> <span class="comment">//一定要使用typename</span></span></span><br></pre></td></tr></table></figure>

<p>因为C::iterator看起来有可能是类型，也有可能是成员变量，所以，要<strong>明确告诉编译器</strong>。</p>
</li>
</ul>
<h2 id="条款43：-学习处理模板化基类的名称"><a href="#条款43：-学习处理模板化基类的名称" class="headerlink" title="条款43：&#x3D;&#x3D;学习处理模板化基类的名称&#x3D;&#x3D;"></a>条款43：&#x3D;&#x3D;学习处理模板化基类的名称&#x3D;&#x3D;</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgInfo</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClear</span><span class="params">(<span class="type">const</span> MsgInfo &amp;info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  		std::string msg;</span><br><span class="line">        Company c;</span><br><span class="line">        c.<span class="built_in">sendCleartext</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo &amp;info)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span> : <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo &amp;info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  		将<span class="string">&quot;传送前&quot;</span>的信息写至log;</span><br><span class="line">        <span class="built_in">sendClear</span>(info);  <span class="comment">//调用base class函数：这段代码无法通过编译</span></span><br><span class="line">        将<span class="string">&quot;传送后&quot;</span>的信息写至log;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之所以无法通过编译是因为编译器无法确认 MsgInfo&lt;Company&gt; 中是否有 sendClear() 函数，也就<strong>不会进入父类作用域</strong>去查看是否有这个函数<ul>
<li>因为就算一般（泛化）的 template 中确实是有sendClear() 函数，但可能有全特化版本，而这个版本没有 sendClear() 函数</li>
</ul>
</li>
</ul>
<p><strong>解决方案有三个：</strong></p>
<p>在 derived class templates ——&gt;假定这个函数被继承</p>
<ul>
<li>在sendClear之前加上<strong>this操作符</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<strong>using声明式</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br></pre></td></tr></table></figure>

<ul>
<li>明白<strong>指出被调用的函数位于base class</strong>内<ul>
<li>此操作的明确资格修饰（explicit qualification）会关闭 “ virtual ” 绑定行为</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info);</span><br></pre></td></tr></table></figure>



<h2 id="条款44：将与参数无关的代码抽离-templates"><a href="#条款44：将与参数无关的代码抽离-templates" class="headerlink" title="条款44：将与参数无关的代码抽离 templates"></a>条款44：将与参数无关的代码抽离 templates</h2><ul>
<li>Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系</li>
<li>因<strong>非类型模板参数</strong>（non-type template parameters）而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数<ul>
<li>如以下代码示例</li>
</ul>
</li>
<li>因<strong>类型参数</strong>（type parameters）而造成的代码膨胀，往往可降低，做法是让带有<strong>完全相同二进制</strong>表述的具现类型<strong>共享实现码</strong><ul>
<li>例如 vector&lt;int&gt; 和 vector&lt;long&gt; 的成员函数可能完全相同，会<strong>使用唯一一份底层实现</strong></li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<ul>
<li>对于template class或者template function，其间的代码重复可能不是很容易能看出来，需要对调用情况进行分析，可能会实现仅仅是参数不同的函数，例如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">		 std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">5</span>&gt; sm1; <span class="comment">//调用SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line">sm1.<span class="built_in">invert</span>();</span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>, <span class="number">10</span>&gt; sm2; <span class="comment">//调用SquareMatrix&lt;double, 10&gt;::invert</span></span><br><span class="line">sm2.<span class="built_in">invert</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案是写一个带参数的invert函数，然后，public函数的接口调用带参数的invert函数。<ul>
<li><strong>减少了具现模板时的代码膨胀</strong>，将具现<strong>模板间的一些相同机能</strong>交由其他类&#x2F;函数模板实现，再继承调用，这样都会使用一份代码，而不需要每次模板具现的时候都有一份重复代码</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span>							<span class="comment">//将与参数是std::size_t n无关的代码抽离了出来</span></span><br><span class="line">&#123;												</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;			<span class="comment">//避免覆盖base版的invert</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123;<span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n);&#125;			<span class="comment">//this是为了假定invert被继承——条款43</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="条款45：运用-成员函数模板-接受所有兼容类型"><a href="#条款45：运用-成员函数模板-接受所有兼容类型" class="headerlink" title="条款45：运用&#x3D;&#x3D;成员函数模板&#x3D;&#x3D;接受所有兼容类型"></a>条款45：运用&#x3D;&#x3D;成员函数模板&#x3D;&#x3D;接受所有兼容类型</h2><ul>
<li><p>同一个 template 的不同具现体（instantiations）之间并不存在什么与生俱来的固有关系</p>
<ul>
<li>这里意指如果以带有 base-derived 关系的 B，D 两类型<strong>分别具现化某个 template</strong>，产生出来的两个具现&#x3D;&#x3D;<strong>并不带有 base-derived 关系</strong>&#x3D;&#x3D;</li>
</ul>
</li>
<li><p>使用 member function templates（<strong>成员函数模板</strong>）生成 “可接受所有兼容类型” 的函数——这里用倾向使用 class</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T *realPtr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SmartPtr&lt;Top&gt; pt1 = </span><br><span class="line">	<span class="built_in">SmartPtr</span>&lt;middle&gt;(<span class="keyword">new</span> Middle); 	<span class="comment">//将smartPtr&lt;middle&gt;转换成SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = </span><br><span class="line">	<span class="built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);</span><br><span class="line">SmartPtr&lt;<span class="type">const</span> Top&gt; pct2 = pt1;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">   	<span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt; &amp;other)</span></span></span><br><span class="line"><span class="function">    	: heldPtr(other.get()) &#123;</span>...&#125;</span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> heldPtr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *heldPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用成员初值列来初始化 SmartPtr 之内类型为 T* 的成员变量，并以类型为 U* 的指针作为初值，这个行为只有当 “存在某个隐式转换<strong>可将一个U<em>指针转换成一个T</em>指针</strong>” 才能通过编译。</p>
</li>
<li><p>运用成员函数模板接受所有兼容类型——这里是构造函数的示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;									<span class="comment">//构造,来自任何类型的</span></span><br><span class="line">	 <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(Y* p)</span></span>;							<span class="comment">//内置指针</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">	 <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp;r)</span></span>;					<span class="comment">//或shared—_ptr</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">	 <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>&lt;Y&gt;(weak_ptr&lt;Y&gt; <span class="type">const</span>&amp;r);		<span class="comment">//或weak_ptr</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">	 <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>&lt;Y&gt;(auto_ptr&lt;Y&gt;&amp; r);			<span class="comment">//或auto_ptr</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;									<span class="comment">//赋值,来自任何兼容的</span></span><br><span class="line">	 shared_ptr&amp; <span class="keyword">operator</span>== (shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);	<span class="comment">//shared_ptr</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">	 shared_ptr&amp; <span class="keyword">operator</span>== (auto_ptr&lt;Y&gt; &amp;r);			<span class="comment">//或auto_ptr</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 class 内声明泛化 copy 构造函数，并<strong>不会阻止编译器生成自己的 copy 构造函数</strong>，所以，如果你想要控制 copy 构造的方方面面，你必须<strong>同时声明泛化 copy 构造函数</strong>和<strong>正常的 copy 构造函数</strong>。相同规则也适用于赋值操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr <span class="type">const</span>&amp;r);						<span class="comment">//copy构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">	<span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp;r)</span></span>;					<span class="comment">//泛化copy构造函数</span></span><br><span class="line">    </span><br><span class="line">	shared_ptr&amp; <span class="keyword">operator</span>== (shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);	<span class="comment">//copy assignment</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">	shared_ptr&amp; <span class="keyword">operator</span>== (shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);	<span class="comment">//泛化copy assignment</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款46：需要类型转换时请为模板定义非成员函数</h2><ul>
<li>与条款24中的不同：加入了模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>, <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">	<span class="function"><span class="type">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>* (<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>		<span class="comment">//错误，无法通过编译</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>oneHalf 可以推导出类型为 Rational&lt;int&gt;</p>
</li>
<li><p>而 2 不能推出Rational&lt;int&gt;，因为首先要用临时对象并调用 Rational 的构造函数来构建，然而此时 Rational&lt;T&gt; 还未具现化，因此无法通过编译</p>
</li>
<li><p>解决方法是让<code>const Rational&lt;T&gt; operator* (const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)</code>这个函数成为类的 friend，当 <strong>onehalf 具现化类</strong>的时候<strong>这个函数也被具现化</strong>，上述的 2 可以转化为 创建临时对象并调用 Rational 的构造函数 (2) 来构建</p>
<ul>
<li><p>这个 friend 函数要在类中将定义式也附上，不然连接器找不到它，而外部加上作用域的定义是行不通的</p>
</li>
<li><p>如果定义比较复杂，可以调用外部辅助实现——&gt;接口和实现分离，在接口函数中调用实现函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rational.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Rational</span>;	<span class="comment">//声明Rational template</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenaem T&gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"> <span class="keyword">friend</span></span><br><span class="line">	<span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">doMultiply</span>(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>一些</strong>编译器要求把所有 template 的定义式放进头文件内——需要的话就将 doMultiply() 定义式也写在头文件</p>
<ul>
<li>operator* 的定义式就是 doMultiply()</li>
</ul>
</li>
</ul>
</li>
<li><p>在一个class template 内，template 名称可以省略</p>
</li>
</ul>
<h2 id="条款47：请使用-traits-classes-表现类型信息"><a href="#条款47：请使用-traits-classes-表现类型信息" class="headerlink" title="条款47：请使用 &#x3D;&#x3D;traits classes 表现类型信息&#x3D;&#x3D;"></a>条款47：请使用 &#x3D;&#x3D;traits classes 表现类型信息&#x3D;&#x3D;</h2><ul>
<li>Traits classes 使得“类型相关信息”在编译期可用。它们以 templates 和 “templates 特化” 完成实现</li>
</ul>
<p>STL迭代器分类：</p>
<ul>
<li>Input迭代器：只能向前移动，一次一步，客户只可读取它们所指的东西，而且只能读取一次。</li>
<li>Output迭代器：只能向前移动，一次一步，客户只可涂写它们所指的东西，而且只能涂写一次。</li>
<li>forward迭代器：这种迭代器可以做前述两种分类能做的每件事情，而且可以读或写其所指物一次以上。</li>
<li>bidirectional迭代器：它除了可以向前移动，还可以向后移动。STL的list迭代器就属于这一分类，set，multiset，map和multimap的迭代器也都是这一分类。</li>
<li>random access迭代器：可以在常量时间内向前或向后跳跃任意距离。vector，deque和string提供的迭代器都是这一分类。</li>
</ul>
<p>在STL中有advance函数，可以把迭代器按照某个距离进行移动，声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterI &amp;iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (iter is a random access iterator)</span><br><span class="line">  &#123;</span><br><span class="line">    iter += d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123;<span class="keyword">while</span>(d--) ++iter;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">while</span> (d++) --iter;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++中实现相关原理如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterI&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;...&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">    &#123;</span><br><span class="line">  	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;...&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">    &#123;</span><br><span class="line">  	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">对于iterator_traits</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">对于内置指针，需要特化一个版本出来</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;IterT *&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>if <strong>在运行期才确定</strong>，而<strong>模板需要在编译阶段具现</strong>，所以下面 if 语句不能通过编译</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT &amp;iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">typeid</span>(<span class="keyword">typename</span> std::iterator_traits&lt;IterI&gt;::iterator_category) == <span class="built_in">typeid</span>(std::random_access_iterator_tag))</span><br><span class="line">&#125;;		<span class="comment">//if 在运行期才确定，而模板需要在编译阶段具现，所以下面 if 语句不能通过编译</span></span><br></pre></td></tr></table></figure>

<ul>
<li>建立一组重载函数或函数模板，彼此间的差异只在于各自的traits参数。</li>
<li>建立一个控制函数或函数模板，它调用上述那些劳工函数并传递traits class所提供的信息。</li>
<li>整合重载技术后，**&#x3D;&#x3D;traits classes 有可能在编译器对类型执行 if…else 测试&#x3D;&#x3D;** ——&gt; 模板元（TMP：Template metaprogramming）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d,</span></span></span><br><span class="line"><span class="params"><span class="function">				std::random_access_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  iter += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d, std::bidirectional_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123;<span class="keyword">while</span> (d--) ++iter;&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="keyword">while</span>(d++) --iter;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d, std::input_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(d--) ++iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT &amp;iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">doAdvance</span>(iter, d, <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="条款48：认识-template-元编程"><a href="#条款48：认识-template-元编程" class="headerlink" title="条款48：认识 template 元编程"></a>条款48：认识 template 元编程</h2><ul>
<li>Template metaprogramming (TMP，模板元编程)可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率</li>
<li>TMP可被用来生成“基于政策选择组合”的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码</li>
</ul>
<h1 id="8-定制-new-和-delete"><a href="#8-定制-new-和-delete" class="headerlink" title="8. 定制 new 和 delete"></a>8. 定制 new 和 delete</h1><h2 id="条款49：了解-new-handler-的行为"><a href="#条款49：了解-new-handler-的行为" class="headerlink" title="条款49：了解 &#x3D;&#x3D;new-handler&#x3D;&#x3D; 的行为"></a>条款49：了解 &#x3D;&#x3D;new-handler&#x3D;&#x3D; 的行为</h2><ul>
<li>set_new_handler 允许客户指定一个函数，在<strong>内存分配无法获得满足时被调用</strong><ul>
<li>operator new 可能不止一次分配内存，并在每次失败后调用 new-handling 函数</li>
</ul>
</li>
<li>Nothrow new 是一个颇为局限的工具，因为它只适用于内存分配；<strong>后继</strong>的构造函数调用<strong>还是可能抛出异常</strong></li>
</ul>
<ul>
<li><p>如果父类里面有 static 成员变量，想要子类继承时都有一份独有的 static 成员变量，可以让父类变成模板（实际上没有地方用到），子类在继承的时候将模板参数设定为本身，<strong>Template 机制会自动为每一个 T 生成一份 static 成员</strong></p>
</li>
<li><p>设计良好的 new-handler 函数可以有以下选择：</p>
<ul>
<li>让更多内存可被使用</li>
<li>安装另一个 new-handler</li>
<li>卸除 new-handler</li>
<li>抛出 bad_alloc</li>
<li>不返回</li>
</ul>
</li>
</ul>
<h2 id="条款50：了解-new-和-delete-的合理替换时机"><a href="#条款50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款50：了解 new 和 delete 的合理替换时机"></a>条款50：了解 new 和 delete 的合理替换时机</h2><ul>
<li>有许多理由需要写个自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息<ul>
<li>用来检测运用上的错误</li>
<li>为了强化效能</li>
<li>为了收集使用上的统计数据</li>
<li>为了增加分配和归还的速度</li>
<li>为了降低缺省内存管理器带来的空间额外开销</li>
<li>为了弥补缺省内存分配器中的非最佳**&#x3D;&#x3D;齐位&#x3D;&#x3D;**</li>
<li>为了将相关对象成簇集中</li>
<li>为了获得非传统行为</li>
</ul>
</li>
</ul>
<h2 id="条款51：编写-new-和-delete-时需固守常规"><a href="#条款51：编写-new-和-delete-时需固守常规" class="headerlink" title="条款51：编写 new 和 delete 时需固守常规"></a>条款51：编写 new 和 delete 时需固守常规</h2><ul>
<li><p>operator new 应该<strong>内含一个无穷循环</strong>，并在其中尝试分配内存，如果它<strong>无法满足内存需求</strong>，就应该<strong>调用new-handler</strong>。它也应该有能力处理任何<strong>0 bytes申请</strong>。Class专属版本则还应该处理“比正确大小更大的（错误）申请” ——&gt; 调用标准 operator new</p>
</li>
<li><p>operator delete应该在<strong>收到null指针时不做任何事</strong>。Class专属版本则还应该处理“比正确大小更大的（错误）申请” ——&gt; 调用标准operator delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory, std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* Base::oeprator <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Base))			<span class="comment">//如果大小错误</span></span><br><span class="line">		<span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);	<span class="comment">//令标准的operator new起而处理</span></span><br><span class="line">	...									<span class="comment">//否则在这里处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory, std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;			<span class="comment">//检查null指针</span></span><br><span class="line">	<span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Base))			<span class="comment">//如果大小错误</span></span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(size)</span></span>;		<span class="comment">//operator delete处理此以申请</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	现在，归还rawMemory所指内存</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="条款52：写了-placement-new-也要写-placement-delete"><a href="#条款52：写了-placement-new-也要写-placement-delete" class="headerlink" title="条款52：写了 placement new 也要写 placement delete"></a>条款52：写了 placement new 也要写 placement delete</h2><ul>
<li><p>当你写一个 <strong>placement</strong> operator new，请确定也写出了对应的 <strong>placement</strong> operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏</p>
</li>
<li><p>当你声明 placement new 和 placement delete，请确定<strong>不要无意识（非故意）地遮盖它们的正常版本</strong></p>
<ul>
<li><p>对于撰写内存分配函数，你需要记住的是，缺省的情况下 C++ 在 global 作用域下提供以下形式的 operator new、</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;				<span class="comment">//normal new</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;						<span class="comment">//placement new</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;		<span class="comment">//nothrow new</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个简单的做法是，建立一个 base class，内含所有正常形式的 new 和 delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StandardNewDeleteForms</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//normal new/delete</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size); &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//placement new/delete</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size, ptr); &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory, ptr)</span></span>; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//nothrow new/delete</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp; nt)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size, nt); &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>:<span class="keyword">public</span> StandardNewDeleteForms &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">new</span>;				<span class="comment">//让这些形式可见</span></span><br><span class="line">	<span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, 			<span class="comment">//添加一个自定的placemet new</span></span></span></span><br><span class="line"><span class="params"><span class="function">							 std::ostream&amp; logStream)</span></span></span><br><span class="line"><span class="function">		<span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory,				<span class="comment">//添加一个自定的placemet delete</span></span></span></span><br><span class="line"><span class="params"><span class="function">								std::ostream&amp; logStream)</span></span></span><br><span class="line"><span class="function">		<span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="9-杂项讨论"><a href="#9-杂项讨论" class="headerlink" title="9. 杂项讨论"></a>9. 杂项讨论</h1><h2 id="条款53：不要忽略编译器的警告"><a href="#条款53：不要忽略编译器的警告" class="headerlink" title="条款53：不要忽略编译器的警告"></a>条款53：不要忽略编译器的警告</h2><ul>
<li>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取 “无任何警告” 的荣誉</li>
<li>不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失</li>
</ul>
<h2 id="条款54：让自己熟悉包括-TR1-在内的标准程序库"><a href="#条款54：让自己熟悉包括-TR1-在内的标准程序库" class="headerlink" title="条款54：让自己熟悉包括 TR1 在内的标准程序库"></a>条款54：让自己熟悉包括 TR1 在内的标准程序库</h2><blockquote>
<p>TR1：Technical Report 1</p>
</blockquote>
<ul>
<li>STL</li>
<li>Iostreams</li>
<li>国际化支持</li>
<li>数值处理</li>
<li>异常阶层体系</li>
<li>C89标准程序库</li>
</ul>
<p>上面的分类应该是比较老的分类了，最新的应该包含C++11和C++14的标准程序库了。</p>
<ul>
<li>TR1 自身知识一份规范。为获得 TR1 提供的好处，你需要一份实物。一个好的实物来源是 Boost</li>
</ul>
<h2 id="条款55：让自己熟悉-Boost"><a href="#条款55：让自己熟悉-Boost" class="headerlink" title="条款55：让自己熟悉 Boost"></a>条款55：让自己熟悉 Boost</h2><ul>
<li><p>Boost 是一个社群，也是一个网站。致力于免费、源码开放、同僚复查的 C++ 程序库开发。Boost 在 C++ 标准化过程中扮演深具影响力的角色</p>
</li>
<li><p>Boost 提供许多 TR1 组件实现品，以及其他许多程序库</p>
</li>
<li><p>Boost 是否需要熟悉？看 google 代码规范是推荐使用其中一部分的，觉得还是有必要看看。</p>
</li>
</ul>
<h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://estrellaxiaoyu.github.io">Estrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://estrellaxiaoyu.github.io/2023/07/25/Effective%20C++/">https://estrellaxiaoyu.github.io/2023/07/25/Effective%20C++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://estrellaxiaoyu.github.io" target="_blank">Estrella博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/%E7%AC%94%E8%AE%B0p2.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/25/C++%E9%9D%A2%E7%BB%8F/" title="C++面经整理集"><img class="cover" src="/./img/%E7%AC%94%E8%AE%B0p1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++面经整理集</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/25/MySQL%E7%AC%94%E8%AE%B0/" title="MySQL笔记"><img class="cover" src="/./img/%E7%AC%94%E8%AE%B0p4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL笔记</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/%E5%A4%B4%E5%83%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Estrella</div><div class="author-info__description">hi，欢迎你来到我的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Estrellaxiaoyu" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:estrellaxiaoyu@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Estrella的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE0%EF%BC%9A%E5%AF%BC%E8%AF%BB"><span class="toc-number">1.</span> <span class="toc-text">条款0：导读</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="toc-number">2.</span> <span class="toc-text">1. 让自己习惯C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE1%EF%BC%9A%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="toc-number">2.1.</span> <span class="toc-text">条款1：视C++为一个语言联邦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE2%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const%EF%BC%8Cenum%EF%BC%8Cinline%E4%BB%A3%E6%9B%BF-define"><span class="toc-number">2.2.</span> <span class="toc-text">条款2：尽量以const，enum，inline代替 #define</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE3%EF%BC%9A-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="toc-number">2.3.</span> <span class="toc-text">条款3：&#x3D;&#x3D;尽可能使用const&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE4%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.4.</span> <span class="toc-text">条款4：确定对象被使用前已被初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-number">3.</span> <span class="toc-text">2. 构造&#x2F;析构&#x2F;赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE5%EF%BC%9A%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">条款5：了解C++默默编写并调用哪些函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE6%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="toc-number">3.2.</span> <span class="toc-text">条款6：若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE7%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E-virtual-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">条款7：为多态基类声明 virtual 析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE8%EF%BC%9A-%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">条款8：&#x3D;&#x3D;别让异常逃离析构函数&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE9%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8-virtual-%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">条款9：绝不在构造函数和析构函数过程中调用 virtual 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4-operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-reference-to-this"><span class="toc-number">3.6.</span> <span class="toc-text">条款10：令 operator&#x3D; 返回一个 reference to *this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8-operator-%E4%B8%AD-%E5%A4%84%E7%90%86%E2%80%9C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9C"><span class="toc-number">3.7.</span> <span class="toc-text">条款11：在 operator&#x3D; 中&#x3D;&#x3D;处理“自我赋值“&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="toc-number">3.8.</span> <span class="toc-text">条款12：复制对象时勿忘其每一个成分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">3. 资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">4.1.</span> <span class="toc-text">条款13：以对象管理资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83-copying-%E8%A1%8C%E4%B8%BA"><span class="toc-number">4.2.</span> <span class="toc-text">条款14：在资源管理类中小心 copying 行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">4.3.</span> <span class="toc-text">条款15：在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8-new-%E5%92%8C-delete-%E6%97%B6%E8%A6%81%E9%87%87%E7%94%A8%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">条款16：成对使用 new 和 delete 时要采用相同形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE17%EF%BC%9A-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-newed-%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">4.5.</span> <span class="toc-text">条款17：&#x3D;&#x3D;以独立语句将 newed 对象置入智能指针&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="toc-number">5.</span> <span class="toc-text">4. 设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE18%EF%BC%9A-%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">条款18：&#x3D;&#x3D;让接口容易被正确使用，不易被误用&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E8%AE%BE%E8%AE%A1-class-%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1-type"><span class="toc-number">5.2.</span> <span class="toc-text">条款19：设计 class 犹如设计 type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5-pass-by-reference-to-const-%E6%9B%BF%E6%8D%A2-pass-by-value"><span class="toc-number">5.3.</span> <span class="toc-text">条款20：宁以 pass-by-reference-to-const 替换 pass-by-value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6-reference"><span class="toc-number">5.4.</span> <span class="toc-text">条款21：必须返回对象时，别妄想返回其 reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA-private"><span class="toc-number">5.5.</span> <span class="toc-text">条款22：将成员变量声明为 private</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5-non-member%E3%80%81non-friend-%E6%9B%BF%E6%8D%A2-member-%E5%87%BD%E6%95%B0"><span class="toc-number">5.6.</span> <span class="toc-text">条款23：宁以 non-member、non-friend 替换 member 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8-non-member-%E5%87%BD%E6%95%B0"><span class="toc-number">5.7.</span> <span class="toc-text">条款24：若所有参数皆需要类型转换，请为此采用 non-member 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A-%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84-swap-%E5%87%BD%E6%95%B0"><span class="toc-number">5.8.</span> <span class="toc-text">条款25：&#x3D;&#x3D;考虑写出一个不抛出异常的 swap 函数&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">5. 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">6.1.</span> <span class="toc-text">条款26：尽可能延后变量定义式的时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-number">6.2.</span> <span class="toc-text">条款27：尽量少做转型动作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9A%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9E-handles-%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="toc-number">6.3.</span> <span class="toc-text">条款28：避免返回 handles 指向对象内部成分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9A-%E4%B8%BA-%E2%80%9C-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D-%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-number">6.4.</span> <span class="toc-text">条款29：&#x3D;&#x3D;为 “ 异常安全” 而努力是值得的&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9A-%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3-inlining-%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-number">6.5.</span> <span class="toc-text">条款30：&#x3D;&#x3D;透彻了解 inlining 的里里外外&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A-%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E5%88%B0%E6%9C%80%E4%BD%8E"><span class="toc-number">6.6.</span> <span class="toc-text">条款31：&#x3D;&#x3D;将文件间的编译依存关系降到最低&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">6. 继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84-public-%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BA-is-a-%E5%85%B3%E7%B3%BB"><span class="toc-number">7.1.</span> <span class="toc-text">条款32：确定你的 public 继承塑模出 is-a 关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">7.2.</span> <span class="toc-text">条款33：避免遮掩继承而来的名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E8%BF%98%E6%98%AF%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">7.3.</span> <span class="toc-text">条款34：区分接口继承还是实现继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE35%EF%BC%9A-%E8%80%83%E8%99%91-virtual-%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-number">7.4.</span> <span class="toc-text">条款35：&#x3D;&#x3D;考虑 virtual 函数以外的其他选择&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%881-%E8%99%9A%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.1.</span> <span class="toc-text">方案1-虚函数方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%882-%E5%80%9F%E7%94%B1-Non-Virtual-Interface-%E6%89%8B%E6%B3%95%E5%AE%9E%E7%8E%B0-Template-Method-%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.2.</span> <span class="toc-text">方案2-借由 Non-Virtual Interface 手法实现 Template Method 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%883-%E5%80%9F%E7%94%B1-Function-Pointers-%E5%AE%9E%E7%8E%B0-Strategy-%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.3.</span> <span class="toc-text">方案3-借由 Function Pointers 实现 Strategy 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%884-%E5%80%9F%E7%94%B1-tr1-function-%E5%AE%8C%E6%88%90-strategy-%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.4.</span> <span class="toc-text">方案4-借由 tr1::function 完成 strategy 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%885-%E5%8F%A4%E5%85%B8%E7%9A%84-Strategy-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.5.</span> <span class="toc-text">方案5-古典的 Strategy 策略模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE36%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84-non-virtual-%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">条款36：绝不重新定义继承而来的 non-virtual 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">7.6.</span> <span class="toc-text">条款37：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE38%EF%BC%9A%E9%80%9A%E8%BF%87-%E5%A4%8D%E5%90%88-%E5%A1%91%E6%A8%A1%E5%87%BA-has-a-%E6%88%96-%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="toc-number">7.7.</span> <span class="toc-text">条款38：通过&#x3D;&#x3D;复合&#x3D;&#x3D;塑模出 has-a 或 “根据某物实现出”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE39%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8-private-%E7%BB%A7%E6%89%BF"><span class="toc-number">7.8.</span> <span class="toc-text">条款39：明智而审慎地使用 private 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE40%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">7.9.</span> <span class="toc-text">条款40：明智而审慎地使用多重继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">7. 模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE41%EF%BC%9A%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="toc-number">8.1.</span> <span class="toc-text">条款41：了解隐式接口和编译期多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE42%EF%BC%9A%E4%BA%86%E8%A7%A3-typename-%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-number">8.2.</span> <span class="toc-text">条款42：了解 typename 的双重意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE43%EF%BC%9A-%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">8.3.</span> <span class="toc-text">条款43：&#x3D;&#x3D;学习处理模板化基类的名称&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE44%EF%BC%9A%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BB-templates"><span class="toc-number">8.4.</span> <span class="toc-text">条款44：将与参数无关的代码抽离 templates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE45%EF%BC%9A%E8%BF%90%E7%94%A8-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF-%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.5.</span> <span class="toc-text">条款45：运用&#x3D;&#x3D;成员函数模板&#x3D;&#x3D;接受所有兼容类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE46%EF%BC%9A%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">8.6.</span> <span class="toc-text">条款46：需要类型转换时请为模板定义非成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE47%EF%BC%9A%E8%AF%B7%E4%BD%BF%E7%94%A8-traits-classes-%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">8.7.</span> <span class="toc-text">条款47：请使用 &#x3D;&#x3D;traits classes 表现类型信息&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE48%EF%BC%9A%E8%AE%A4%E8%AF%86-template-%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">8.8.</span> <span class="toc-text">条款48：认识 template 元编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%AE%9A%E5%88%B6-new-%E5%92%8C-delete"><span class="toc-number">9.</span> <span class="toc-text">8. 定制 new 和 delete</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE49%EF%BC%9A%E4%BA%86%E8%A7%A3-new-handler-%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">9.1.</span> <span class="toc-text">条款49：了解 &#x3D;&#x3D;new-handler&#x3D;&#x3D; 的行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE50%EF%BC%9A%E4%BA%86%E8%A7%A3-new-%E5%92%8C-delete-%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-number">9.2.</span> <span class="toc-text">条款50：了解 new 和 delete 的合理替换时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE51%EF%BC%9A%E7%BC%96%E5%86%99-new-%E5%92%8C-delete-%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="toc-number">9.3.</span> <span class="toc-text">条款51：编写 new 和 delete 时需固守常规</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE52%EF%BC%9A%E5%86%99%E4%BA%86-placement-new-%E4%B9%9F%E8%A6%81%E5%86%99-placement-delete"><span class="toc-number">9.4.</span> <span class="toc-text">条款52：写了 placement new 也要写 placement delete</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA"><span class="toc-number">10.</span> <span class="toc-text">9. 杂项讨论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE53%EF%BC%9A%E4%B8%8D%E8%A6%81%E5%BF%BD%E7%95%A5%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="toc-number">10.1.</span> <span class="toc-text">条款53：不要忽略编译器的警告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE54%EF%BC%9A%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89%E5%8C%85%E6%8B%AC-TR1-%E5%9C%A8%E5%86%85%E7%9A%84%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="toc-number">10.2.</span> <span class="toc-text">条款54：让自己熟悉包括 TR1 在内的标准程序库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE55%EF%BC%9A%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89-Boost"><span class="toc-number">10.3.</span> <span class="toc-text">条款55：让自己熟悉 Boost</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#end"><span class="toc-number">11.</span> <span class="toc-text">end</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/C++%E9%9D%A2%E7%BB%8F/" title="C++面经整理集"><img src="/./img/%E7%AC%94%E8%AE%B0p1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++面经整理集"/></a><div class="content"><a class="title" href="/2023/07/25/C++%E9%9D%A2%E7%BB%8F/" title="C++面经整理集">C++面经整理集</a><time datetime="2023-07-25T09:55:13.000Z" title="发表于 2023-07-25 17:55:13">2023-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/Effective%20C++/" title="Effective C++笔记"><img src="/./img/%E7%AC%94%E8%AE%B0p2.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective C++笔记"/></a><div class="content"><a class="title" href="/2023/07/25/Effective%20C++/" title="Effective C++笔记">Effective C++笔记</a><time datetime="2023-07-25T09:54:53.000Z" title="发表于 2023-07-25 17:54:53">2023-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/MySQL%E7%AC%94%E8%AE%B0/" title="MySQL笔记"><img src="/./img/%E7%AC%94%E8%AE%B0p4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL笔记"/></a><div class="content"><a class="title" href="/2023/07/25/MySQL%E7%AC%94%E8%AE%B0/" title="MySQL笔记">MySQL笔记</a><time datetime="2023-07-25T09:54:50.000Z" title="发表于 2023-07-25 17:54:50">2023-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/C++%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" title="C++Primer查漏补缺"><img src="/./img/%E7%AC%94%E8%AE%B0p8.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++Primer查漏补缺"/></a><div class="content"><a class="title" href="/2023/07/25/C++%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" title="C++Primer查漏补缺">C++Primer查漏补缺</a><time datetime="2023-07-25T09:54:13.000Z" title="发表于 2023-07-25 17:54:13">2023-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/C++Primer%E7%AC%94%E8%AE%B0/" title="C++Primer笔记"><img src="/./img/%E7%AC%94%E8%AE%B0p3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++Primer笔记"/></a><div class="content"><a class="title" href="/2023/07/25/C++Primer%E7%AC%94%E8%AE%B0/" title="C++Primer笔记">C++Primer笔记</a><time datetime="2023-07-25T09:53:56.000Z" title="发表于 2023-07-25 17:53:56">2023-07-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Estrella</div><div class="footer_custom_text">Wlcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>