<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++面经整理集 | Estrella博客</title><meta name="author" content="Estrella"><meta name="copyright" content="Estrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++后台开发 &amp;&amp; C++音视频开发：面试问题整理集">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面经整理集">
<meta property="og:url" content="https://estrellaxiaoyu.github.io/2023/07/25/C++%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="Estrella博客">
<meta property="og:description" content="C++后台开发 &amp;&amp; C++音视频开发：面试问题整理集">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://estrellaxiaoyu.github.io/img/%E7%AC%94%E8%AE%B0p1.jpg">
<meta property="article:published_time" content="2023-07-25T09:55:13.000Z">
<meta property="article:modified_time" content="2023-07-29T08:09:34.930Z">
<meta property="article:author" content="Estrella">
<meta property="article:tag" content="Estrella的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://estrellaxiaoyu.github.io/img/%E7%AC%94%E8%AE%B0p1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://estrellaxiaoyu.github.io/2023/07/25/C++%E9%9D%A2%E7%BB%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":100},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++面经整理集',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-29 16:09:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/%E7%AC%94%E8%AE%B0p1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Estrella博客"><span class="site-name">Estrella博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++面经整理集</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-25T09:55:13.000Z" title="发表于 2023-07-25 17:55:13">2023-07-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-29T08:09:34.930Z" title="更新于 2023-07-29 16:09:34">2023-07-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">55.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>182分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++面经整理集"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-语言基础-C-C-over"><a href="#1-语言基础-C-C-over" class="headerlink" title="1. 语言基础 (C&#x2F;C++)&#x3D;&#x3D;over&#x3D;&#x3D;"></a>1. 语言基础 (C&#x2F;C++)&#x3D;&#x3D;over&#x3D;&#x3D;</h1><h2 id="（0）-指针和引用的区别"><a href="#（0）-指针和引用的区别" class="headerlink" title="（0） 指针和引用的区别"></a>（0） 指针和引用的区别</h2><ul>
<li>指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作</li>
<li>指针可以有多级，返回函数内部指向在堆区开辟内存的指针的地址，用于后续手动清理，引用只有一级</li>
<li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改</li>
<li>指针的大小一般是4个字节，64位操作系统是<strong>8个字节</strong>，引用的大小取决于被引用对象的大小</li>
<li>指针变量定义时不必初始化；引用定义时必须初始化，不然会报错，指针可以为空，引用不可以。</li>
</ul>
<h2 id="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"><a href="#（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？" class="headerlink" title="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"></a>（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</h2><ul>
<li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li>
<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li>
<li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li>
</ul>
<h2 id="（2）-堆和栈有什么区别"><a href="#（2）-堆和栈有什么区别" class="headerlink" title="（2） 堆和栈有什么区别"></a>（2） 堆和栈有什么区别</h2><ul>
<li>从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。</li>
<li>堆空间因为会有频繁的分配释放操作，会产生**&#x3D;&#x3D;内存碎片&#x3D;&#x3D;**</li>
<li>堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小</li>
<li>栈的效率——&gt;(3)</li>
</ul>
<h2 id="（3）堆快一点还是栈快一点？（字节提前批一面）"><a href="#（3）堆快一点还是栈快一点？（字节提前批一面）" class="headerlink" title="（3）堆快一点还是栈快一点？（字节提前批一面）"></a>（3）堆快一点还是栈快一点？（字节提前批一面）</h2><ul>
<li>栈快一点。因为<strong>操作系统</strong>会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈有<strong>专门的指令</strong>执行，所以栈的效率比较高也比较快。</li>
<li>而堆的操作是<strong>由C&#x2F;C++函数库</strong>提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</li>
</ul>
<h2 id="（4）-new和delete是如何实现的，new-与-malloc的异同处"><a href="#（4）-new和delete是如何实现的，new-与-malloc的异同处" class="headerlink" title="（4） new和delete是如何实现的，new 与 malloc的异同处"></a>（4） new和delete是如何实现的，new 与 malloc的异同处</h2><p>在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。</p>
<ul>
<li><strong>分配内存的位置</strong>：malloc是从堆上动态分配内存，new是从自由存储区为对象动态分配内存。自由存储区的位置取决于operator new的实现。<strong>自由存储区</strong>不仅可以为堆，还可以是<strong>静态存储区</strong>，这都看operator new在哪里为对象分配内存。</li>
<li><strong>分配内存的大小的计算</strong>：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</li>
<li><strong>内存分配失败返回值</strong>：malloc内存分配失败后返回<strong>NULL</strong>。new分配内存失败则会抛异常（bac_alloc）。</li>
<li><strong>内存分配失败返回值</strong>：malloc内存分配失败后返回<strong>NULL</strong>。new分配内存失败则会抛异常（bac_alloc）。</li>
<li><strong>内存分配成功返回值</strong>：malloc内存分配成功后返回void*，然后再强制类型转换为需要的类型；new操作符分配内存成功后返回与对象类型相匹配的指针类型；因此new是符合<strong>类型安全的操作符</strong>。</li>
<li><strong>是否可以被重载</strong>：opeartor new &#x2F;operator delete可以被重载。而malloc&#x2F;free则不能重载。</li>
</ul>
<h2 id="（5）既然有了malloc-free，C-中为什么还需要new-delete呢？"><a href="#（5）既然有了malloc-free，C-中为什么还需要new-delete呢？" class="headerlink" title="（5）既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？"></a>（5）既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leikun153/article/details/80612130">https://blog.csdn.net/leikun153/article/details/80612130</a></p>
<ul>
<li>malloc&#x2F;free和new&#x2F;delete都是用来申请内存和回收内存的。</li>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc&#x2F;free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc&#x2F;free。</li>
</ul>
<h2 id="（6）-C和C-的区别"><a href="#（6）-C和C-的区别" class="headerlink" title="（6） C和C++的区别"></a>（6） C和C++的区别</h2><p>包括但不限于：</p>
<ul>
<li>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码<strong>模块化</strong>。继承通过子类继承父类的<strong>方法和属性</strong>，实现了<strong>代码复用</strong>。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了<strong>接口复用</strong>。</li>
<li>C和C++内存管理的方法不一样，C使用malloc&#x2F;free，C++除此之外还用new&#x2F;delete</li>
<li>C++中还有函数重载和引用等概念，C中没有</li>
</ul>
<h2 id="（7）delete和delete-的区别"><a href="#（7）delete和delete-的区别" class="headerlink" title="（7）delete和delete[]的区别"></a>（7）delete和delete[]的区别</h2><ul>
<li><p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数</p>
</li>
<li><p>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p>
</li>
</ul>
<h2 id="（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"><a href="#（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）" class="headerlink" title="（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"></a>（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h2><p>包括但不限于：</p>
<ul>
<li>C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。</li>
<li>C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法</li>
<li>JAVA和C++都有构造函数，但是C++有析构函数但是Java没有</li>
<li>C++有指针，Java没有指针，只有引用</li>
</ul>
<h2 id="（9）C-和python的区别"><a href="#（9）C-和python的区别" class="headerlink" title="（9）C++和python的区别"></a>（9）C++和python的区别</h2><p>包括但不限于：</p>
<ol>
<li>python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li>
<li>python使用缩进来区分不同的代码块，C++使用花括号来区分</li>
<li>C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li>
<li>python的库函数比C++的多，调用起来很方便</li>
</ol>
<h2 id="（10）-struct和class的区别"><a href="#（10）-struct和class的区别" class="headerlink" title="（10） struct和class的区别"></a>（10） struct和class的区别</h2><ul>
<li>使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的</li>
<li>struct的继承默认是public继承，而class的继承默认是private继承</li>
<li>class可以用作模板，而struct不能</li>
</ul>
<h2 id="（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）"><a href="#（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）" class="headerlink" title="（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）"></a>（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）</h2><p>  联系：它们都是定义常量的一种方法。</p>
<p>  区别：</p>
<ul>
<li>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。</li>
<li>define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</li>
<li>define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。</li>
<li>const可以定义函数而define不可以。</li>
</ul>
<h2 id="（12）-在C-中const的用法（定义，用途）"><a href="#（12）-在C-中const的用法（定义，用途）" class="headerlink" title="（12） 在C++中const的用法（定义，用途）"></a>（12） 在C++中const的用法（定义，用途）</h2><ul>
<li>const修饰类的成员变量时，表示常量不能被修改</li>
<li>const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</li>
</ul>
<h2 id="（13）-C-中的static用法和意义"><a href="#（13）-C-中的static用法和意义" class="headerlink" title="（13） C++中的static用法和意义"></a>（13） C++中的static用法和意义</h2><p>static的意思是静态的，可以用来修饰变量，函数和类成员。</p>
<ul>
<li><p>变量：被static修饰的变量就是<strong>静态变量</strong>，它会在程序运行过程中一直存在，static修饰的变量一般有两种，局部的和全局的，如果局部的静态变量和全局的静态变量同名的话，这个局部的变量会覆盖全局的，然后局部变量作用域一般是在某个函数体内，如果这个函数被重复调用多次，这个局部的变量只会声明定义一次</p>
</li>
<li><p>函数：被static修饰的函数就是<strong>静态函数</strong>，静态函数只能在本文件中使用，<strong>不能被其他文件调用</strong>，也不会和其他文件中的同名函数冲突。</p>
</li>
<li><p>类：</p>
<ul>
<li><p>而在类中，被static修饰的成员变量是<strong>类静态成员</strong>，这个静态成员会被类的多个对象共用，如果static修饰的变量不是const类型的话，需要<strong>在类外定义</strong>。</p>
</li>
<li><p>被static修饰的成员函数也<strong>属于静态成员</strong>，<strong>不是属于某个对象</strong>的，访问这个静态函数不是通过对象名，而是通过<strong>引用类名来访问</strong>。不具有this指针</p>
</li>
</ul>
</li>
<li><p>初始化顺序：需要注意static在不同编译单元的<strong>初始化顺序</strong>没有明确的定义，可以通过local-static可以有一个明确的初始化顺序</p>
</li>
</ul>
<h2 id="（14）-计算下面几个类的大小："><a href="#（14）-计算下面几个类的大小：" class="headerlink" title="（14） 计算下面几个类的大小："></a>（14） 计算下面几个类的大小：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>空类的大小是1， 在C++中空类会占一个字节，这是<strong>为了让对象的实例能够相互区别</strong>。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的<strong>空白基类最优化</strong>。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)&#x3D;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  A a; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节<br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; <span class="type">int</span> b; &#125;;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p>
<h2 id="（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h2><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p>
<ul>
<li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li>
<li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li>
<li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li>
</ul>
<h2 id="（16）-STL源码中的hash表的实现"><a href="#（16）-STL源码中的hash表的实现" class="headerlink" title="（16） STL源码中的hash表的实现"></a>（16） STL源码中的hash表的实现</h2><p>STL中的hash表就unordered_map，它记录的<strong>键</strong>是<strong>元素的哈希值</strong>，通过对比元素的哈希值<strong>来确定元素的值</strong>。采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过8时，就自动转为红黑树进行组织。</p>
<h2 id="（17）解决哈希冲突的方式？"><a href="#（17）解决哈希冲突的方式？" class="headerlink" title="（17）解决哈希冲突的方式？"></a>（17）解决哈希冲突的方式？</h2><ol>
<li>线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。</li>
<li>二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找1^2,2^2,3^2,4^2…..i^2个位置。</li>
<li>双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。</li>
<li>开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，STL的hashtable就是采用这种实现方式。</li>
<li>建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。</li>
</ol>
<h2 id="（18）-STL中unordered-map和map的区别"><a href="#（18）-STL中unordered-map和map的区别" class="headerlink" title="（18） STL中unordered_map和map的区别"></a>（18） STL中unordered_map和map的区别</h2><ul>
<li>unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现&#x3D;&#x3D;操作符。</li>
<li>map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。</li>
</ul>
<h2 id="（19）-STL中vector的实现"><a href="#（19）-STL中vector的实现" class="headerlink" title="（19） STL中vector的实现"></a>（19） STL中vector的实现</h2><p>STL中的vector是<strong>封装了动态数组的顺序容器</strong>。<strong>不过与动态数组不同的是</strong>，vector在容量不够的时候会自动扩大容器的大小。具体策略是更大内存，一般是原来的两倍，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针，还可以通过将原来容器元素<strong>移动</strong>到新容器中，提高性能。这样子的话可以减少频繁插入元素时扩大容器的时间</p>
<h2 id="（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h2><p>如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分<strong>耗时和耗内存</strong>的，可以通过将原来容器元素移动到新容器中，提高性能。频繁调用push_back()会使得程序<strong>花费很多时间在vector扩容上</strong>，会变得很慢。这种情况可以考虑使用list。</p>
<h2 id="（21）C-中vector和list的区别"><a href="#（21）C-中vector和list的区别" class="headerlink" title="（21）C++中vector和list的区别"></a>（21）C++中vector和list的区别</h2><ul>
<li><p>vector和数组类似，拥有一段<strong>连续的内存空间</strong>，所以支持<strong>随机访问</strong>，然后它的插入和删除元素可能会<strong>导致大量元素的移动</strong>，造成大量拷贝，比较消耗内存。它还有<strong>自动扩容的机制</strong>，就是在容量不够的时候会分配一个内存容量更大的容器，然后将原来容器中的元素拷贝过去，这个过程比较消耗性能，可以通过将原来容器元素移动到新容器中，提高性能</p>
</li>
<li><p>list是由<strong>双向链表</strong>实现的，因此内存空间是<strong>不连续</strong>的，list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能<strong>高效地进行插入和删除</strong>。</p>
</li>
<li><p>迭代器</p>
<ul>
<li><p>vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+&#x3D;”，“&lt;”等操作符。list::iterator则不支持</p>
</li>
<li><p>vector::iterator和list::iterator都重载了“++”运算符。<strong>可用于遍历</strong></p>
</li>
</ul>
</li>
</ul>
<p>总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</p>
<p>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</p>
<h2 id="（22）-C-中的重载和重写的区别："><a href="#（22）-C-中的重载和重写的区别：" class="headerlink" title="（22） C++中的重载和重写的区别："></a>（22） C++中的重载和重写的区别：</h2><ul>
<li>重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，<strong>但返回值不可以作为区分不同重载函数的标志</strong>。</li>
<li>重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30379911/article/details/99497160">https://blog.csdn.net/weixin_30379911/article/details/99497160</a></p>
<h2 id="（23）-C-内存管理（热门问题）"><a href="#（23）-C-内存管理（热门问题）" class="headerlink" title="（23） C ++内存管理（热门问题）"></a>（23） C ++内存管理（热门问题）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43152052/article/details/98889139">https://blog.csdn.net/qq_43152052/article/details/98889139</a></p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、全局&#x2F;静态存储区和常量存储区和代码区。</p>
<ul>
<li><p><strong>栈</strong>：由**&#x3D;&#x3D;编译器&#x3D;&#x3D;**自动分配释放，存放为函数运行的局部变量，函数参数，返回数据，返回地址等。</p>
<ul>
<li>操作系统会在<strong>底层</strong>对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈有专门的指令<strong>执行</strong>，但是分配的<strong>内存容量有限</strong>，超过容量就会导致栈溢出。</li>
<li>地址空间是向下增长的，越来越小</li>
</ul>
</li>
<li><p><strong>堆</strong>：一般由**&#x3D;&#x3D;程序员&#x3D;&#x3D;**分配释放，若程序员不释放，程序结束时可能由OS回收；分配方式类似于链表</p>
<ul>
<li>在操作系统中有一个<strong>记录空闲内存地址的链表</strong>。它记录了有哪些还未使用的内存空间。当系统收到程序的申请时，会遍历该链表，寻找<strong>第一个空间大于所申请空间的堆结点</strong>，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</li>
<li>地址空间是向上增长的，越来越大</li>
</ul>
</li>
<li><p><strong>全局&#x2F;静态存储区</strong>：内存在程序**&#x3D;&#x3D;编译的时候&#x3D;&#x3D;<strong>就已经分配好，这块内存在程序的</strong>整个运行期间**都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。</p>
</li>
<li><p><strong>常量</strong>存储区：里面存放的是<strong>常量字符串</strong>，不允许修改，无<strong>法访问常量的地址的。</strong></p>
</li>
<li><p><strong>代码区</strong>：存放程序的二进制代码</p>
</li>
</ul>
<p>关于这个有很多种说法，有的会增加一个自由存储区，存放new分配得到的内存，与堆相似。</p>
<img src="面经整理发布版.assets/1629687632@2dda0b7df0c9fdaecae07f062e25145a.png" alt="img" style="zoom:50%;" />



<h2 id="（24）-介绍面向对象的三大特性，并且举例说明每一个。"><a href="#（24）-介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="（24） 介绍面向对象的三大特性，并且举例说明每一个。"></a>（24） 介绍面向对象的三大特性，并且举例说明每一个。</h2><p>面向对象的三大特性是：封装，继承和多态。</p>
<ul>
<li>封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；</li>
<li>继承使得子类可以复用父类的成员和方法，实现了代码重用；</li>
<li>多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。<ul>
<li>C++多态包括编译时多态和运行时多态，编译时多态体现在<strong>函数重载和模板上</strong>，运行时多态体现在<strong>虚函数</strong>上。</li>
</ul>
</li>
</ul>
<h2 id="（25）-多态的实现（和下个问题一起回答）"><a href="#（25）-多态的实现（和下个问题一起回答）" class="headerlink" title="（25） 多态的实现（和下个问题一起回答）"></a>（25） 多态的实现（和下个问题一起回答）</h2><p>C++ 多态包括编译时多态和运行时多态，编译时多态体现在<strong>函数重载和模板上</strong>，运行时多态体现在<strong>虚函数</strong>上。</p>
<ul>
<li>虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.</li>
</ul>
<h2 id="（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h2><ul>
<li><p>C++多态通过虚函数来实现，这个是运行时多态，编译时多态的话通过函数重载和模板来实现。</p>
</li>
<li><p><strong>是什么：</strong></p>
<ul>
<li>虚函数表是每个类中存放<strong>虚函数地址的&#x3D;&#x3D;指针数组&#x3D;&#x3D;<strong>，类的实例在</strong>调用虚函数时</strong>会<strong>在虚函数表中寻找函数地址进行调用</strong></li>
</ul>
</li>
<li><p><strong>编译期阶段</strong>：</p>
<ul>
<li>虚函数表是在编译阶段构建好的，而且编译器会为类生成一个<strong>指向虚函数表的指针</strong></li>
</ul>
<p><code>*__vptr</code></p>
</li>
<li><p><strong>注意点：</strong></p>
<ul>
<li>一个类的所有实例都共享&#x3D;&#x3D;<strong>同一张</strong>&#x3D;&#x3D;虚函数表</li>
<li><strong>子类</strong><ul>
<li>如果一个类继承了有虚函数的基类，这个子类也会有虚函数表和指向虚表的指针</li>
<li>如果子类重写了父类的虚函数，则子类的虚函数表会指向子类实现的&#x3D;&#x3D;函数地址&#x3D;&#x3D;，否则指向父类的函数地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lihao21/article/details/50688337">C++虚函数表剖析</a></p>
<ul>
<li><p>如果多重继承和多继承的话，子类的虚函数表长什么样子？<br><strong>多重继承</strong>的情况下**&#x3D;&#x3D;越是祖先&#x3D;&#x3D;<strong>的父类的虚函数更靠前，</strong>多继承<strong>的情况下越是</strong>&#x3D;&#x3D;靠近子类名称&#x3D;&#x3D;**的类的虚函数在虚函数表中更靠前。详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36359022/article/details/81870219">https://blog.csdn.net/qq_36359022/article/details/81870219</a></p>
</li>
<li><p>我们把经过虚表调用虚函数的过程称为<strong>动态绑定</strong></p>
<ul>
<li>调用虚函数、通过指针调用函数</li>
</ul>
</li>
<li><p>传统的函数调用我们称之为<strong>静态绑定</strong></p>
</li>
</ul>
<h2 id="（27）-编译器如何处理处理虚函数表"><a href="#（27）-编译器如何处理处理虚函数表" class="headerlink" title="（27） 编译器如何处理处理虚函数表"></a>（27） 编译器如何处理处理虚函数表</h2><ul>
<li>见（26）</li>
</ul>
<h2 id="（28）-基类的析构函数一般写成虚函数的原因"><a href="#（28）-基类的析构函数一般写成虚函数的原因" class="headerlink" title="（28） 基类的析构函数一般写成虚函数的原因"></a>（28） 基类的析构函数一般写成虚函数的原因</h2><ul>
<li>不是虚函数<ul>
<li>当<strong>析构</strong>一个<strong>指向子类的父类指针</strong>时，如果子类的析构函数不是虚函数的话，编译器就会实施静态绑定，调用父类的析构函数而不是调用子类的析构函数，这样会因为子类<strong>析构不完全</strong>而导致<strong>内存泄漏</strong></li>
</ul>
</li>
<li>是虚函数<ul>
<li>编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而<strong>正确</strong>释放子类对象的资源。</li>
</ul>
</li>
</ul>
<h2 id="（29）-构造函数为什么一般不定义为虚函数"><a href="#（29）-构造函数为什么一般不定义为虚函数" class="headerlink" title="（29） 构造函数为什么一般不定义为虚函数"></a>（29） 构造函数为什么一般不定义为虚函数</h2><ul>
<li><strong>因为子类在构造的时候，是先构造父类，再构造子类</strong>，如果父类的构造函数是虚函数的话，子类要调用这个函数就要通过虚函数表来调用，然而虚函数表是在子类构造的时候才会创建出来，从而无法调用父类的构造函数</li>
</ul>
<h2 id="（30）-构造函数或者析构函数中调用虚函数会怎样"><a href="#（30）-构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="（30） 构造函数或者析构函数中调用虚函数会怎样"></a>（30） 构造函数或者析构函数中调用虚函数会怎样</h2><ul>
<li>首先子类在构造的时候，是先构造父类，再构造子类，如果父类在构造函数中调用虚函数的话，就需要访问子类的虚函数表，然而子类的虚函数表是在子类构造的时候才创建的，所以无法实现。</li>
<li>在析构的时候，是先析构子类，再析构父类，然后，子类在被析构的时候，虚函数表已经被释放掉了，然而父类的析构函数需要虚函数表来调用函数，所以无法实现</li>
</ul>
<h2 id="（31）-纯虚函数"><a href="#（31）-纯虚函数" class="headerlink" title="（31） 纯虚函数"></a>（31） 纯虚函数</h2><ul>
<li>是什么<ul>
<li>纯虚函数是**&#x3D;&#x3D;只有声明没有实现&#x3D;&#x3D;**的虚函数，需要子类重写这个纯虚函数</li>
</ul>
</li>
<li>注意点<ul>
<li>包含纯虚函数的类是抽象类，它**&#x3D;&#x3D;不能被实例化&#x3D;&#x3D;<strong>，子类只有重写了这个纯虚函数</strong>才能**生成对象</li>
</ul>
</li>
</ul>
<p>使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。</p>
<h2 id="（32）-静态绑定和动态绑定的介绍"><a href="#（32）-静态绑定和动态绑定的介绍" class="headerlink" title="（32） 静态绑定和动态绑定的介绍"></a>（32） 静态绑定和动态绑定的介绍</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lizhenghn/p/3657717.html">C++中的静态绑定和动态绑定</a></p>
<ul>
<li><p>静态绑定就是绑定静态类型，静态类型就是对象&#x3D;&#x3D;<strong>在声明时</strong>&#x3D;&#x3D;采用的类型，在编译期既已确定</p>
</li>
<li><p>动态绑定就是绑定动态类型，通常是指一个<strong>指针或引用</strong>&#x3D;&#x3D;目前&#x3D;&#x3D;所指对象的类型，是在运行期决定的</p>
</li>
</ul>
<h2 id="（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h2><ul>
<li>一般是再拷贝指针的时候出现的深拷贝和浅拷贝</li>
<li>浅拷贝指的是只拷贝指针，不拷贝指针指向的内容，这样就有两个指针指向同一块内存，如果通过一个指针释放掉这块内存，然后又用另一个指针释放这块内存，就会产生错误</li>
<li>深拷贝就是用来解决这个问题，就是把指针和指针指向的内存都拷贝一份就可以了。</li>
</ul>
<h2 id="（34）-对象复用的了解，零拷贝的了解"><a href="#（34）-对象复用的了解，零拷贝的了解" class="headerlink" title="（34） 对象复用的了解，零拷贝的了解"></a>（34） 对象复用的了解，零拷贝的了解</h2><ul>
<li><p>对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是**&#x3D;&#x3D;继承和复合&#x3D;&#x3D;**模式了。</p>
</li>
<li><p>C++中 emplace_back 就是利用零拷贝的技术</p>
</li>
<li><p>Linux中零拷贝指的是完全在内核中进行的操作，从而可以避免内核缓冲区和用户缓冲区之间的数据拷贝，效率很高</p>
</li>
<li><p>我了解到的一些零拷贝的Linux的api有<strong>sendfile，splice，tee，mmap</strong></p>
</li>
<li><p>sendfile是两个文件描述符之间传递数据</p>
</li>
<li><p>splice是两个文件描述符之间移动数据</p>
</li>
<li><p>tee是两个文件描述符之间传递数据，至少有一个文件描述符是管道描述符</p>
</li>
<li><p>mmap会在内核缓冲区开辟一个共享内存，这个共享内存对用进程是可见的，进程可以直接从共享内存读取和发送数据</p>
<ul>
<li>共享内存介绍——&gt;操作系统（4）</li>
</ul>
</li>
</ul>
<blockquote>
<p>用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p>
</blockquote>
<h2 id="（35）-介绍C-所有的构造函数"><a href="#（35）-介绍C-所有的构造函数" class="headerlink" title="（35） 介绍C++所有的构造函数"></a>（35） 介绍C++所有的构造函数</h2><ul>
<li><ul>
<li><p>C++中的构造函数可以分为4类：</p>
<ul>
<li>默认构造函数</li>
<li>初始化构造函数（有参数）</li>
<li>拷贝构造函数</li>
<li>移动构造函数（move和右值引用）</li>
<li>委托构造函数？</li>
<li>转换构造函数</li>
</ul>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>() &#123;<span class="comment">//默认构造函数，没有参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> a, <span class="type">int</span> n):<span class="built_in">age</span>(a), <span class="built_in">num</span>(n) &#123;&#125;; <span class="comment">//初始化构造函数，有参数和参数列表</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student&amp; s) &#123;<span class="comment">//拷贝构造函数，这里与编译器生成的一致</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = s.age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = s.num;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> r) &#123;   <span class="comment">//转换构造函数,形参是其他类型变量，且只有一个形参</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = r;</span><br><span class="line">		<span class="keyword">this</span>-&gt;num = <span class="number">1002</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">18</span>,<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function">Student <span class="title">s3</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s4</span><span class="params">(s3)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 age:%d, num:%d\n&quot;</span>, s1.age, s1.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 age:%d, num:%d\n&quot;</span>, s2.age, s2.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s3 age:%d, num:%d\n&quot;</span>, s3.age, s3.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 age:%d, num:%d\n&quot;</span>, s4.age, s4.num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// s1 age:20, num:1000</span></span><br><span class="line"><span class="comment">// s2 age:18, num:1001</span></span><br><span class="line"><span class="comment">// s3 age:10, num:1002</span></span><br><span class="line"><span class="comment">// s2 age:10, num:1002</span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</li>
<li>复制构造函数用于复制本类的对象</li>
<li>转换构造函数用于将其他类型的变量，隐式转换为本类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="（36）-什么情况下会调用拷贝构造函数（三种情况）"><a href="#（36）-什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="（36） 什么情况下会调用拷贝构造函数（三种情况）"></a>（36） 什么情况下会调用拷贝构造函数（三种情况）</h2><ul>
<li><p>对象以值传递的方式传入函数参数 </p>
<blockquote>
<p>如 <code> void func(Dog dog)&#123;&#125;;</code></p>
</blockquote>
</li>
<li><p>对象以值传递的方式从函数返回</p>
<blockquote>
<p>如 <code> Dog func()&#123; Dog d; return d;&#125;</code></p>
</blockquote>
</li>
<li><p>对象需要通过另外一个对象进行初始化</p>
</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lwbeyond/article/details/6202256">C++拷贝构造函数详解</a></p>
<h2 id="（37）-结构体内存对齐方式和为什么要进行内存对齐？"><a href="#（37）-结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="（37） 结构体内存对齐方式和为什么要进行内存对齐？"></a>（37） 结构体内存对齐方式和为什么要进行内存对齐？</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/image-20230602131558223.png" alt="image-20230602131558223"></p>
<ul>
<li>主要是为了提高cpu读取的效率</li>
<li>由于CPU读取数据是按块读取的，可以使得CPU一次就可以将所需的数据读进来</li>
<li>对齐规则<ul>
<li>变量<strong>只能</strong>存储在其类型长度的<strong>整数倍地址</strong></li>
<li>结构体还需要和其拥有对象的长度最长的类型的长度的整数倍对齐</li>
<li>前提是pack参数比类型长度要长，否则遍历存储在pack参数的整数倍地址<ul>
<li>#pragram pack(show) 来看pack参数大小</li>
</ul>
</li>
<li>数组按照数组的类型来对齐</li>
<li>嵌套的struct是按照规则2取对齐参数</li>
</ul>
</li>
</ul>
<h2 id="（38）内存泄漏的定义，产生原因，如何检测与避免？"><a href="#（38）内存泄漏的定义，产生原因，如何检测与避免？" class="headerlink" title="（38）内存泄漏的定义，产生原因，如何检测与避免？"></a>（38）内存泄漏的定义，产生原因，如何检测与避免？</h2><ul>
<li><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为<strong>内存泄漏</strong>。</p>
</li>
<li><p>造成内存泄漏的几种原因：</p>
<ul>
<li>new和delete**&#x3D;&#x3D;没有配套&#x3D;&#x3D;**使用</li>
<li>用new[]为一组对象分配了内存，在释放对象数组时**&#x3D;&#x3D;没有使用delete[]&#x3D;&#x3D;**，使用了delete</li>
<li>没有将基类的**&#x3D;&#x3D;析构函数&#x3D;&#x3D;**定义为虚函数，当要释放一个指向子类的基类指针时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</li>
<li>没有正确的清楚嵌套的对象指针<ul>
<li>对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间</li>
<li>指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了</li>
</ul>
</li>
</ul>
</li>
<li><p>避免方法：</p>
<ul>
<li>new&#x2F;delete，malloc&#x2F;free要配套</li>
<li>使用智能指针</li>
<li>将基类的析构函数设为虚函数</li>
</ul>
</li>
<li><p><strong>检测工具</strong></p>
<ul>
<li>Linux下可以使用<strong>Valgrind工具</strong></li>
<li>Windows下可以使用<strong>CRT库</strong></li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/We_are_family678/article/details/79658097">C++内存泄露检查的5个方法</a></p>
</li>
</ul>
<h2 id="（39）-C-的智能指针有哪些"><a href="#（39）-C-的智能指针有哪些" class="headerlink" title="（39） C++的智能指针有哪些"></a>（39） C++的智能指针有哪些</h2><p>C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记<strong>释放指针指向的内存地址</strong>造成内存泄漏。</p>
<ul>
<li><p>auto_ptr</p>
<ul>
<li>是较早版本的智能指针，在进行指针拷贝和赋值的时候，会将旧指针&#x3D;&#x3D;<strong>管理权</strong>&#x3D;&#x3D;交给新指针并让旧指针置空，但是这种方式在需要访问旧指针的时候，就会出现问题，。C++11 已将其摒弃</li>
</ul>
</li>
<li><p>unique_ptr</p>
<ul>
<li>是auto_ptr的一个改良版，unique_ptr更安全，更灵活，不支持赋值也不能拷贝构造，支持移动构造和移动复制，为了<strong>保证一个对象同一时间只有一个智能指针</strong><ul>
<li>更安全：编译器会自动检测是否使用了拷贝语义</li>
<li>更灵活：可以进行临时对象拷贝：函数返回临时对象，还多了删除器</li>
<li>reset(new …)：重置空间，原来空间清理</li>
<li>主动释放空间：p &#x3D; nullptr（只支持nullptr赋值）</li>
<li>释放所有权：auto p1 &#x3D; p0.release(); delete p1; 需要手动释放空间</li>
<li>自定义空间删除方法：传删除器（是个类函数）可以用来关闭连接（文件描述符）：close(fd)，管理锁</li>
<li>有着十分接近裸指针的性能</li>
</ul>
</li>
</ul>
</li>
<li><p>shared_ptr</p>
<ul>
<li>可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。（内部使用计数机制进行维护）</li>
<li>删除器是函数指针或者 lambda 表达式</li>
</ul>
</li>
<li><p>weak_ptr</p>
<ul>
<li>是为了**&#x3D;&#x3D;协助 shared_ptr&#x3D;&#x3D;**而出现的。它不能访问对象，只能观测shared_ptr的引用计数，解决shared_ptr 循环引用的问题<ul>
<li><strong>循环引用</strong>：两个类的shared_ptr指针，互相内部有share_ptr导致对方use_count+1 &#x3D;&#x3D; 2，两个share_ptr离开作用域后use_count - 1 &#x3D;&#x3D; 1，此时都想要对方内部的share_ptr析构，但类无法析构，类内的成员也就无法析构</li>
<li>可以用 lock() 访问对象：如果对象存在获取一个share_ptr的引用计数不为0获取临时的share_ptr，离开其作用域后use_count-1</li>
<li>expired()：判断对象是否被销毁</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>简单实现一个<strong>线程安全</strong>shared_ptr<ul>
<li>模板</li>
<li>explicit重载构造：初始化列表 _ptr，_refCount，_mutex</li>
<li>拷贝构造：初始化列表 _ptr，_refCount，_mutex &amp;&amp; 线程安全 _refCount++</li>
<li>赋值构造：自我赋值检测 + 线程安全release + 赋值 + 线程安全 _refCount++</li>
<li>重载 * 和 -&gt;</li>
<li>返回内置指针 + 返回 _refCount</li>
<li>线程安全 _refCount++ + 线程安全release</li>
<li>T* _ptr + int* _pRefcount + mutex* _pMutex</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;		<span class="comment">//模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shared_Ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Shared_Ptr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span>	<span class="comment">// 重载构造函数</span></span></span><br><span class="line"><span class="function">                        :_pPtr(ptr)</span></span><br><span class="line"><span class="function">                        , _pRefCount(new int(<span class="number">1</span>))</span></span><br><span class="line"><span class="function">                        , _pMutex(new mutex) &#123;</span>&#125;</span><br><span class="line">	~<span class="built_in">Shared_Ptr</span>() &#123;</span><br><span class="line">		<span class="built_in">Release</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Shared_Ptr</span>(<span class="type">const</span> Shared_Ptr&lt;T&gt;&amp; sp)	<span class="comment">//拷贝构造函数</span></span><br><span class="line">			   :_pPtr(sp._pPtr)</span><br><span class="line">               , _pRefCount(sp._pRefCount)</span><br><span class="line">               , _pMutex(sp._pMutex) &#123;</span><br><span class="line">		<span class="built_in">AddRefCount</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	Shared_Ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Shared_Ptr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">		<span class="comment">//if (this != &amp;sp)</span></span><br><span class="line">		<span class="keyword">if</span> (_pPtr != sp._pPtr) &#123;		<span class="comment">//检测自我赋值</span></span><br><span class="line">			<span class="comment">// 释放管理的旧资源</span></span><br><span class="line">			<span class="built_in">Release</span>();</span><br><span class="line">			<span class="comment">// 共享管理新对象的资源，并增加引用计数</span></span><br><span class="line">			_pPtr = sp._pPtr;</span><br><span class="line">			_pRefCount = sp._pRefCount;</span><br><span class="line">			_pMutex = sp._pMutex;</span><br><span class="line">			<span class="built_in">AddRefCount</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123;			<span class="comment">// 解引用</span></span><br><span class="line">		<span class="keyword">return</span> *_pPtr;</span><br><span class="line">	&#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123;			<span class="comment">// -&gt;</span></span><br><span class="line">		<span class="keyword">return</span> _pPtr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">UseCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *_pRefCount; &#125;	<span class="comment">//返回引用计数</span></span><br><span class="line">	<span class="function">T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _pPtr; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddRefCount</span><span class="params">()</span> </span>&#123;		<span class="comment">// 线程安全 ++count</span></span><br><span class="line">		_pMutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line">		++(*_pRefCount);</span><br><span class="line">		_pMutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;			<span class="comment">// 线程安全 释放</span></span><br><span class="line">		<span class="type">bool</span> deleteflag = <span class="literal">false</span>;</span><br><span class="line">		_pMutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line">		<span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> _pRefCount;</span><br><span class="line">			<span class="keyword">delete</span> _pPtr;</span><br><span class="line">			deleteflag = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		_pMutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">		<span class="keyword">if</span> (deleteflag == <span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">delete</span> _pMutex;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> *_pRefCount;			<span class="comment">// 全是指针</span></span><br><span class="line">	T* _pPtr;</span><br><span class="line">	mutex* _pMutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>简单实现一个<strong>线程安全</strong>weak_ptr（后面准备暑期实习的时候再加上）<ul>
<li>解决 share_ptr 循环引用问题</li>
<li>lock()：获取 share_ptr 指针，如果count &#x3D;&#x3D; 0 return nullptr</li>
</ul>
</li>
<li>简单实现一个<strong>线程安全</strong>unique_ptr（后面准备暑期实习的时候再加上）</li>
</ul>
<h2 id="（40）-调试程序的方法"><a href="#（40）-调试程序的方法" class="headerlink" title="（40） 调试程序的方法"></a>（40） 调试程序的方法</h2><ul>
<li>通过设置断点进行调试</li>
<li>打印log进行调试</li>
<li>打印中间结果进行调试</li>
</ul>
<h2 id="（41）-遇到coredump要怎么调试"><a href="#（41）-遇到coredump要怎么调试" class="headerlink" title="（41） 遇到coredump要怎么调试"></a>（41） 遇到coredump要怎么调试</h2><p>——&gt;Linux（18）coredump 是什么 + 产生 coredump 的原因</p>
<ul>
<li>使用gdb命令对core文件进行调试</li>
</ul>
<p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir coredumpTest</span><br><span class="line">vim coredumpTest.cpp</span><br></pre></td></tr></table></figure>

<p>在编辑器内键入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,i);<span class="comment">//正确的应该是&amp;i,这里使用i会导致segment fault</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ coredumpTest.cpp -g -o coredumpTest</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./coredumpTest</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/46605905">使用gdb调试coredump</a>：有时间再多了解</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [可执行文件名] [core文件名]</span><br></pre></td></tr></table></figure>



<h2 id="（42）-inline关键字说一下-和宏定义有什么区别"><a href="#（42）-inline关键字说一下-和宏定义有什么区别" class="headerlink" title="（42） inline关键字说一下 和宏定义有什么区别"></a>（42） inline关键字说一下 和宏定义有什么区别</h2><blockquote>
<p>inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。inline函数被修改后程序需要重新编译。</p>
</blockquote>
<ul>
<li>建议：<ul>
<li>inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个<strong>建议</strong>，如果inline函数太复杂：带有循环或递归、switch-case语句inline会失效，编译器可以选择忽略该建议，不对该函数进行展开。</li>
</ul>
</li>
<li>编译：<ul>
<li>内联函数在<strong>编译时</strong>直接被<strong>嵌入到目标代码</strong>中去，而宏在<strong>预编译</strong>时进行一个简单的<strong>文本替换</strong>。</li>
<li>内联函数可以进行诸如<strong>类型安全检查</strong>、<strong>语句是否正确</strong>等编译功能，宏不具有这样的功能。</li>
</ul>
</li>
<li>函数<ul>
<li>宏不是函数，而inline是函数</li>
<li>宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现<strong>二义性</strong>。而内联函数不会出现二义性。</li>
</ul>
</li>
</ul>
<h2 id="（43）-模板的用法与适用场景-实现原理"><a href="#（43）-模板的用法与适用场景-实现原理" class="headerlink" title="（43） 模板的用法与适用场景 实现原理"></a>（43） 模板的用法与适用场景 实现原理</h2><ul>
<li><p>用template &lt;typename T&gt;关键字进行声明，接下来就可以进行模板函数和模板类的编写了</p>
</li>
<li><p>编译器会对函数模板进行<strong>两次编译</strong>：在声明的地方对&#x3D;&#x3D;模板代码&#x3D;&#x3D;本身进行编译，这次编译<strong>只会进行一个语法检查</strong>，并不会生成具体的代码。在创建实例的时候对代码进行参数替换后再进行编译，生成<strong>具体的函数代码</strong>。</p>
</li>
</ul>
<h2 id="（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h2><p>成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span> (<span class="type">int</span> &amp;inputID, string &amp;inputName, FaceImage &amp;inputFace);</span><br><span class="line">    ~<span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    FaceImage face;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">A</span> (<span class="type">int</span> &amp;inputID, string &amp;inputName, FaceImage &amp;inputFace)</span><br><span class="line">       : <span class="built_in">id</span>(inputID), <span class="built_in">name</span>(inputName), <span class="built_in">face</span>(inputFace) &#123;&#125;	<span class="comment">// 成员初始化列表</span></span><br></pre></td></tr></table></figure>

<p>因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了默认构造函数的过程，否则会调用一次默认构造函数，再调用赋值构造函数。所以使用成员初始化列表效率会高一些。</p>
<ul>
<li><p>有三种情况是<strong>必须使用成员初始化列表进行初始化</strong>的：</p>
<ul>
<li><p><strong>常量成员</strong>的初始化，因为常量成员只能初始化不能赋值</p>
</li>
<li><p><strong>引用</strong>类型</p>
</li>
<li><p>没有默认构造函数的类类型：使用初始化列表可以不用调用默认构造函数</p>
</li>
</ul>
</li>
</ul>
<p>详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html">C++ 初始化列表</a></p>
<h2 id="（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h2><ul>
<li><p><strong>自动类型推导auto</strong> 和 <strong>decltype</strong></p>
<ul>
<li>auto 根据<code>=</code>右边的初始值 value 推导出变量的类型；</li>
<li>decltype 根据 exp 表达式推导出变量的类型，跟<code>=</code>右边的 value 没有关系。</li>
<li>decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符。<ul>
<li>以下是 auto 关键字对 cv 限定符的推导规则：<ul>
<li>如果表达式的类型不是<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。</li>
<li>如果表达式的类型是指针或者引用，auto 将保留 cv 限定符。</li>
</ul>
</li>
<li>decltype推到引用时就是引用，auto推导出引用对象类型</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>lambda表达式</strong>：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：<br><code>[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型&#123;函数体&#125;</code></p>
</li>
<li><p>新的<strong>智能指针</strong> <strong>unique_ptr和shared_ptr</strong></p>
</li>
<li><p><strong>nullptr</strong></p>
<ul>
<li>函数参数进行传参的时候传入NULL可能会产生二义性问题，NULL既可以表示 <strong>(int)0</strong>，也可以表示 <em><em>(void</em>)0</em>*</li>
<li>nullptr的类型就是void*</li>
</ul>
</li>
<li><p><strong>thread类和mutex类</strong></p>
</li>
<li><p>更多详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279">https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279</a></p>
</li>
</ul>
<h2 id="（46）C-函数调用的压栈过程"><a href="#（46）C-函数调用的压栈过程" class="headerlink" title="（46）C++函数调用的压栈过程"></a>（46）C++函数调用的压栈过程</h2><p>从代码入手，解释这个过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> var1 = param1;</span><br><span class="line">	<span class="type">int</span> var2 = param2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;var1=%d,var2=%d&quot;</span>, <span class="built_in">f</span>(var1), <span class="built_in">f</span>(var2));<span class="comment">//如果将printf换为cout进行输出，输出结果则刚好相反</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// var1=1,var2=2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当函数从入口函数main函数开始执行时，编译器会将我们<strong>操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈</strong>；</li>
<li>当main函数开始调用func()函数时，编译器此时会将<strong>main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈</strong>；</li>
<li>当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</li>
<li>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</li>
</ul>
<p>函数的调用过程：</p>
<ul>
<li>从栈空间分配存储空间</li>
<li>从实参的<strong>存储空间</strong>复制值到<strong>形参栈空间</strong></li>
<li>进行运算</li>
</ul>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p>
<p>数组作为参数的函数调用方式是<strong>地址传递</strong>，形参和实参都指向相同的内存空间，调用完成后，<strong>形参指针被销毁</strong>，但是所指向的内存空间依然存在，不能也不会被销毁。</p>
<p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。</p>
<h2 id="（47）-C-的四种强制转换"><a href="#（47）-C-的四种强制转换" class="headerlink" title="（47） C++的四种强制转换"></a>（47） C++的四种强制转换</h2><p>四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast</p>
<ul>
<li><p>1）static_cast ：<br>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。</p>
<blockquote>
<p>特性与要点：</p>
<ol>
<li>它没有运行时类型检查，所以是有安全隐患的。</li>
<li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li>
<li>static_cast不能转换const，volatile等属性</li>
</ol>
</blockquote>
</li>
<li><p>2）dynamic_cast：<br>用于动态类型转换。具体的说，就是在<strong>基类指针到派生类指针</strong>，或者<strong>派生类到基类指针</strong>的转换。<br>dynamic_cast能够提供<strong>运行时类型检查</strong>，只用于&#x3D;&#x3D;含有虚函数的类&#x3D;&#x3D;。<br>dynamic_cast如果不能转换<strong>返回NULL</strong>。</p>
</li>
<li><p>3）const_cast：<br>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</p>
</li>
<li><p>4）reinterpret_cast<br>几乎什么都可以转，用在任意的<strong>指针之间的转换</strong>，<strong>引用之间的转换</strong>，<strong>指针和足够大的int型之间</strong>的转换，整数到指针的转换等。但是不够安全。</p>
</li>
</ul>
<h2 id="（48）string的底层实现"><a href="#（48）string的底层实现" class="headerlink" title="（48）string的底层实现"></a>（48）string的底层实现</h2><p>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</p>
<p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p>
<h2 id="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"><a href="#（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的" class="headerlink" title="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"></a>（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</h2><h3 id="（1）预编译"><a href="#（1）预编译" class="headerlink" title="（1）预编译"></a>（1）预编译</h3><p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：</p>
<ol>
<li>删除所有的#define，展开所有的宏定义。</li>
<li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</li>
<li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。</li>
<li>删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</li>
<li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。</li>
</ol>
<h3 id="（2）编译"><a href="#（2）编译" class="headerlink" title="（2）编译"></a>（2）编译</h3><p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应 的汇编代码文件。</p>
<ol>
<li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分 割成一系列的记号。</li>
<li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的 语法树是一种以表达式为节点的树。</li>
<li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进 行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义。</li>
<li>优化：源代码级别的一个优化过程。</li>
<li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言 表示。</li>
<li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移 来替代乘法运算、删除多余的指令等。</li>
</ol>
<h3 id="（3）汇编"><a href="#（3）汇编" class="headerlink" title="（3）汇编"></a>（3）汇编</h3><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没 有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过 来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Window下)。</p>
<h3 id="（4）链接"><a href="#（4）链接" class="headerlink" title="（4）链接"></a>（4）链接</h3><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链 接：</p>
<ul>
<li><strong>静态链接</strong></li>
</ul>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<p>&#x3D;&#x3D;空间浪费&#x3D;&#x3D;：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
<p>&#x3D;&#x3D;更新困难&#x3D;&#x3D;：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行&#x3D;&#x3D;速度快&#x3D;&#x3D;：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快。</p>
<ul>
<li><strong>动态链接</strong></li>
</ul>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形 成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>&#x3D;&#x3D;共享&#x3D;&#x3D;库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副 本，而是这多个程序在执行时<strong>共享同一份副本</strong>；</p>
<p>&#x3D;&#x3D;更新方便&#x3D;&#x3D;：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运 行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>&#x3D;&#x3D;性能损耗&#x3D;&#x3D;：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损 失。</p>
<h2 id="（50）set，map和vector的插入复杂度"><a href="#（50）set，map和vector的插入复杂度" class="headerlink" title="（50）set，map和vector的插入复杂度"></a>（50）set，map和vector的插入复杂度</h2><ul>
<li>set,map的插入复杂度就是红黑树的插入复杂度，是log(N)</li>
<li>unordered_set,unordered_map的插入复杂度是常数，最坏是O(N)</li>
<li>vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝</li>
</ul>
<h2 id="（51）定义和声明的区别"><a href="#（51）定义和声明的区别" class="headerlink" title="（51）定义和声明的区别"></a>（51）定义和声明的区别</h2><ul>
<li><p>声明是告诉编译器变量的类型和名字，<strong>不会为变量分配内存</strong></p>
</li>
<li><p>定义就是对这个变量和函数进行<strong>内存分配和初始化</strong></p>
</li>
<li><p>同一个变量可以被声明多次，但是只能被定义一次</p>
</li>
</ul>
<h2 id="（52）typdef和define区别"><a href="#（52）typdef和define区别" class="headerlink" title="（52）typdef和define区别"></a>（52）typdef和define区别</h2><ul>
<li><p>#define是预处理命令，在预处理是执行简单的替换</p>
</li>
<li><p>typedef是在<strong>编译时</strong>处理的，它是在<strong>自己的作用域内给其中的类型起别名</strong></p>
</li>
<li><p>define不检查数据类型；typedef会检查数据类型</p>
</li>
</ul>
<h2 id="（53）被free回收的内存是立即返还给操作系统吗？为什么"><a href="#（53）被free回收的内存是立即返还给操作系统吗？为什么" class="headerlink" title="（53）被free回收的内存是立即返还给操作系统吗？为什么"></a>（53）被free回收的内存是立即返还给操作系统吗？为什么</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/YMY_mine/article/details/81180168">https://blog.csdn.net/YMY_mine/article/details/81180168</a></p>
<ul>
<li><p>不是的，被free回收的内存会首先被**&#x3D;&#x3D;ptmalloc内存管理器&#x3D;&#x3D;<strong>使用</strong>双链表<strong>保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就</strong>避免了频繁的系统调用<strong>，占用过多的系统资源。同时ptmalloc也会尝试对</strong>小块内存进行合并<strong>，避免过多的</strong>内存碎片**。</p>
</li>
<li><p>了解</p>
<ul>
<li>ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk</li>
<li>ptmalloc将相似大小的 chunk 用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8&spm=1001.2101.3001.7020">双向链表</a>链接起来，这样的一个链表被称为一个 bin。Ptmalloc 一共维护了 128 个 bin，并使用一个数组来存储这些 bin（如下图所示）。</li>
</ul>
<p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/70.png" alt="img"></p>
</li>
</ul>
<h2 id="（54）引用作为函数参数以及返回值的好处"><a href="#（54）引用作为函数参数以及返回值的好处" class="headerlink" title="（54）引用作为函数参数以及返回值的好处"></a>（54）引用作为函数参数以及返回值的好处</h2><ul>
<li>对比值传递，<strong>引用传参</strong>的好处：<ul>
<li>减少了值传递的时候<strong>生成副本的时间和空间消耗</strong>，提高函数调用和运行的效率</li>
<li>在函数内部可以对此参数进行<strong>修改</strong></li>
</ul>
</li>
<li>引用作为返回值<ul>
<li>用引用作为返回值最大的好处就是在内存中<strong>不产生</strong>返回值的<strong>副本</strong>。</li>
</ul>
</li>
</ul>
<p>但是有以下的限制：</p>
<ul>
<li><strong>不能返回局部变量的引用</strong>。<ul>
<li>因为函数返回以后局部变量就会被销毁</li>
</ul>
</li>
<li>不能<strong>返回函数内部new分配的内存的引用</strong>。<ul>
<li>虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。<strong>例如</strong>，被函数返回的引用<strong>只是作为一个临时变量出现</strong>，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</li>
</ul>
</li>
<li><strong>可以返回类成员的引用，但是最好是const</strong>。<ul>
<li>因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。</li>
</ul>
</li>
</ul>
<h2 id="（55）友元函数和友元类"><a href="#（55）友元函数和友元类" class="headerlink" title="（55）友元函数和友元类"></a>（55）友元函数和友元类</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhuguanhao/p/6286145.html">https://www.cnblogs.com/zhuguanhao/p/6286145.html</a></p>
<p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数<strong>可以访问类中的私有成员和保护成员</strong>。友元的正确使用能提高程序的运行效率，但同时也<strong>破坏了类的封装性和数据的隐藏性</strong>，导致程序可维护性变差。</p>
<p>1）友元函数</p>
<p>有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span></span>;      <span class="comment">//该函数是友元函数的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span> </span>&#123; <span class="comment">//友元函数定义，为了访问类A中的成员</span></span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line">    <span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p>
<p>2）友元类</p>
<p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br>但是另一个类里面也要相应的进行声明</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">C</span>;                         <span class="comment">//这是友元类的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;             <span class="comment">//友元类定义，为了访问类A中的成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span> </span>&#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span> c;</span><br><span class="line">    c.<span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用友元类时注意： </p>
<p>(1) 友元关系<strong>不能被继承</strong>。 </p>
<p>(2) 友元关系是<strong>单向的</strong>，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 </p>
<p>(3) 友元关系<strong>不具有传递性</strong>。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p>
<h2 id="（56）说一下volatile关键字的作用"><a href="#（56）说一下volatile关键字的作用" class="headerlink" title="（56）说一下volatile关键字的作用"></a>（56）说一下volatile关键字的作用</h2><ul>
<li><p>volatile的意思是“脆弱的”，表明<strong>它修饰的变量的值十分容易被改变</strong>，所以编译器就<strong>不会对这个变量进行优化</strong>（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而<strong>提供稳定的访问</strong>。每次读取volatile的变量时，系统<strong>总是会从内存中</strong>读取这个变量，并且将它的值立刻保存。</p>
</li>
<li><p><code>gcc -O main.c -o main</code>：加了 -O 参数，编译器会进行优化</p>
<ul>
<li>使用本项优化，编译器会尝试&#x3D;&#x3D;减小生成代码的尺寸&#x3D;&#x3D;，以及&#x3D;&#x3D;缩短执行时间&#x3D;&#x3D;，但并不执行需要占用大量编译时间的优化。</li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1858501">GCC -O0 -O1 -O2 -O3 四级优化选项</a></li>
</ul>
</li>
</ul>
<h2 id="（57）STL中的sort-算法是用什么实现的，stable-sort-呢——-和十大排序再结合看"><a href="#（57）STL中的sort-算法是用什么实现的，stable-sort-呢——-和十大排序再结合看" class="headerlink" title="（57）STL中的sort()算法是用什么实现的，stable_sort()呢——&#x3D;&#x3D;和十大排序再结合看&#x3D;&#x3D;"></a>（57）STL中的sort()算法是用什么实现的，stable_sort()呢——&#x3D;&#x3D;和十大排序再结合看&#x3D;&#x3D;</h2><ul>
<li>STL中的sort用到了快速排序，但<strong>不仅仅只用了快速排序</strong>，还<strong>结合了插入排序和堆排序</strong>，stable_sort()是归并排序。</li>
<li>区别<ul>
<li>sort是快速排序实现，因此是不稳定的；stable_sort是归并排序实现，因此是&#x3D;&#x3D;稳定的&#x3D;&#x3D;；</li>
<li>对于相等的元素sort可能&#x3D;&#x3D;改变顺序&#x3D;&#x3D;，stable_sort保证排序后相等的&#x3D;&#x3D;元素次序不变&#x3D;&#x3D;；</li>
<li>如果提供了比较函数，sort不要求比较函数的参数被限定为const，而stable_sort则要求&#x3D;&#x3D;参数被限定为const&#x3D;&#x3D;，否则编译不能通过。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36274119">C++一道深坑面试题：STL里sort算法用的是什么排序算法？</a></li>
<li>其他问题：了解即可<ul>
<li>数据量大和数据量小都适合用快速排序吗？<ul>
<li>数据量小不适合用快速排序，因为频繁的<strong>递归调用</strong>会带来额外的负担；</li>
</ul>
</li>
<li>快速排序的时间复杂度不是稳定的nlogn，最坏情况会变成n^2，怎么解决复杂度恶化问题？<ul>
<li>随机选取中间数</li>
</ul>
</li>
<li>快速排序递归实现时，怎么解决递归层次过深的问题？<ul>
<li>控制递归次数，到达次数后改用堆排序（稳定的O(logn)）</li>
</ul>
</li>
<li>递归过深会引发什么问题？<ul>
<li>会导致栈溢出：操作系统规定了大小，Linux默认是8M（ulimit -a显示当前栈大小，ulimit -s修改栈大小），Windows是1M</li>
</ul>
</li>
<li>怎么控制递归深度？如果达到递归深度了还没排完序怎么办？</li>
</ul>
</li>
</ul>
<h2 id="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"><a href="#（58）vector会迭代器失效吗？什么情况下会迭代器失效？" class="headerlink" title="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"></a>（58）vector会迭代器失效吗？什么情况下会迭代器失效？</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html">https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html</a></p>
<ul>
<li>会</li>
<li>当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效</li>
<li>当vector在插入的时候，end迭代器肯定会失效</li>
<li>当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。</li>
</ul>
<h2 id="（59）为什么C-没有实现垃圾回收？"><a href="#（59）为什么C-没有实现垃圾回收？" class="headerlink" title="（59）为什么C++没有实现垃圾回收？"></a>（59）为什么C++没有实现垃圾回收？</h2><ul>
<li>首先，实现一个垃圾回收器会带来<strong>额外的空间和时间开销</strong>。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要<strong>单独开辟一个线程</strong>在空闲的时候进行free操作。  </li>
<li>垃圾回收会使得C++不适合进行<strong>很多底层的操作</strong>。</li>
</ul>
<h2 id="（60）左值引用与右值引用的区别？右值引用的作用"><a href="#（60）左值引用与右值引用的区别？右值引用的作用" class="headerlink" title="（60）左值引用与右值引用的区别？右值引用的作用"></a>（60）左值引用与右值引用的区别？右值引用的作用</h2><ul>
<li><strong>左值引用，就是绑定到左值的引用，通过&amp;来获得左值引用</strong><ul>
<li>左值引用要求右边的值必须能够取地址</li>
<li>可以使用<strong>常左值引用</strong>才能<strong>绑定右值</strong><ul>
<li>使用常左值引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了</li>
</ul>
</li>
</ul>
</li>
<li><strong>右值引用，就是绑定到右值的引用，通过&amp;&amp;来获得右值引用</strong><ul>
<li>只能绑定到一个将要销毁的对象（字面值、临时对象）</li>
</ul>
</li>
<li>右值引用的作用<ul>
<li>主要用于<strong>移动语义</strong>std::move和完美转发std::forword</li>
<li><strong>零拷贝</strong><ul>
<li>移动构造函数和移动赋值构造函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="（61）move和forward完美转发"><a href="#（61）move和forward完美转发" class="headerlink" title="（61）move和forward完美转发"></a>（61）move和forward完美转发</h2><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><ul>
<li><p><code>int &amp;&amp;rr2 = std::move(rr1);</code></p>
</li>
<li><p><code>move</code>告诉编译器，我们有一个左值，但我希望像右值一样处理它。</p>
</li>
<li><p>调用<code>move</code>意味着：除了对<code>rr1</code>赋值或者销毁它外，我们将不再使用它。</p>
</li>
<li><p>标准库<code>move</code>函数是使用右值引用的模板的一个很好的例子。</p>
</li>
<li><p>从一个左值<code>static_cast</code>到一个右值引用是允许的。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward"></a>完美转发 std::forward</h3><ul>
<li><p>使用一个名为<code>forward</code>的新标准库设施来传递参数，它能够保持**&#x3D;&#x3D;原始实参的类型&#x3D;&#x3D;**。（如果是右值，让其保持右值，如果是左值，让其保持左值）</p>
</li>
<li><p>定义在头文件<code>utility</code>中。</p>
</li>
<li><p>与move不同<strong>必须通过显式模板实参</strong>来调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::forward&lt;Type&gt;(arg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="built_in">intermediary</span>(Type &amp;&amp;arg) &#123;</span><br><span class="line">	<span class="built_in">finalFcn</span>(std::forward&lt;Type&gt;(arg));</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>std::forward&lt;Type&gt;返回的是右值引用</p>
<ul>
<li>如果实参是一个右值，则Type是一个普通（非引用）类型，forward&lt;Type&gt;将返回Type&amp;&amp;（<strong>右值引用</strong>）</li>
<li>如果实参是一个左值，则通过**&#x3D;&#x3D;引用折叠&#x3D;&#x3D;<strong>，Type本身是一个左值引用类型，返回类型是一个指向左值引用类型的</strong>右值引用**</li>
</ul>
</li>
</ul>
<ul>
<li>与std::move相同，对std::forward不适用using声明是一个好主意。</li>
</ul>
<h2 id="（62）在-operator-中处理“自我赋值“"><a href="#（62）在-operator-中处理“自我赋值“" class="headerlink" title="（62）在 operator&#x3D; 中处理“自我赋值“"></a>（62）在 operator&#x3D; 中处理“自我赋值“</h2><blockquote>
<p> 确定任何一个函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确</p>
</blockquote>
<ul>
<li><p>确保当对象自我赋值时operator&#x3D; 有良好的行为。其中技术包括</p>
<ul>
<li>比较”来源对象“和”目标对象“的地址</li>
<li>精心周到的语句顺序</li>
<li>copy and swap</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//比较”来源对象“和”目标对象“的地址</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> = &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;		<span class="comment">//证同测试（identity test），如果是自我赋值就不做任何事</span></span><br><span class="line">	<span class="keyword">delete</span> pb;</span><br><span class="line">	pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//精心周到的语句顺序</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Bitmap* pOring = pb;		<span class="comment">//记住原先的pb</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);	<span class="comment">//令pb指向 *pb的一个复件（副本）</span></span><br><span class="line">    <span class="keyword">delete</span> pOring;				<span class="comment">//删除原先的pb</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//copy and swap</span></span><br><span class="line"><span class="comment">//————1————</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>;		<span class="comment">//交换*this和rhs的数据</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp;rhs) &#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);			<span class="comment">//temp离开作用域后自动释放了原来的pb</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//————2————</span></span><br><span class="line">Widget&amp; Widget::oprator=(Widget rhs) &#123;	<span class="comment">//rhs是一份拷贝，相当于temp</span></span><br><span class="line">	<span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="（63）C-的deque的底层实现"><a href="#（63）C-的deque的底层实现" class="headerlink" title="（63）C++的deque的底层实现"></a>（63）C++的deque的底层实现</h2><ul>
<li>分段存储，一段的内空间是连续的，每段又分布在不同的地方，map表里面记录指向段的指针</li>
<li>deque 容器的分段存储结构，提高了在序列两端添加或删除元素的效率</li>
<li>内部为了遍历，有4个指针<ul>
<li>cur：指向当前正在遍历的元素；</li>
<li>first：指向当前连续空间的首地址；</li>
<li>last：指向当前连续空间的末尾地址；</li>
<li>node：它是一个二级指针，用于指向 map 数组中存储的指向当前连续空间的指针。</li>
</ul>
</li>
<li>维护 start、finish 这 2 个 deque 迭代器<ul>
<li>start 迭代器记录着 map 数组中首个连续空间的信息，finish 迭代器记录着 map 数组中最后一个连续空间的信息。另外需要注意的是，和普通 deque 迭代器不同，start 迭代器中的 cur 指针指向的是连续空间中首个元素；而 finish 迭代器中的 cur 指针指向的是连续空间最后一个元素的下一个位置。</li>
</ul>
</li>
</ul>
<h2 id="（64）为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"><a href="#（64）为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？" class="headerlink" title="（64）为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？"></a>（64）为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</h2><ul>
<li>从<strong>软件设计</strong>的角度看，<strong>栈代表了处理逻辑，而堆代表了数据</strong>。**这样分开，使得处理&#x3D;&#x3D;逻辑更为清晰&#x3D;&#x3D;**。<ul>
<li>分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</li>
</ul>
</li>
<li>堆与栈的分离，使得<strong>堆中的内容可以被多个栈&#x3D;&#x3D;共享&#x3D;&#x3D;<strong>（也可以理解为</strong>多个线程访问同一个对象</strong>），节省空间，不过要注意线程安全的问题。<ul>
<li>这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</li>
</ul>
</li>
<li>因为栈<strong>在运行的时侯</strong>需要保存系统运行的上下文，进行地址段的划分，需要占用比较多空间，而栈的空间又是向上增长的，空间有限。而堆不同，堆中的对象是可以<strong>根据需要&#x3D;&#x3D;动态增长&#x3D;&#x3D;的</strong>，相应栈中只需记录堆中的一个地址即可</li>
</ul>
<img src="面经整理发布版.assets/v2-c9c793adc29afdb5c42bd2f5f685c5c3_1440w.webp" alt="img" style="zoom:50%;" />



<h2 id="（65）指针引用-二级指针传递"><a href="#（65）指针引用-二级指针传递" class="headerlink" title="（65）指针引用 &amp;&amp; 二级指针传递"></a>（65）指针引用 &amp;&amp; 二级指针传递</h2><ul>
<li>找出其中的问题：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMemory</span><span class="params">( <span class="type">char</span> *p )</span> </span>&#123;</span><br><span class="line">    p = (<span class="type">char</span> *) <span class="built_in">malloc</span>( <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">GetMemory</span>( str );</span><br><span class="line">    <span class="built_in">strcpy</span>( str, <span class="string">&quot;hello world&quot;</span> );</span><br><span class="line">    <span class="built_in">printf</span>( str );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>第一是getMemory中malloc的内存没有被free掉，会有内存泄露的问题。 </li>
<li>第二，整个代码的目的是str指针分配内存，然后为其复制helloworld并输出，但是最后str的值仍为NULL，输出时会报错，因为getMemory函数并没有实现为str分配空间的功能，在getMemory中传入的是一级指针，只是把str的值传进去了，没有传入str的地址，在函数中malloc后就会把一个分配好的新地址赋值给p，此时p的值就不是str的值了，所以函数结束后str的值仍为NULL。<strong>要实现为str分配地址的功能，传入的应该是二级指针或是指针的引用</strong>，不能只传入一级指针</li>
</ul>
<h2 id="（66）将文件间的编译依存关系降到最低"><a href="#（66）将文件间的编译依存关系降到最低" class="headerlink" title="（66）将文件间的编译依存关系降到最低"></a>（66）将文件间的编译依存关系降到最低</h2><ul>
<li><p><strong>解耦</strong>——编译的时候有时候只需要一个声明而不必把定义编译进去</p>
</li>
<li><p>支持 “编译依存性最小化” 的一般构想是：<strong>相依于声明式</strong>，<strong>不要相依于定义式</strong>。基于此构想的两个手段是 Handle classes 和 Interface classes。</p>
</li>
<li><p>程序库头文件应该以 “完全且仅有声明式”（full and declaration-only forms）的形式存在。这种做法不论是否涉及 templates 都适用</p>
<ul>
<li><strong>Handles classes</strong>：将&#x3D;&#x3D;声明和定义分类编写&#x3D;&#x3D;，声明类和定义类有同名成员函数，声明类通过成员智能指针指向实现类，声明类的成员函数通过这个指针调用定义式中的函数</li>
<li><strong>Interface classes</strong>：父类中通过虚函数 “声明” ，子类继承父类重写虚函数提供 “定义”，通过 factory 函数返回一个指向子类的父类智能指针</li>
<li>将声明与定义分离，可以**&#x3D;&#x3D;将 “非真正必要之类型定义” 与 客户端之间的编译依存关系去除掉&#x3D;&#x3D;**</li>
</ul>
</li>
</ul>
<h2 id="（67）异常安全"><a href="#（67）异常安全" class="headerlink" title="（67）异常安全"></a>（67）异常安全</h2><ul>
<li>异常安全函数（Exception-safe functions）即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型<ul>
<li><strong>基本型</strong>：如果异常被抛出，程序内的任何事务仍然保持在有效的状态下（但是不能预料现实状态，<strong>程序可能处于任何状态</strong>——只要这个状态是合法的）</li>
<li><strong>强烈保证型</strong>：如果异常被抛出，程序状态不改变；如果函数成功，则完全成功，如果函数失败，程序会回复到 “调用函数之前” 的状态</li>
<li><strong>不抛掷（nothrow）保证</strong>：承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。作用于<strong>内置类型</strong>（例如 ints，指针等等）身上的所有操作都提供 nothrow 保证。这是异常安全码中一个<strong>必不可少的关键基础材料</strong><ul>
<li><strong>在函数名后面加 throw()</strong> 括号内为空</li>
</ul>
</li>
</ul>
</li>
<li>“强烈保证” 往往能够以 copy-and-swap 实现出来，但 “强烈保证” 并非对所有函数都可实现或具备现实意义</li>
<li>函数提供的 “异常安全保证” 通常最高只等于其所调用之各个函数的 “异常安全保证” 最低者</li>
</ul>
<h1 id="2-计网相关"><a href="#2-计网相关" class="headerlink" title="2. 计网相关"></a>2. 计网相关</h1><h2 id="（1）在浏览器中输入URL后执行的全部过程（如www-baidu-com）-over"><a href="#（1）在浏览器中输入URL后执行的全部过程（如www-baidu-com）-over" class="headerlink" title="（1）在浏览器中输入URL后执行的全部过程（如www.baidu.com）==over=="></a>（1）在浏览器中输入URL后执行的全部过程（如<a target="_blank" rel="noopener" href="http://www.baidu.com)==over==/">www.baidu.com）==over==</a></h2><ul>
<li><p>首先浏览器会对URL来进行解析，生成&#x3D;&#x3D;请求报文&#x3D;&#x3D;</p>
</li>
<li><p>然后再通过&#x3D;&#x3D;域名解析DNS&#x3D;&#x3D;来获得目的地的IP地址</p>
<ul>
<li>迭代查询：先看本地浏览器缓存，然后是host文件，本地DNS服务器，根域名服务器，顶级、权限、本地</li>
</ul>
</li>
<li><p>然后进入运输层，封装TCP头部（如果http请求消息超过MSS，要进行分片，并标上序号）</p>
</li>
<li><p>然后到网络层封装IP首部（如果报文长度ip + tcp + 消息体 超过MTU：1500字节）</p>
</li>
<li><p>然后到数据链路层封装MAC地址（需要查看ARP缓存，没有就ARP广播查询）</p>
</li>
<li><p>最后通过网卡将数字信息转换为电信号（网卡驱动程序会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>）</p>
</li>
<li><p>中间通过交换机（<strong>二层网络设备</strong>，交换机根据MAC地址表查询有没有目标MAC地址，没找到就发送给除了源端口外的所有端口）</p>
</li>
<li><p>最后到网关（如果是发送给自己的，放入接收缓冲区，接收完后去掉MAC地址，根据MAC地址后的IP地址进行转发网络包），通过将条目的子网掩码和目标IP地址进行&amp;运算，找到最匹配的，然后从这个网关（下一跳路由器）转发</p>
</li>
<li><p>然后再通过ARP寻到下一跳路由器的MAC地址，然后通过交换机转发</p>
</li>
<li><p>最后如果在路由器中的匹配的网关为空，说明到达目标地址。</p>
</li>
<li><p><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</p>
</li>
<li><p><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</p>
</li>
</ul>
<h2 id="（2）HTTP"><a href="#（2）HTTP" class="headerlink" title="（2）HTTP"></a>（2）HTTP</h2><h3 id="（1）HTTP基本概念"><a href="#（1）HTTP基本概念" class="headerlink" title="（1）HTTP基本概念"></a>（1）HTTP基本概念</h3><h4 id="（1）能否详细解释「超文本传输协议」？"><a href="#（1）能否详细解释「超文本传输协议」？" class="headerlink" title="（1）能否详细解释「超文本传输协议」？"></a>（1）能否详细解释「超文本传输协议」？</h4><ul>
<li>HTTP 是一个在计算机世界里专门在<strong>「两点」</strong>之间<strong>「传输」</strong>文字、图片、音频、视频等<strong>「超文本」</strong>数据的<strong>「约定和规范」</strong>。</li>
</ul>
<h4 id="（2）那「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？"><a href="#（2）那「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？" class="headerlink" title="（2）那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？"></a>（2）那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？</h4><ul>
<li>这种说法是<strong>不正确</strong>的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用<strong>两点之间</strong>的描述会更准确</li>
</ul>
<h4 id="（3）http的状态码-403-201等等是什么意思"><a href="#（3）http的状态码-403-201等等是什么意思" class="headerlink" title="（3）http的状态码 403 201等等是什么意思"></a>（3）http的状态码 403 201等等是什么意思</h4><ul>
<li>记住5类就好</li>
</ul>
<blockquote>
<p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p>
<p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul>
<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul>
<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
</blockquote>
<h4 id="（4）HTTP-常见字段有哪些？"><a href="#（4）HTTP-常见字段有哪些？" class="headerlink" title="（4）HTTP 常见字段有哪些？"></a>（4）HTTP 常见字段有哪些？</h4><ul>
<li><p><code>Host: www.A.com</code></p>
<ul>
<li>客户端发送请求时，用来指定服务器的域名。</li>
<li>有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</li>
</ul>
</li>
<li><p><code>Content-Length: 1000</code></p>
<ul>
<li><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong></li>
</ul>
</li>
<li><p><code>Connection: Keep-Alive</code></p>
<ul>
<li>开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</li>
</ul>
</li>
<li><p><strong>编码</strong></p>
<ul>
<li><p><code>Content-Type: text/html; Charset=utf-8</code></p>
<ul>
<li>上面的类型表明，发送的是网页，而且编码是UTF-8。</li>
</ul>
</li>
<li><p><code>Accept: */*</code></p>
<ul>
<li>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</li>
<li>上面代码中，客户端声明自己可以接受任何格式的数据。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>压缩</strong></p>
<ul>
<li><p><code>Content-Encoding: gzip</code></p>
<ul>
<li>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</li>
</ul>
</li>
<li><p><code>Accept-Encoding: gzip, deflate</code></p>
<ul>
<li>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（2）GET-与-POST"><a href="#（2）GET-与-POST" class="headerlink" title="（2）GET 与 POST"></a>（2）GET 与 POST</h3><h4 id="（1）-http的请求方法有哪些？get和post的区别。"><a href="#（1）-http的请求方法有哪些？get和post的区别。" class="headerlink" title="（1） http的请求方法有哪些？get和post的区别。"></a>（1） http的请求方法有哪些？get和post的区别。</h4><ul>
<li>HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）</li>
</ul>
<p>get和post的区别：</p>
<ul>
<li><p>get 是安全和幂等的，是只读的操作，不会修改服务器的资源，多次请求结果相同，可以做缓存，也可以保存为书签。</p>
</li>
<li><p>post 是不安全也是不幂等的，它会修改服务器上的资源，多次请求会创建多个资源，浏览器一般不会缓存，不可以保存为书签。</p>
</li>
<li><p>位置</p>
<ul>
<li>get把请求附在 <code>url</code> 上，而post把参数附在 <code>http包</code>的包体中</li>
</ul>
</li>
<li><p>大小</p>
<ul>
<li>浏览器和服务器一般对get方法所提交的 url长度 有限制，一般是&#x3D;&#x3D;1k或者2k&#x3D;&#x3D;，而对post方法所传输的参数大小限制为&#x3D;&#x3D;80k到4M&#x3D;&#x3D;不等</li>
</ul>
</li>
<li><p>编码</p>
<ul>
<li>post可以传输&#x3D;&#x3D;<strong>二进制编码</strong>&#x3D;&#x3D;的信息，get的参数一般**&#x3D;&#x3D;只支持ASCII&#x3D;&#x3D;**</li>
</ul>
</li>
<li><p>了解</p>
</li>
<li><p><strong>GET 的语义是从服务器获取指定的资源</strong></p>
<ul>
<li>用URL传输数据</li>
</ul>
</li>
<li><p><strong>POST 的语义是根据&#x3D;&#x3D;请求负荷&#x3D;&#x3D;（报文body）对指定的资源做出处理</strong></p>
<ul>
<li>比如在论坛进行留言浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。</li>
<li>POST用body传输数据</li>
</ul>
</li>
</ul>
<p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/12-Get%E8%AF%B7%E6%B1%82.png" alt="GET 请求"></p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/13-Post%E8%AF%B7%E6%B1%82.png" alt="POST 请求"></p>
<h4 id="（2）GET-和-POST-方法都是安全和幂等的吗？"><a href="#（2）GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="（2）GET 和 POST 方法都是安全和幂等的吗？"></a>（2）GET 和 POST 方法都是安全和幂等的吗？</h4><ul>
<li><p>先说明下安全和幂等的概念：</p>
<ul>
<li>在 HTTP 协议里，所谓的<strong>「安全」</strong>是指请求方法不会<strong>「破坏」</strong>服务器上的资源。</li>
<li>所谓的「幂等」，意思是<strong>多次执行相同</strong>的操作，结果都是<strong>「相同」</strong>的。</li>
</ul>
</li>
<li><p>如果从 RFC 规范定义的语义来看：</p>
<ul>
<li><strong>GET 方法就是安全且幂等的</strong>，因为它是&#x3D;&#x3D;「只读」&#x3D;&#x3D;操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li>
<li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li>
</ul>
</li>
</ul>
<h3 id="（3）HTTP-缓存技术"><a href="#（3）HTTP-缓存技术" class="headerlink" title="（3）HTTP 缓存技术"></a>（3）HTTP 缓存技术</h3><h4 id="（1）HTTP-缓存有哪些实现方式？"><a href="#（1）HTTP-缓存有哪些实现方式？" class="headerlink" title="（1）HTTP 缓存有哪些实现方式？"></a>（1）HTTP 缓存有哪些实现方式？</h4><ul>
<li><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p>
</li>
<li><p>&#x3D;&#x3D;强制缓存&#x3D;&#x3D;指的是只要浏览器判断缓存&#x3D;&#x3D;没有过期&#x3D;&#x3D;（有一个服务器过期时间<code>Cache-Control</code>），则直接使用浏览器的本地缓存</p>
</li>
<li><p>当时间过期后，通过&#x3D;&#x3D;协商缓存&#x3D;&#x3D;：就是在与服务端协商之后，通过协商结果来判断&#x3D;&#x3D;是否使用本地缓存&#x3D;&#x3D;，然后更新过期时间<code>Cache-Control</code></p>
<ul>
<li>先<code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段</li>
<li>后<code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段<ul>
<li><code>Etag</code> 的优先级更高</li>
<li><code>Last-Modified</code> 容易被修改</li>
<li>时间粒度，秒，纳秒</li>
<li>有些服务器保存时间不准确</li>
</ul>
</li>
</ul>
</li>
<li><p>了解</p>
<ul>
<li>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP&#x2F;1.1 的性能肯定肉眼可见的提升。</li>
<li>所以，避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。</li>
</ul>
</li>
</ul>
<h4 id="（2）什么是强制缓存"><a href="#（2）什么是强制缓存" class="headerlink" title="（2）什么是强制缓存"></a>（2）什么是强制缓存</h4><ul>
<li><p>强制缓存指的是只要浏览器判断缓存&#x3D;&#x3D;没有过期&#x3D;&#x3D;（有一个服务器过期时间<code>Cache-Control</code>），则直接使用浏览器的本地缓存</p>
</li>
<li><p>当时间过期后，通过&#x3D;&#x3D;协商缓存&#x3D;&#x3D;：就是在与服务端协商之后，通过协商结果来判断&#x3D;&#x3D;是否使用本地缓存&#x3D;&#x3D;，然后更新过期时间<code>Cache-Control</code></p>
<ul>
<li>先<code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段</li>
<li>后<code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段<ul>
<li><code>Etag</code> 的优先级更高</li>
<li><code>Last-Modified</code> 容易被修改</li>
<li>时间粒度，秒，纳秒</li>
<li>有些服务器保存时间不准确</li>
</ul>
</li>
</ul>
</li>
<li><p>了解</p>
</li>
</ul>
<p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 &#x3D;&#x3D;from disk cache&#x3D;&#x3D;，就是使用了强制缓存。</p>
<p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/1cb6bc37597e4af8adfef412bfc57a42.png" alt="img"></p>
<p>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p>
<p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中&#x3D;&#x3D;设置了过期时间大小&#x3D;&#x3D;；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>
</ul>
<h4 id="（3）什么是协商缓存？"><a href="#（3）什么是协商缓存？" class="headerlink" title="（3）什么是协商缓存？"></a>（3）什么是协商缓存？</h4><ul>
<li><strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</li>
<li><strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</li>
</ul>
<p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p>
<p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E7%BC%93%E5%AD%98etag.png" alt="img"></p>
<p>上图就是一个协商缓存的过程，所以<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p>
<p>协商缓存可以基于两种头部来实现。</p>
<p>&#x3D;&#x3D;第一种&#x3D;&#x3D;：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p>
<ul>
<li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li>
<li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
<p>&#x3D;&#x3D;第二种&#x3D;&#x3D;：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p>
<ul>
<li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li>
<li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p>
<p>如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，<strong>这时 Etag 的优先级更高</strong>，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。</p>
<p><strong>为什么 ETag 的优先级更高？</strong>这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p>
<ol>
<li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li>
<li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li>
<li>有些服务器不能精确获取文件的最后修改时间。</li>
</ol>
<p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>
<p>下图是强制缓存和协商缓存的工作流程：</p>
<p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/http%E7%BC%93%E5%AD%98.png" alt="img"></p>
<p>当使用 ETag 字段实现的协商缓存的过程：</p>
<ul>
<li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p>
</li>
<li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p>
<ul>
<li>如果没有过期，则直接使用本地缓存；</li>
<li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li>
</ul>
</li>
<li><p>服务器再次收到请求后，</p>
<p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</p>
<p>：</p>
<ul>
<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p>
</li>
</ul>
<h3 id="（4）HTTP-特性"><a href="#（4）HTTP-特性" class="headerlink" title="（4）HTTP 特性"></a>（4）HTTP 特性</h3><h4 id="（1）HTTP-1-1-的优点有哪些？"><a href="#（1）HTTP-1-1-的优点有哪些？" class="headerlink" title="（1）HTTP&#x2F;1.1 的优点有哪些？"></a>（1）HTTP&#x2F;1.1 的优点有哪些？</h4><ul>
<li>简单<ul>
<li>格式简单，header + body ，头部信息简单 key-value</li>
</ul>
</li>
<li>灵活和易于扩展<ul>
<li>请求方法、URI&#x2F;URL、状态码、头字段都允许<strong>自定义和扩充</strong>。</li>
<li>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>，比如：<ul>
<li>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</li>
<li>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用了 UDP 协议。</li>
</ul>
</li>
</ul>
</li>
<li>应用广泛和跨平台</li>
</ul>
<h4 id="（2）HTTP-1-1-的缺点有哪些？"><a href="#（2）HTTP-1-1-的缺点有哪些？" class="headerlink" title="（2）HTTP&#x2F;1.1 的缺点有哪些？"></a>（2）HTTP&#x2F;1.1 的缺点有哪些？</h4><ul>
<li><p>&#x3D;&#x3D;不安全&#x3D;&#x3D;</p>
<ul>
<li>不验证通信方的身份，&#x3D;&#x3D;冒充&#x3D;&#x3D;<ul>
<li>访问到假淘宝</li>
</ul>
</li>
<li>通信使用明文（不加密）&#x3D;&#x3D;窃听&#x3D;&#x3D;<ul>
<li>信息泄漏</li>
</ul>
</li>
<li>无法证明报文的完整性，&#x3D;&#x3D;篡改&#x3D;&#x3D;<ul>
<li>植入广告</li>
</ul>
</li>
</ul>
</li>
<li><p>无状态双刃剑</p>
<ul>
<li>无状态的<strong>好处</strong>，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</li>
<li>无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在完成&#x3D;&#x3D;有关联性的操作&#x3D;&#x3D;时会非常麻烦。<ul>
<li>解决方案使用 cookie，可以用于标识用户</li>
</ul>
</li>
</ul>
</li>
<li><p>明文传输双刃剑</p>
<ul>
<li>明文意味着在传输过程中的信息，是可方便阅读的，例如Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。</li>
<li>信息容易泄漏</li>
</ul>
</li>
</ul>
<h4 id="（3）HTTP-1-1-的性能如何？"><a href="#（3）HTTP-1-1-的性能如何？" class="headerlink" title="（3）HTTP&#x2F;1.1 的性能如何？"></a>（3）HTTP&#x2F;1.1 的性能如何？</h4><ul>
<li>长连接</li>
<li>管道网络传输：默认不开启<ul>
<li>客户端发送请求不会被阻塞</li>
</ul>
</li>
<li>但服务端需要顺序响应，如果一个请求没有处理完毕，会阻塞接下来收到的请求</li>
</ul>
<h3 id="（5）HTTP-与-HTTPS"><a href="#（5）HTTP-与-HTTPS" class="headerlink" title="（5）HTTP 与 HTTPS"></a>（5）HTTP 与 HTTPS</h3><h4 id="（1）HTTP-与-HTTPS-有哪些区别？"><a href="#（1）HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="（1）HTTP 与 HTTPS 有哪些区别？"></a>（1）HTTP 与 HTTPS 有哪些区别？</h4><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 &#x3D;&#x3D;SSL&#x2F;TLS 安全协议&#x3D;&#x3D;，使得报文能够加密传输。</li>
<li>HTTP &#x3D;&#x3D;连接建立&#x3D;&#x3D;相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的&#x3D;&#x3D;默认端口&#x3D;&#x3D;不一样，HTTP 默认端口号是 <strong>80</strong>，HTTPS 默认端口号是 <strong>443</strong>。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请&#x3D;&#x3D;数字证书&#x3D;&#x3D;，来保证服务器的身份是可信的。</li>
</ul>
<h4 id="（2）HTTPS-解决了-HTTP-的哪些问题？"><a href="#（2）HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="（2）HTTPS 解决了 HTTP 的哪些问题？"></a>（2）HTTPS 解决了 HTTP 的哪些问题？</h4><ul>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了&#x3D;&#x3D;冒充&#x3D;&#x3D;的风险。</li>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了&#x3D;&#x3D;窃听&#x3D;&#x3D;的风险。</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的指纹，指纹用于校验数据的完整性，解决了&#x3D;&#x3D;篡改&#x3D;&#x3D;的风险。</li>
</ul>
<ul>
<li><strong>混合加密</strong></li>
</ul>
<p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/image-20230609113842344.png" alt="image-20230609113842344"></p>
<ul>
<li>公钥是公开的，需要向CA机构认证，私钥是私有的，不被公开</li>
<li>单向散列函数，逆向计算几乎不可能</li>
<li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<ul>
<li>使用非对称加密加密了传输内容：<ul>
<li>在上面的基础上，<strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li>
</ul>
</li>
<li>一般我们不会用非对称加密来&#x3D;&#x3D;加密实际的传输内容&#x3D;&#x3D;，因为非对称加密的计算比较耗费性能的。</li>
</ul>
</li>
</ul>
<img src="面经整理发布版.assets/image-20230609115338980.png" alt="image-20230609115338980" style="zoom: 25%;" />



<h4 id="（3）HTTPS-SSL-TSL传输层是如何建立连接的？其间交互了什么"><a href="#（3）HTTPS-SSL-TSL传输层是如何建立连接的？其间交互了什么" class="headerlink" title="（3）HTTPS SSL\TSL传输层是如何建立连接的？其间交互了什么"></a>（3）HTTPS SSL\TSL传输层是如何建立连接的？其间交互了什么</h4><ul>
<li>客户端向服务器索要并验证服务器的公钥。<ul>
<li>客户端向服务器发送TSL协议版本，密码套件列表，客户端生成的随机数</li>
<li>服务端先确认TSL协议版本和密码套件，版本支持的话会返回服务器生成的随机数和数字证书</li>
</ul>
</li>
<li>双方协商生产「会话秘钥」。<ul>
<li>客户端用服务器给的数字证书里面公钥加密一个随机数 pre-master，以及对之前的所有信息做一个摘要（单向散列函数），发送给服务器进行检验</li>
<li>最后双方都有 服务器的随机数，客户端的随机数和pre-master，用协商好的加密算法对三个随机数进行加密得到会话密钥</li>
</ul>
</li>
<li>后续双方采用「会话秘钥」进行加密通信。</li>
</ul>
<h4 id="（4）-HTTPS-的应用数据是如何保证完整性的？"><a href="#（4）-HTTPS-的应用数据是如何保证完整性的？" class="headerlink" title="（4） HTTPS 的应用数据是如何保证完整性的？"></a>（4） HTTPS 的应用数据是如何保证完整性的？</h4><img src="面经整理发布版.assets/记录协议.png" alt="img" style="zoom:25%;" />

<p>具体过程如下：</p>
<ul>
<li>首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</li>
<li>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li>
<li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li>
<li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li>
</ul>
<h4 id="（5）HTTPS-一定安全可靠吗？"><a href="#（5）HTTPS-一定安全可靠吗？" class="headerlink" title="（5）HTTPS 一定安全可靠吗？"></a>（5）HTTPS 一定安全可靠吗？</h4><ul>
<li><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</li>
</ul>
<h4 id="（6）为什么抓包工具能截取-HTTPS-数据？"><a href="#（6）为什么抓包工具能截取-HTTPS-数据？" class="headerlink" title="（6）为什么抓包工具能截取 HTTPS 数据？"></a>（6）为什么抓包工具能截取 HTTPS 数据？</h4><ul>
<li><p>中间人要拿到私钥只能通过如下方式：</p>
<ul>
<li>去网站服务端拿到私钥；</li>
<li>去CA处拿域名签发私钥；</li>
<li>自己签发证书，切要被浏览器信任；</li>
</ul>
</li>
<li><p>不用解释，抓包工具只能使用第三种方式取得中间人的身份。</p>
</li>
<li><p>使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装&#x3D;&#x3D;Fiddler 的根证书&#x3D;&#x3D;，这里实际上起认证中心（CA）的作用。</p>
</li>
<li><p>抓包工具能够抓包的关键是&#x3D;&#x3D;客户端会往系统受信任的根证书列表中导入抓包工具生成的证书&#x3D;&#x3D;，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。</p>
</li>
</ul>
<h4 id="（7）如何避免被中间人抓取数据？"><a href="#（7）如何避免被中间人抓取数据？" class="headerlink" title="（7）如何避免被中间人抓取数据？"></a>（7）如何避免被中间人抓取数据？</h4><ul>
<li>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。</li>
<li>还可以通过 <strong>HTTPS 双向认证</strong>来避免这种问题<ul>
<li>用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份</li>
</ul>
</li>
</ul>
<h3 id="（6）HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#（6）HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="（6）HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>（6）HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h3><h4 id="（1）HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#（1）HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="（1）HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>（1）HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h4><ul>
<li><p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：</p>
<ul>
<li><p>使用**&#x3D;&#x3D;长连接&#x3D;&#x3D;**改善了短连接的性能消耗</p>
</li>
<li><p><strong>节约时间</strong>：支持**&#x3D;&#x3D;管道传输&#x3D;&#x3D;**，发送（客户）端不用阻塞发送，但需要接收（服务）端阻塞等待</p>
</li>
</ul>
</li>
<li><p>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p>
<ul>
<li>&#x3D;&#x3D;<strong>头部</strong>&#x3D;&#x3D;<strong>未压缩</strong>，如果头部太长导致发送数据时间变长</li>
<li>头部<strong>冗余</strong>，有多个相同头部数据包出现</li>
<li>**队头&#x3D;&#x3D;阻塞&#x3D;&#x3D;**：服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据</li>
<li>请求只能从客户端开始，服务器只能**&#x3D;&#x3D;被动响应&#x3D;&#x3D;**。</li>
<li>没有请求优先级控制；</li>
</ul>
</li>
</ul>
<h4 id="（2）HTTP-2-做了什么优化？"><a href="#（2）HTTP-2-做了什么优化？" class="headerlink" title="（2）HTTP&#x2F;2 做了什么优化？"></a>（2）HTTP&#x2F;2 做了什么优化？</h4><img src="面经整理发布版.assets/25-HTTP2.jpeg" alt="HTT/1 ~ HTTP/2" style="zoom:50%;" />

<ul>
<li><p>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p>
<ul>
<li><p>头部压缩</p>
<ul>
<li><p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p>
<p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p>
</li>
</ul>
</li>
<li><p>二进制帧</p>
<ul>
<li><p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p>
<p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.png" alt="HTTP/1 与 HTTP/2 "></p>
</li>
</ul>
</li>
<li><p>并发传输</p>
</li>
<li><p>服务器主动推送资源</p>
</li>
</ul>
</li>
</ul>
<h3 id="（）-http协议与TCP的区别与联系"><a href="#（）-http协议与TCP的区别与联系" class="headerlink" title="（） http协议与TCP的区别与联系"></a>（） http协议与TCP的区别与联系</h3><p>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</p>
<p>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。<br>建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。</p>
<h3 id="（）-http-1-0和http-1-1的区别"><a href="#（）-http-1-0和http-1-1的区别" class="headerlink" title="（） http&#x2F;1.0和http&#x2F;1.1的区别"></a>（） http&#x2F;1.0和http&#x2F;1.1的区别</h3><ul>
<li>HTTP 协议老的标准是 HTTP&#x2F;1.0 ，目前最通用的标准是 HTTP&#x2F;1.1 。</li>
<li>HTTP1.0 只保持&#x3D;&#x3D;短连接&#x3D;&#x3D;，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http&#x2F;1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive</li>
<li>HTTP 1.1 支持&#x3D;&#x3D;长连接&#x3D;&#x3D;，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</li>
</ul>
<h2 id="（2）-建立TCP服务器的各个系统调用-over"><a href="#（2）-建立TCP服务器的各个系统调用-over" class="headerlink" title="（2） 建立TCP服务器的各个系统调用&#x3D;&#x3D;over&#x3D;&#x3D;"></a>（2） 建立TCP服务器的各个系统调用&#x3D;&#x3D;over&#x3D;&#x3D;</h2><p>建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37964547/article/details/81429627">建立TCP 服务器的系统调用</a></p>
<h2 id="（3）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"><a href="#（3）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？" class="headerlink" title="（3） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"></a>（3） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">socket()    创建套接字   </span><br><span class="line">bind()      绑定本机端口    </span><br><span class="line">connect()   建立连接     （TCP三次握手在调用这个函数时进行）</span><br><span class="line">listen()    监听端口</span><br><span class="line">accept()    接受连接</span><br><span class="line">recv(), read(), recvfrom()  数据接收</span><br><span class="line">send(), write(), sendto()   数据发送</span><br><span class="line">close(), shutdown() 关闭套接字</span><br></pre></td></tr></table></figure>

<p>使用close()时，只有当套接字的<strong>引用计数为0的时候才会终止连接</strong>，而用**shutdown()**就可以直接关闭连接</p>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/junjun150013652/article/details/37994907">网络编程Socket之TCP之close&#x2F;shutdown详解</a></p>
<p>TCP连接与断开详解： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/felixzh/p/8359066.html">https://www.cnblogs.com/felixzh/p/8359066.html</a></p>
<h2 id="（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP"><a href="#（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP" class="headerlink" title="（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP"></a>（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP</h2><ul>
<li><p>RIP“路由信息协议(Route Information Protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。RIP是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。</p>
</li>
<li><p>OSPF：详见：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41341540">https://zhuanlan.zhihu.com/p/41341540</a></p>
</li>
</ul>
<h2 id="（4）-UDP如何实现可靠传输"><a href="#（4）-UDP如何实现可靠传输" class="headerlink" title="（4） UDP如何实现可靠传输"></a>（4） UDP如何实现可靠传输</h2><p>因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，<strong>只能从应用层实现</strong>。需要实现seq&#x2F;ack机制，重传机制和窗口确认机制。</p>
<p>就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</p>
<p>作者：姚冬<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/283995548/answer/661809748">https://www.zhihu.com/question/283995548/answer/661809748</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="（5）-TCP和UDP的区别"><a href="#（5）-TCP和UDP的区别" class="headerlink" title="（5） TCP和UDP的区别"></a>（5） TCP和UDP的区别</h2><ul>
<li>TCP是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ACK对收发的数据进行正确性检验。而UDP是无连接的协议，不管对方有没有收到或者收到的数据是否正确。</li>
<li>TCP提供<strong>流量控制</strong>和<strong>拥塞控制</strong>，而UDP没有。</li>
<li>TCP对系统资源的要求高于UDP，所以速度也比UDP慢。</li>
<li>TCP数据包是没有边界的，<strong>会出现粘包的问题</strong>，UDP包是独立的，不会出现粘包问题。</li>
<li>所以在应用方面，如果强调数据的完整性和正确性用TCP，当要求性能和速度的时候，使用UDP更加合适。</li>
</ul>
<p>注：单凭TCP是不能保证完整性的，要是有黑客伪造TCP包，是无法识别的。</p>
<h2 id="（6）-TCP和UDP相关的协议与端口号"><a href="#（6）-TCP和UDP相关的协议与端口号" class="headerlink" title="（6） TCP和UDP相关的协议与端口号"></a>（6） TCP和UDP相关的协议与端口号</h2><p>TCP族的协议有HTTP，HTTPS，SMTP，TelNet，FTP等，UDP族的协议有DNS，DHCP等等。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22080999/article/details/81105051">https://blog.csdn.net/qq_22080999/article/details/81105051</a></p>
<h2 id="（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）"><a href="#（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）" class="headerlink" title="（7） TCP（UDP，IP）等首部的认识（http请求报文构成）"></a>（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</h2><p>TCP的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等</p>
<p>UDP的头部则包括：源端口，目的端口，长度，校验和。</p>
<p>IP数据包的头部包括：源IP地址，目的IP地址，协议，校验和，总长度等等</p>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangliangzi/article/details/52554439">https://blog.csdn.net/zhangliangzi/article/details/52554439</a></p>
<h2 id="（8）-网页解析的过程与实现方法"><a href="#（8）-网页解析的过程与实现方法" class="headerlink" title="（8） 网页解析的过程与实现方法"></a>（8） 网页解析的过程与实现方法</h2><p>这里仅展示浏览器解析服务器响应的过程，URL解析和交互的完整过程在(9)</p>
<ul>
<li>首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成。</li>
<li>然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。</li>
<li>不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。</li>
<li>然后是css解析，将css文件解析为样式表对象来渲染DOM树。</li>
</ul>
<h2 id="（10）-网络层分片的原因与具体实现"><a href="#（10）-网络层分片的原因与具体实现" class="headerlink" title="（10） 网络层分片的原因与具体实现"></a>（10） 网络层分片的原因与具体实现</h2><p>因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。</p>
<p>IP分片和完整IP报文差不多拥有相同的IP头，16位ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对IP数据进行重新组织。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gettogetto/article/details/72851734">https://blog.csdn.net/gettogetto/article/details/72851734</a></p>
<h2 id="（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"><a href="#（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）" class="headerlink" title="（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"></a>（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</h2><ul>
<li>三次握手</li>
</ul>
<p>第一次握手：首先client给server发送连接请求报文，在这个报文中，包含了SYN&#x3D;1，client_seq&#x3D;任意值i，发送之后处于SYN-SENT状态，这是第一次握手</p>
<p>第二次握手：server端接收到了这个请求，并分配资源，同时给client返回一个ACK报文，这个报文中呢包含了这些字段，标志位SYN和ACK都为1，而小ack为i+1，此时位于SYN-RCVD状态，这是第二次握手</p>
<p>第三次握手：client收到server发来的ACK信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server回一个ACK报文，报文中同样包含了ACK&#x3D;1这样的消息，同时呢，还包括了client_ack&#x3D;k+1这样的字段，这样呢三次握手之后，连接就建立了，client进入established（已建立连接）状态<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手.png"></p>
<ul>
<li>四次挥手断开连接：</li>
</ul>
<p>TCP断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动<br>第一次挥手：当client没有数据要发送给server了，他会给server发送一个FIN报文，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后client进入FIN_WAIT_1的第一阶段</p>
<p>第二次挥手：当server收到client发来的FIN报文后，告诉client：“我收到你的FIN消息了，但是你等我发完的”此时给client返回一个ACK信息，并且呢ack&#x3D;seq+1，这是第二次挥手，挥手之后呢server进入CLOSE_WAIT阶段，而client收到之后处于FIN_WAIT_2第二阶段</p>
<p>第三次挥手：当server发完所有数据时，他会给client发送一个FIN报文，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变成LAST_ACK状态，等着client最后的ACK信息，这是第三次挥手</p>
<p>第四次挥手：当client收到这个FIN报文时，他会对这个消息进行确认，即给server发ACK信息，但是它不相信网络，怕server收不到信息，它会进入TIME_WAIT状态，万一server没收到ACK消息它可以可以重传，而当server收到这个ACK信息后，就正式关闭了tcp连接，处于CLOSED状态，而client等待了2MSL这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样tcp连接就断开了<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="fig/四次挥手.png"></p>
<h2 id="（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态"><a href="#（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态" class="headerlink" title="（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态"></a>（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</h2><p>见上</p>
<h2 id="（13）-为什么使用三次握手，两次握手可不可以？"><a href="#（13）-为什么使用三次握手，两次握手可不可以？" class="headerlink" title="（13） 为什么使用三次握手，两次握手可不可以？"></a>（13） 为什么使用三次握手，两次握手可不可以？</h2><p>如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。</p>
<p>举两个例子，第一种是黑客会伪造大量SYN请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫SYN洪泛攻击。第二种是服务器返回给客户端的ACK数据包可能会在传输的过程中丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。</p>
<h2 id="（14）-TIME-WAIT的意义（为什么要等于2MSL）"><a href="#（14）-TIME-WAIT的意义（为什么要等于2MSL）" class="headerlink" title="（14） TIME_WAIT的意义（为什么要等于2MSL）"></a>（14） TIME_WAIT的意义（为什么要等于2MSL）</h2><p>TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。如果客户端发送的ACK发生丢失，服务器会再次发送FIN报文给客户端，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<h2 id="（15）-超时重传机制（不太高频）"><a href="#（15）-超时重传机制（不太高频）" class="headerlink" title="（15） 超时重传机制（不太高频）"></a>（15） 超时重传机制（不太高频）</h2><h2 id="（16）-TCP怎么保证可靠性？"><a href="#（16）-TCP怎么保证可靠性？" class="headerlink" title="（16） TCP怎么保证可靠性？"></a>（16） TCP怎么保证可靠性？</h2><p><strong>（校序重流拥）</strong></p>
<ul>
<li><p>校验和<br>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p>
</li>
<li><p>确认应答+序列号<br>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p>
</li>
<li><p>超时重传<br>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
</li>
<li><p>流量控制<br>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>接收方有即时窗口（滑动窗口），随ACK报文发送</p>
</li>
<li><p>拥塞控制<br>当网络拥塞时，减少数据的发送。<br>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</p>
</li>
</ul>
<p>慢启动、拥塞避免、快速重传、快速恢复 </p>
<h2 id="（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"><a href="#（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？" class="headerlink" title="（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"></a>（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</h2><p>所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用TCP报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。</p>
<p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。</p>
<p>解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。</p>
<h2 id="（18）-tcp滑动窗口协议"><a href="#（18）-tcp滑动窗口协议" class="headerlink" title="（18） tcp滑动窗口协议"></a>（18） tcp滑动窗口协议</h2><p>详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/wdscq1234/article/details/52444277">TCP-IP详解：滑动窗口SlidingWindow</a>和<a target="_blank" rel="noopener" href="https://www.cnblogs.com/alifpga/p/7675850.html">TCP滑动窗口</a></p>
<p>TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。</p>
<p>接收方会在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。</p>
<h2 id="（19）-拥塞控制和流量控制的区别"><a href="#（19）-拥塞控制和流量控制的区别" class="headerlink" title="（19） 拥塞控制和流量控制的区别"></a>（19） 拥塞控制和流量控制的区别</h2><p>拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。</p>
<h2 id="（20）-TCP拥塞控制，算法名字？（极其重要）"><a href="#（20）-TCP拥塞控制，算法名字？（极其重要）" class="headerlink" title="（20） TCP拥塞控制，算法名字？（极其重要）"></a>（20） TCP拥塞控制，算法名字？（极其重要）</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="拥塞控制"><br>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制自然也是控制发送者的流量，拥塞控制有四种算法，<strong>慢启动、拥塞避免，快速重传和快速恢复</strong></p>
<p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口和接受窗口的较小值。</p>
<p>（1）<strong>慢启动</strong>。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16<br>*为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd &gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法</p>
<p>（2）<strong>拥塞避免</strong>。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p>
<p>（3）<strong>快速重传</strong>。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1）</p>
<p>（4）<strong>快速恢复</strong>。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd&#x3D;1，进入慢启动阶段</p>
<h2 id="（22）-TCP三次握手时的第一次的seq序号是怎样产生的"><a href="#（22）-TCP三次握手时的第一次的seq序号是怎样产生的" class="headerlink" title="（22） TCP三次握手时的第一次的seq序号是怎样产生的"></a>（22） TCP三次握手时的第一次的seq序号是怎样产生的</h2><p>第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p>
<p>seq &#x3D; C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。</p>
<h2 id="（23）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"><a href="#（23）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？" class="headerlink" title="（23） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"></a>（23） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</h2><p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16&#x3D;65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p>
<p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p>
<h2 id="（24）-对称密码和非对称密码体系"><a href="#（24）-对称密码和非对称密码体系" class="headerlink" title="（24） 对称密码和非对称密码体系"></a>（24） 对称密码和非对称密码体系</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29689487/article/details/81634057">https://blog.csdn.net/qq_29689487/article/details/81634057</a></p>
<ul>
<li>对称加密：加密和解密使用的密钥是同一个<ul>
<li>优点：计算量小，算法速度快，加密效率高  缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲</li>
<li>常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES</li>
</ul>
</li>
<li>非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密<ul>
<li>优点：安全，不怕泄漏  缺点：速度慢</li>
<li>常用算法：RSA，ECC，DSA</li>
</ul>
</li>
</ul>
<h2 id="（25）-数字证书的了解（高频）"><a href="#（25）-数字证书的了解（高频）" class="headerlink" title="（25） 数字证书的了解（高频）"></a>（25） 数字证书的了解（高频）</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.jpg" alt="fig/数字证书.jpg"></p>
<p>权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。</p>
<p>网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。</p>
<h2 id="（26）-服务器出现大量close-wait的连接的原因以及解决方法"><a href="#（26）-服务器出现大量close-wait的连接的原因以及解决方法" class="headerlink" title="（26） 服务器出现大量close_wait的连接的原因以及解决方法"></a>（26） 服务器出现大量close_wait的连接的原因以及解决方法</h2><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p>
<ul>
<li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li>
<li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li>
</ul>
<p>处理方法：</p>
<ul>
<li>停止应用程序</li>
<li>修改程序里的bug</li>
</ul>
<h2 id="（27）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"><a href="#（27）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）" class="headerlink" title="（27） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"></a>（27） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</h2><ul>
<li><p>消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等</p>
</li>
<li><p>MD5算法介绍：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）</p>
</li>
</ul>
<ol>
<li>MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。</li>
<li>对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。</li>
<li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。</li>
<li>遍历所有分组后得到的四个变量即为结果。</li>
</ol>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39640298/article/details/84555814">https://blog.csdn.net/weixin_39640298/article/details/84555814</a></p>
<ul>
<li><p>为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。</p>
</li>
<li><p>加强安全性：加盐（加随机数）</p>
</li>
</ul>
<h2 id="（28）-单条记录高并发访问的优化"><a href="#（28）-单条记录高并发访问的优化" class="headerlink" title="（28） 单条记录高并发访问的优化"></a>（28） 单条记录高并发访问的优化</h2><p>服务器端：</p>
<ul>
<li>使用缓存，如redis等</li>
<li>使用分布式架构进行处理</li>
<li>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回</li>
<li>将静态资源尽可能在客户端进行缓存</li>
<li>采用ngnix进行负载均衡 （nginx读作恩静埃克斯 &#x3D; Engine X）</li>
</ul>
<p>数据库端：</p>
<ul>
<li>数据库采用主从赋值，读写分离措施</li>
<li>建立适当的索引</li>
<li>分库分表</li>
</ul>
<h2 id="（29）-介绍一下ping的过程，分别用到了哪些协议"><a href="#（29）-介绍一下ping的过程，分别用到了哪些协议" class="headerlink" title="（29） 介绍一下ping的过程，分别用到了哪些协议"></a>（29） 介绍一下ping的过程，分别用到了哪些协议</h2><p>详见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html">Ping原理与ICMP协议</a></p>
<p>ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议</p>
<ul>
<li>首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。</li>
<li>然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li>
<li>然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li>
</ul>
<p>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。</p>
<h2 id="（30）-TCP-IP的粘包与避免介绍一下"><a href="#（30）-TCP-IP的粘包与避免介绍一下" class="headerlink" title="（30） TCP&#x2F;IP的粘包与避免介绍一下"></a>（30） TCP&#x2F;IP的粘包与避免介绍一下</h2><p>因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。</p>
<p>导致TCP粘包的原因有三方面：</p>
<ul>
<li>发送端等待缓冲区满才进行发送，造成粘包</li>
<li>接收方来不及接收缓冲区内的数据，造成粘包</li>
<li>由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</li>
</ul>
<p>避免粘包的措施：</p>
<ul>
<li>通过编程，强制使TCP发生数据传送，不必等到缓冲区满</li>
<li>优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等</li>
<li>设置固定长度的报文或者设置报文头部指示报文的长度。</li>
</ul>
<h2 id="（31）-说一下TCP的封包和拆包"><a href="#（31）-说一下TCP的封包和拆包" class="headerlink" title="（31） 说一下TCP的封包和拆包"></a>（31） 说一下TCP的封包和拆包</h2><p>因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li>
<li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</li>
</ul>
<h2 id="（32）-一个ip配置多个域名，靠什么识别？"><a href="#（32）-一个ip配置多个域名，靠什么识别？" class="headerlink" title="（32） 一个ip配置多个域名，靠什么识别？"></a>（32） 一个ip配置多个域名，靠什么识别？</h2><ul>
<li>靠host主机名区分</li>
<li>靠端口号区分</li>
</ul>
<h2 id="（33）-服务器攻击（DDos攻击）"><a href="#（33）-服务器攻击（DDos攻击）" class="headerlink" title="（33） 服务器攻击（DDos攻击）"></a>（33） 服务器攻击（DDos攻击）</h2><h2 id="（34）DNS的工作过程和原理"><a href="#（34）DNS的工作过程和原理" class="headerlink" title="（34）DNS的工作过程和原理"></a>（34）DNS的工作过程和原理</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/DNS%E6%9F%A5%E8%AF%A2%E5%9B%BE%E8%A7%A3.png"><br>DNS解析有两种方式：递归查询和迭代查询</p>
<ul>
<li>递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。</li>
<li>迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果</li>
</ul>
<h2 id="（35）OSA七层协议和五层协议，TCP-IP四层网络模型，分别有哪些-over"><a href="#（35）OSA七层协议和五层协议，TCP-IP四层网络模型，分别有哪些-over" class="headerlink" title="（35）OSA七层协议和五层协议，TCP&#x2F;IP四层网络模型，分别有哪些&#x3D;&#x3D;over&#x3D;&#x3D;"></a>（35）OSA七层协议和五层协议，TCP&#x2F;IP四层网络模型，分别有哪些&#x3D;&#x3D;over&#x3D;&#x3D;</h2><h3 id="简要概括"><a href="#简要概括" class="headerlink" title="简要概括"></a>简要概括</h3><ul>
<li>应用层：各种应用软件，包括 Web 应用。</li>
<li>表示层：数据格式标识，基本压缩加密功能。</li>
<li>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</li>
<li>传输层：端到端传输数据的基本功能；如 TCP、UDP。</li>
<li>网络层：定义IP编址，定义<strong>路由功能</strong>；如不同设备的数据转发。</li>
<li>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</li>
<li>物理层：底层数据传输，如网线；网卡标准。</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>在四层，既传输层数据被称作<strong>tcp报文段或udp用户数据报</strong>（Segments）；</li>
<li>三层网络层数据被称做<strong>包</strong>（Packages）；</li>
<li>二层数据链路层时数据被称为<strong>帧</strong>（Frames）；</li>
<li>一层物理层时数据被称为<strong>比特流</strong>（Bits）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>网络七层模型是&#x3D;&#x3D;一个标准，而非实现&#x3D;&#x3D;。</li>
<li>网络四层模型是一个&#x3D;&#x3D;实现的应用&#x3D;&#x3D;模型。</li>
<li>网络四层模型由七层模型简化合并而来。</li>
</ul>
<p>五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。</p>
<p>TCP&#x2F;IP 四层模型：应用层，传输层，网络层，网络接口层</p>
<p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82.png" alt="(fig/网络协议层.png"></p>
<h2 id="（36）IP寻址和MAC寻址有什么不同，怎么实现的"><a href="#（36）IP寻址和MAC寻址有什么不同，怎么实现的" class="headerlink" title="（36）IP寻址和MAC寻址有什么不同，怎么实现的"></a>（36）IP寻址和MAC寻址有什么不同，怎么实现的</h2><h1 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3. 操作系统"></a>3. 操作系统</h1><h2 id="（1）-进程与线程的区别和联系（重点）"><a href="#（1）-进程与线程的区别和联系（重点）" class="headerlink" title="（1） 进程与线程的区别和联系（重点）"></a>（1） 进程与线程的区别和联系（重点）</h2><ul>
<li>区别</li>
</ul>
<ol>
<li>进程是对运行时程序的封装，是系统进行资源分配和调度的基本单元，而线程是进程的子任务，是CPU分配和调度的基本单元。</li>
<li>一个进程可以有多个线程，但是一个线程只能属于一个进程。</li>
<li>进程的创建需要系统分配内存和CPU，文件句柄等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。</li>
<li>进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。</li>
</ol>
<ul>
<li>联系 进程与线程之间的关系：线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。</li>
</ul>
<h2 id="（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"><a href="#（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关" class="headerlink" title="（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"></a>（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</h2><p>答：32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。</p>
<p>至于线程。进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。Linux32位下是300多个。</p>
<h2 id="（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"><a href="#（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）" class="headerlink" title="（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"></a>（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</h2><ul>
<li>存储器：内存</li>
<li>控制器：南桥北桥</li>
<li>运算器：CPU</li>
<li>输入设备：键盘</li>
<li>输出设备：显示器、网卡</li>
</ul>
<h2 id="（4）-进程之间的通信方法有哪几种-（重点）"><a href="#（4）-进程之间的通信方法有哪几种-（重点）" class="headerlink" title="（4） 进程之间的通信方法有哪几种 （重点）"></a>（4） 进程之间的通信方法有哪几种 （重点）</h2><p>进程之间的通信方式主要有六种，包括<strong>管道，信号量，消息队列，信号，共享内存，套接字</strong>。</p>
<ul>
<li><p>管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png" alt="fig/管道通信.png"></p>
<p>匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。</p>
<p>管道的底层实现 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009528245">https://segmentfault.com/a/1190000009528245</a></p>
</li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。</p>
</li>
<li><p>信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的</p>
</li>
<li><p>共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。</p>
</li>
<li><p>消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。<br>消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。<br>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p>
</li>
<li><p>套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>
</li>
</ul>
<h2 id="（5）-进程调度方法详细介绍"><a href="#（5）-进程调度方法详细介绍" class="headerlink" title="（5） 进程调度方法详细介绍"></a>（5） 进程调度方法详细介绍</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011080472/article/details/51217754">https://blog.csdn.net/u011080472/article/details/51217754</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leex_brave/article/details/51638300">https://blog.csdn.net/leex_brave/article/details/51638300</a></p>
<ul>
<li>先来先服务 （FCFS first come first serve）：按照作业到达任务队列的顺序调度  FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）而不利于短作业（I&#x2F;O繁忙性）。</li>
<li>短作业优先 （SHF short job first）：每次从队列里选择预计时间最短的作业运行。SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业可能一直处于等待状态，出现饥饿现象；完全未考虑作业的优先紧迫程度，不能用于实时系统。</li>
<li>最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。</li>
<li>高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。响应比 &#x3D; （等待时间 + 服务时间） &#x2F; 服务时间 &#x3D; 等待时间 &#x2F; 服务时间 + 1。因为每次都需要计算响应比，所以比较耗费系统资源。</li>
<li>时间片轮转 用于分时系统的进程调度。基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。</li>
<li>多级反馈队列(Multilevel Feedback Queue)</li>
</ul>
<h2 id="（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？"><a href="#（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？" class="headerlink" title="（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？"></a>（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？</h2><p>进程的执行需要经过三大步骤：编译，链接和装入。</p>
<ul>
<li>编译：将源代码编译成若干模块</li>
<li>链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）</li>
<li>装入：将模块装入内存运行</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38623623/article/details/78306498">https://blog.csdn.net/qq_38623623/article/details/78306498</a></p>
<p>将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。</p>
<p>通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。</p>
<h2 id="（6）-操作系统的内存管理说一下"><a href="#（6）-操作系统的内存管理说一下" class="headerlink" title="（6） 操作系统的内存管理说一下"></a>（6） 操作系统的内存管理说一下</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peterYong/p/6556619.html">https://www.cnblogs.com/peterYong/p/6556619.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/141602175">https://zhuanlan.zhihu.com/p/141602175</a></p>
<p>操作系统的内存管理包括物理内存管理和虚拟内存管理</p>
<ul>
<li>物理内存管理包括交换与覆盖，分页管理，分段管理和段页式管理等；</li>
<li>虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等；</li>
</ul>
<p>（面试官这样问的时候，其实是希望你能讲讲虚拟内存）</p>
<h2 id="（7）-实现一个LRU算法"><a href="#（7）-实现一个LRU算法" class="headerlink" title="（7） 实现一个LRU算法"></a>（7） 实现一个LRU算法</h2><p>用到两个数据结构：哈希+双向链表 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; &gt; cache ;<span class="comment">// 存放键，迭代器</span></span><br><span class="line">list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; auxlist; <span class="comment">// 存放 &lt;键，值&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; l;  <span class="comment">// front:new back:old 存放值</span></span><br><span class="line">                             <span class="comment">// 新的放前面，因为前面的可以取得有效的迭代器</span></span><br><span class="line">    map&lt;<span class="type">int</span>, list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt; cache;  <span class="comment">// 存放键，迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123; cap = capacity; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> mapitera = cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (mapitera == cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// found</span></span><br><span class="line">            list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator listItera = mapitera-&gt;second;</span><br><span class="line">            <span class="type">int</span> value = (*listItera).second;</span><br><span class="line"></span><br><span class="line">            l.<span class="built_in">erase</span>(listItera);</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key, value&#125;);</span><br><span class="line">            cache[key] = l.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> itera = cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (itera != cache.<span class="built_in">end</span>()) &#123;  <span class="comment">// exist</span></span><br><span class="line">            list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator listItera = itera-&gt;second;</span><br><span class="line"></span><br><span class="line">            l.<span class="built_in">erase</span>(listItera);</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key, value&#125;);</span><br><span class="line">            cache[key] = l.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// not exist</span></span><br><span class="line">            <span class="keyword">if</span> (cache.<span class="built_in">size</span>() &gt;= cap) &#123;</span><br><span class="line">                pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; oldpair = l.<span class="built_in">back</span>();</span><br><span class="line">                l.<span class="built_in">pop_back</span>();</span><br><span class="line">                cache.<span class="built_in">erase</span>(oldpair.first);</span><br><span class="line">            &#125;</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key, value&#125;);</span><br><span class="line">            cache[key] = l.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）"><a href="#（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）" class="headerlink" title="（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）"></a>（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）</h2><p>（1） 互斥：一个资源每次只能被一个进程使用。<br><br>（2） 占有并请求：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br><br>（3） 不可剥夺:进程已获得的资源，在末使用完之前，不能强行剥夺。<br><br>（4） 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。<br></p>
<p>产生死锁的原因主要是：<br><br>（1） 因为系统资源不足。<br><br>（2） 进程运行推进的顺序不合适。<br><br>（3） 资源分配不当等。<br></p>
<h2 id="（8）-死锁的恢复"><a href="#（8）-死锁的恢复" class="headerlink" title="（8） 死锁的恢复"></a>（8） 死锁的恢复</h2><ol>
<li>重新启动：是最简单、最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。</li>
<li>终止进程(process termination)：终止参与死锁的进程并回收它们所占资源。<br>(1) 一次性全部终止；(2) 逐步终止(优先级，代价函数)</li>
<li>剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。<br>(1) 逐步剥夺：一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。<br>(2) 一次剥夺：一次性地剥夺死锁进程所占有的全部资源。</li>
<li>进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大：<br>(1) 要实现“回退”，必须“记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。<br>(2) 一个回退的进程应当“挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的</li>
</ol>
<h2 id="（8）什么是饥饿"><a href="#（8）什么是饥饿" class="headerlink" title="（8）什么是饥饿"></a>（8）什么是饥饿</h2><p>饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。</p>
<h2 id="（9）-如果要你实现一个mutex互斥锁你要怎么实现？"><a href="#（9）-如果要你实现一个mutex互斥锁你要怎么实现？" class="headerlink" title="（9） 如果要你实现一个mutex互斥锁你要怎么实现？"></a>（9） 如果要你实现一个mutex互斥锁你要怎么实现？</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kid551/article/details/84338619">https://blog.csdn.net/kid551/article/details/84338619</a></p>
<p>实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag&#x3D;1表明该锁已经锁住，flag&#x3D;0表明锁没有锁住。<br>实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;flag,<span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//flag=1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为while有可能被重入，所以可以用TestandSet()方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> old = *ptr;</span><br><span class="line">    *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？"><a href="#（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？" class="headerlink" title="（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？"></a>（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</h2><p>线程之间通信：</p>
<ul>
<li>使用全局变量</li>
<li>使用信号机制</li>
<li>使用事件</li>
</ul>
<p>进程之间同步：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html">https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html</a></p>
<ul>
<li>信号量</li>
<li>管程</li>
</ul>
<h2 id="（13）-什么时候用多进程，什么时候用多线程"><a href="#（13）-什么时候用多进程，什么时候用多线程" class="headerlink" title="（13） 什么时候用多进程，什么时候用多线程"></a>（13） 什么时候用多进程，什么时候用多线程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yu876876/article/details/82810178">https://blog.csdn.net/yu876876/article/details/82810178</a></p>
<ul>
<li>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></li>
<li>计算量：需要大量计算的优先使用<strong>多线程</strong>  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</li>
<li>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</li>
<li>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</li>
</ul>
<p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p>
<h2 id="（14）-文件读写使用的系统调用"><a href="#（14）-文件读写使用的系统调用" class="headerlink" title="（14） 文件读写使用的系统调用"></a>（14） 文件读写使用的系统调用</h2><h2 id="（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？"><a href="#（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？" class="headerlink" title="（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？"></a>（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p>
<ul>
<li>孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。</li>
<li>僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。</li>
</ul>
<h2 id="（16）-说一下PCB-说一下进程地址空间"><a href="#（16）-说一下PCB-说一下进程地址空间" class="headerlink" title="（16） 说一下PCB&#x2F;说一下进程地址空间&#x2F;"></a>（16） 说一下PCB&#x2F;说一下进程地址空间&#x2F;</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38499859/article/details/80057427">https://blog.csdn.net/qq_38499859/article/details/80057427</a></p>
<p>PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。</p>
<p>PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息</p>
<p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/Center.jpeg"></p>
<p>进程地址空间内有：</p>
<ul>
<li>代码段text：存放程序的二进制代码</li>
<li>初始化的数据Data：已经初始化的变量和数据</li>
<li>未初始化的数据BSS：还没有初始化的数据</li>
<li>栈</li>
<li>堆</li>
</ul>
<h2 id="（17）-内核空间和用户空间是怎样区分的"><a href="#（17）-内核空间和用户空间是怎样区分的" class="headerlink" title="（17） 内核空间和用户空间是怎样区分的"></a>（17） 内核空间和用户空间是怎样区分的</h2><p>在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。</p>
<p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。</p>
<h2 id="（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"><a href="#（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）" class="headerlink" title="（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"></a>（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/s_lisheng/article/details/74278765">https://blog.csdn.net/s_lisheng/article/details/74278765</a></p>
<ul>
<li>临界区</li>
<li>信号量</li>
<li>事件</li>
<li>互斥量</li>
</ul>
<h2 id="（19）-同一个进程内的线程会共享什么资源？"><a href="#（19）-同一个进程内的线程会共享什么资源？" class="headerlink" title="（19） 同一个进程内的线程会共享什么资源？"></a>（19） 同一个进程内的线程会共享什么资源？</h2><ul>
<li>该进程的地址空间</li>
<li>全局变量</li>
<li>堆空间</li>
</ul>
<p>线程的栈空间是自己独有的</p>
<h2 id="（20）-异常和中断的区别"><a href="#（20）-异常和中断的区别" class="headerlink" title="（20） 异常和中断的区别"></a>（20） 异常和中断的区别</h2><h2 id="（21）-一般情况下在Linux-windows平台下栈空间的大小"><a href="#（21）-一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="（21） 一般情况下在Linux&#x2F;windows平台下栈空间的大小"></a>（21） 一般情况下在Linux&#x2F;windows平台下栈空间的大小</h2><p>在Linux下栈空间通常是8M，Windows下是1M</p>
<h2 id="（22）虚拟内存的了解"><a href="#（22）虚拟内存的了解" class="headerlink" title="（22）虚拟内存的了解"></a>（22）虚拟内存的了解</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Przz/p/6876988.html">https://www.cnblogs.com/Przz/p/6876988.html</a></p>
<p>在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。<br>当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。</p>
<h2 id="（23）服务器高并发的解决方案"><a href="#（23）服务器高并发的解决方案" class="headerlink" title="（23）服务器高并发的解决方案"></a>（23）服务器高并发的解决方案</h2><ol>
<li><p>应用数据与静态资源分离<br>将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p>
</li>
<li><p>客户端缓存<br>因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p>
</li>
<li><p>集群和分布式<br>（集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br><br>（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br><br>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p>
</li>
<li><p>反向代理<br>在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</p>
</li>
</ol>
<h2 id="（24）协程了解吗（高频）"><a href="#（24）协程了解吗（高频）" class="headerlink" title="（24）协程了解吗（高频）"></a>（24）协程了解吗（高频）</h2><p>协程和微线程是一个东西。</p>
<p>协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。<br>这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。</p>
<h2 id="（25）那协程的底层是怎么实现的，怎么使用协程？"><a href="#（25）那协程的底层是怎么实现的，怎么使用协程？" class="headerlink" title="（25）那协程的底层是怎么实现的，怎么使用协程？"></a>（25）那协程的底层是怎么实现的，怎么使用协程？</h2><p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p>
<h2 id="（23）进程的状态以及转换图"><a href="#（23）进程的状态以及转换图" class="headerlink" title="（23）进程的状态以及转换图"></a>（23）进程的状态以及转换图</h2><ul>
<li><p>三态模型<br>三态模型包括三种状态：</p>
<ol>
<li>执行：进程分到CPU时间片，可以执行</li>
<li>就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行</li>
<li>阻塞：有IO事件或者等待其他资源<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B.png"></li>
</ol>
</li>
<li><p>五态模型</p>
<ol>
<li>新建态：进程刚刚创建。</li>
<li>就绪态：</li>
<li>运行态：</li>
<li>等待态：出现等待事件</li>
<li>终止态：进程结束<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B.png"></li>
</ol>
</li>
<li><p>七态模型</p>
<ol>
<li>新建态</li>
<li>就绪挂起态</li>
<li>就绪态</li>
<li>运行态</li>
<li>等待态</li>
<li>挂起等待态</li>
<li>终止态<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%B8%83%E6%80%81%E6%A8%A1%E5%9E%8B.png"></li>
</ol>
</li>
</ul>
<h2 id="（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？"><a href="#（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？" class="headerlink" title="（24）在执行malloc申请内存的时候，操作系统是怎么做的？&#x2F;内存分配的原理说一下&#x2F;malloc函数底层是怎么实现的？&#x2F;进程是怎么分配内存的？"></a>（24）在执行malloc申请内存的时候，操作系统是怎么做的？&#x2F;内存分配的原理说一下&#x2F;malloc函数底层是怎么实现的？&#x2F;进程是怎么分配内存的？</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yusiguyuan/article/details/39496057">https://blog.csdn.net/yusiguyuan/article/details/39496057</a></p>
<p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p>
<ul>
<li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li>
<li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li>
</ul>
<p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p>
<p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p>
<h2 id="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"><a href="#（25）什么是字节序？怎么判断是大端还是小端？有什么用？" class="headerlink" title="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"></a>（25）什么是字节序？怎么判断是大端还是小端？有什么用？</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/broglie/p/5645200.html">https://www.cnblogs.com/broglie/p/5645200.html</a></p>
<p>字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。<br>判断大小端的方法：使用一个union数据结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">endian</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    endian value;</span><br><span class="line">    value.a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//a和ch共用4字节的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (value.ch == <span class="number">0x12</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;big endian&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value.ch == <span class="number">0x34</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;little endian&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在网络编程中不同字节序的机器发送和接收的顺序不同。</p>
<h1 id="4-Linux"><a href="#4-Linux" class="headerlink" title="4. Linux"></a>4. Linux</h1><h2 id="（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"><a href="#（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）" class="headerlink" title="（1） Linux的I&#x2F;O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"></a>（1） Linux的I&#x2F;O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sqsltr/article/details/92762279">https://blog.csdn.net/sqsltr/article/details/92762279</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/euphie/p/6376508.html">https://www.cnblogs.com/euphie/p/6376508.html</a></p>
<p>（IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据）</p>
<ul>
<li><p>阻塞：调用IO操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝。</p>
</li>
<li><p>非阻塞：调用IO操作的时候，内核会马上返回结果，如果IO不可用，会返回错误，这种方式下进程需要不断轮询直到IO可用为止，但是当进程从内核拷贝数据时是阻塞的。</p>
</li>
<li><p>IO多路复用就是同时监听多个描述符，一旦某个描述符IO就绪（读就绪或者写就绪），就能够通知进程进行相应的IO操作，否则就将进程阻塞在select或者epoll语句上。</p>
</li>
<li><p>同步IO：同步IO模型包括阻塞IO，非阻塞IO和IO多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。</p>
</li>
<li><p>异步IO：在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当IO完成后内核会给进程发送一个信号。</p>
</li>
</ul>
<h2 id="（2）-文件系统的理解（EXT4，XFS，BTRFS）"><a href="#（2）-文件系统的理解（EXT4，XFS，BTRFS）" class="headerlink" title="（2） 文件系统的理解（EXT4，XFS，BTRFS）"></a>（2） 文件系统的理解（EXT4，XFS，BTRFS）</h2><h2 id="（3）-EPOLL的介绍和了解"><a href="#（3）-EPOLL的介绍和了解" class="headerlink" title="（3） EPOLL的介绍和了解"></a>（3） EPOLL的介绍和了解</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56486633">https://zhuanlan.zhihu.com/p/56486633</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/397449cadc9a">https://www.jianshu.com/p/397449cadc9a</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/davidsguo008/article/details/73556811">https://blog.csdn.net/davidsguo008/article/details/73556811</a></p>
<p>Epoll是Linux进行IO多路复用的一种方式，用于在一个线程里监听多个IO源，在IO源可用的时候返回并进行操作。它的特点是基于事件驱动，性能很高。</p>
<p>epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。</p>
<p>Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。</p>
<ul>
<li><p>eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。</p>
</li>
<li><p>epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。</p>
</li>
<li><p>epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。</p>
</li>
</ul>
<h2 id="（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？"><a href="#（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？" class="headerlink" title="（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？"></a>（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</h2><p>（1）select的方法介绍：select把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024.<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/select.png" alt="select"><br>（2)poll使用链表保存文件描述符，其他的跟select没有什么不同。</p>
<p>（3）epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/epoll.png" alt="epoll"><br>详见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3265058.html">https://www.cnblogs.com/Anker/p/3265058.html</a></p>
<h2 id="（5）-Epoll的ET模式和LT模式（ET的非阻塞）"><a href="#（5）-Epoll的ET模式和LT模式（ET的非阻塞）" class="headerlink" title="（5） Epoll的ET模式和LT模式（ET的非阻塞）"></a>（5） Epoll的ET模式和LT模式（ET的非阻塞）</h2><ul>
<li>ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。</li>
<li>LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。</li>
</ul>
<h2 id="（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"><a href="#（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）" class="headerlink" title="（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"></a>（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</h2><p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36357820/article/details/76606113">https://blog.csdn.net/qq_36357820/article/details/76606113</a></p>
<ol>
<li>top命令查看linux负载：</li>
<li>uptime查看linux负载</li>
<li>w查看linux负载：</li>
<li>vmstat查看linux负载</li>
</ol>
<h2 id="（7）-linux的其他常见命令（kill，find，cp等等）"><a href="#（7）-linux的其他常见命令（kill，find，cp等等）" class="headerlink" title="（7） linux的其他常见命令（kill，find，cp等等）"></a>（7） linux的其他常见命令（kill，find，cp等等）</h2><h2 id="（8）-shell脚本用法"><a href="#（8）-shell脚本用法" class="headerlink" title="（8） shell脚本用法"></a>（8） shell脚本用法</h2><h2 id="（9）-硬连接和软连接的区别"><a href="#（9）-硬连接和软连接的区别" class="headerlink" title="（9） 硬连接和软连接的区别"></a>（9） 硬连接和软连接的区别</h2><h2 id="（10）-文件权限怎么看（rwx）"><a href="#（10）-文件权限怎么看（rwx）" class="headerlink" title="（10） 文件权限怎么看（rwx）"></a>（10） 文件权限怎么看（rwx）</h2><h2 id="（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变"><a href="#（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变" class="headerlink" title="（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变"></a>（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</h2><h2 id="（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"><a href="#（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令" class="headerlink" title="（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"></a>（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</h2><h2 id="（13）Linux中线程的同步方式有哪些？"><a href="#（13）Linux中线程的同步方式有哪些？" class="headerlink" title="（13）Linux中线程的同步方式有哪些？"></a>（13）Linux中线程的同步方式有哪些？</h2><h2 id="（14）怎么修改一个文件的权限"><a href="#（14）怎么修改一个文件的权限" class="headerlink" title="（14）怎么修改一个文件的权限"></a>（14）怎么修改一个文件的权限</h2><p>chmod 777  (177 277 477 等，权限组合是 1 2 4，分别代表r x w )</p>
<h2 id="（15）查看文件内容常用命令"><a href="#（15）查看文件内容常用命令" class="headerlink" title="（15）查看文件内容常用命令"></a>（15）查看文件内容常用命令</h2><p>详见： <a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html">http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html</a></p>
<ol>
<li>cat 与 tac</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。所以通常使用重定向的方式，输出满足指定格式的内容</span><br><span class="line"></span><br><span class="line">cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）</span><br><span class="line"></span><br><span class="line">tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令不常用。</span><br><span class="line"></span><br><span class="line">tac语法：tac 文件名。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>more和less（常用）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | more</span><br><span class="line"></span><br><span class="line">more的语法：more 文件名</span><br><span class="line"></span><br><span class="line">Enter 向下n行，需要定义，默认为1行； </span><br><span class="line"></span><br><span class="line">Ctrl f 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">空格键 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">Ctrl b 返回上一屏； </span><br><span class="line"></span><br><span class="line">= 输出当前行的行号； </span><br><span class="line"></span><br><span class="line">:f 输出文件名和当前行的行号； </span><br><span class="line"></span><br><span class="line">v 调用vi编辑器； </span><br><span class="line"></span><br><span class="line">! 命令 调用Shell，并执行命令； </span><br><span class="line"></span><br><span class="line">q 退出more</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">less的功能和more相似，但是使用more无法向前翻页，只能向后翻。</span><br><span class="line"></span><br><span class="line">less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。</span><br><span class="line"></span><br><span class="line">less的语法：less 文件名</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>head和tail</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容</span><br><span class="line"></span><br><span class="line">head的语法：head [n number] 文件名 (number 显示行数)</span><br><span class="line"></span><br><span class="line">tail的功能恰好和head相反，只显示最后几行内容</span><br><span class="line"></span><br><span class="line">tail的语法:tail [-n number] 文件名</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>nl</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来</span><br><span class="line"></span><br><span class="line">nl的语法：nl 文件名</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>vim</li>
</ol>
<p>这个用的太普遍了，主要是用于编辑。</p>
<h2 id="（16）怎么找出含有关键字的前后4行"><a href="#（16）怎么找出含有关键字的前后4行" class="headerlink" title="（16）怎么找出含有关键字的前后4行"></a>（16）怎么找出含有关键字的前后4行</h2><h2 id="（17）Linux的GDB调试"><a href="#（17）Linux的GDB调试" class="headerlink" title="（17）Linux的GDB调试"></a>（17）Linux的GDB调试</h2><h2 id="（18）coredump是什么-怎么才能coredump，为什么产生core文件"><a href="#（18）coredump是什么-怎么才能coredump，为什么产生core文件" class="headerlink" title="（18）coredump是什么 怎么才能coredump，为什么产生core文件"></a>（18）coredump是什么 怎么才能coredump，为什么产生core文件</h2><ul>
<li>它是进程运行时在突然崩溃的<strong>那一刻的一个内存快照</strong>。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻<strong>内存</strong>、<strong>寄存器状态</strong>、<strong>运行堆栈等信息</strong>转储保存在一个core文件里。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</li>
</ul>
<p>coredump产生的条件</p>
<ol>
<li>shell<strong>资源控制限制</strong>，使用 ulimit -c 命令查看shell执行程序时的资源 ，如果为0，则不会产生coredump。可以用ulimit -c unlimited设置为不限大小。</li>
<li>读写越界，包括：数组访问越界，指针指向错误的内存，字符串读写越界</li>
<li>堆栈溢出</li>
<li>使用了<strong>线程不安全</strong>的函数，读写未加锁保护</li>
<li>错误<strong>使用指针转换</strong></li>
</ol>
<h2 id="（19）tcpdump常用命令"><a href="#（19）tcpdump常用命令" class="headerlink" title="（19）tcpdump常用命令"></a>（19）tcpdump常用命令</h2><p>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<p>实用命令实例</p>
<p>将某端口收发的数据包保存到文件<br><br><code>sudo tcpdump -i any port 端口 -w 文件名.cap</code></p>
<p>打印请求到屏幕<br><br><code>sudo tcpdump -i any port 端口 -Xnlps0</code></p>
<p>默认启动<br><br><code>tcpdump</code><br>普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。<br>监视指定网络接口的数据包<br><br><code>tcpdump -i eth1</code><br>如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。</p>
<h2 id="（20）-crontab命令"><a href="#（20）-crontab命令" class="headerlink" title="（20） crontab命令"></a>（20） crontab命令</h2><p>详见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html">https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html</a></p>
<p>corntab命令是用来指定用户计划任务的。用户将需要定时执行的任务写入crontab文件中，提交给crond进程定期执行。</p>
<ul>
<li>crontab命令用来对crontab文件进行管理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1．命令格式：</span><br><span class="line">crontab [-u user] file</span><br><span class="line">crontab [-u user] [ -e | -l | -r ]</span><br><span class="line">2．命令功能：</span><br><span class="line">通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</span><br><span class="line">3．命令参数：</span><br><span class="line">-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</span><br><span class="line">file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</span><br><span class="line">-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line">-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line">-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line">-i：在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure>

<ul>
<li>crontab文件内容</li>
</ul>
<p>crond是Linux下的周期性执行系统任务的守护进程，他会根据&#x2F;etc下的crontab配置文件的内容执行。用户需要将计划任务写入crontab文件中才能执行。</p>
<p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">minute   hour   day   month   week   command</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">minute： 表示分钟，可以是从0到59之间的任何整数。</span><br><span class="line">hour：表示小时，可以是从0到23之间的任何整数。</span><br><span class="line">day：表示日期，可以是从1到31之间的任何整数。</span><br><span class="line">month：表示月份，可以是从1到12之间的任何整数。</span><br><span class="line">week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</span><br><span class="line">在以上各个字段中，还可以使用以下特殊字符：</span><br><span class="line">星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class="line">逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</span><br><span class="line">中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</span><br><span class="line">正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</span><br></pre></td></tr></table></figure>


<h2 id="（21）-查看后台进程"><a href="#（21）-查看后台进程" class="headerlink" title="（21） 查看后台进程"></a>（21） 查看后台进程</h2><ul>
<li>jobs</li>
</ul>
<p>查看当前控制台的后台进程</p>
<p>想要停止后台进程，使用jobs命令查看其进程号（比如为num），然后kill %num即可</p>
<ul>
<li>ps</li>
</ul>
<p>查看后台进程</p>
<ul>
<li>top</li>
</ul>
<p>查看所有进程和资源使用情况，类似Windows中的任务管理器</p>
<p>停止进程：界面是交互式的，在窗口输入k 之后输入PID，会提示输入停止进程模式 有SIGTERM和 SIGKILL 如果留空不输入，就是SIGTERM（优雅停止）</p>
<p>退出top：输入q即可</p>
<h2 id="（22）池化技术"><a href="#（22）池化技术" class="headerlink" title="（22）池化技术"></a>（22）池化技术</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/538360410">池化技术</a></p>
<h2 id="（23）硬中断和软中断——-new"><a href="#（23）硬中断和软中断——-new" class="headerlink" title="（23）硬中断和软中断——&#x3D;&#x3D;new&#x3D;&#x3D;"></a>（23）硬中断和软中断——&#x3D;&#x3D;new&#x3D;&#x3D;</h2><blockquote>
<p>当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数</p>
</blockquote>
<h3 id="硬件中断处理函数会做如下的事情："><a href="#硬件中断处理函数会做如下的事情：" class="headerlink" title="硬件中断处理函数会做如下的事情："></a>硬件中断处理函数会做如下的事情：</h3><ul>
<li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li>
<li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li>
</ul>
<p>至此，硬件中断处理函数的工作就已经完成。</p>
<p>硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。</p>
<h3 id="软中断的处理"><a href="#软中断的处理" class="headerlink" title="软中断的处理"></a>软中断的处理</h3><ul>
<li>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。</li>
<li>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</li>
<li>Ring Buffer——&gt;环形缓存</li>
</ul>
<h2 id="（23）发送网络数据的时候，涉及几次内存拷贝操作？——-new"><a href="#（23）发送网络数据的时候，涉及几次内存拷贝操作？——-new" class="headerlink" title="（23）发送网络数据的时候，涉及几次内存拷贝操作？——&#x3D;&#x3D;new&#x3D;&#x3D;"></a>（23）发送网络数据的时候，涉及几次内存拷贝操作？——&#x3D;&#x3D;new&#x3D;&#x3D;</h2><ul>
<li><p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p>
</li>
<li><p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</p>
</li>
<li><p>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</p>
</li>
<li><p>这里提一下，sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，UDP协议的称为 数据报（datagrams），在 IP 层我们叫 packet，在数据链路层称为 frame</p>
<ul>
<li><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/sk_buff.jpg" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="（24）Linux网络模型——-new"><a href="#（24）Linux网络模型——-new" class="headerlink" title="（24）Linux网络模型——&#x3D;&#x3D;new&#x3D;&#x3D;"></a>（24）Linux网络模型——&#x3D;&#x3D;new&#x3D;&#x3D;</h2><ul>
<li>和 TCP&#x2F;IP 四层网络模型相似</li>
</ul>
<img src="面经整理发布版.assets/协议栈.png" alt="img" style="zoom:50%;" />






<h1 id="5-数据库"><a href="#5-数据库" class="headerlink" title="5. 数据库"></a>5. 数据库</h1><h2 id="（1）-关系型和非关系型数据库的区别（低频）"><a href="#（1）-关系型和非关系型数据库的区别（低频）" class="headerlink" title="（1） 关系型和非关系型数据库的区别（低频）"></a>（1） 关系型和非关系型数据库的区别（低频）</h2><ul>
<li>关系型数据库的优点<ol>
<li>容易理解。因为它采用了关系模型来组织数据。</li>
<li>可以保持数据的一致性。</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带where子句的查询）</li>
</ol>
</li>
<li>非关系型数据库的优点<ol>
<li>不需要经过sql层的解析，读写效率高。</li>
<li>基于键值对，数据的扩展性很好。</li>
<li>可以支持多种类型数据的存储，如图片，文档等等。</li>
</ol>
</li>
</ul>
<h2 id="（2）-什么是非关系型数据库（低频）"><a href="#（2）-什么是非关系型数据库（低频）" class="headerlink" title="（2） 什么是非关系型数据库（低频）"></a>（2） 什么是非关系型数据库（低频）</h2><p>非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。</p>
<p>适合使用非关系型数据库的场景：</p>
<ul>
<li>日志系统</li>
<li>地理位置存储</li>
<li>数据量巨大</li>
<li>高可用</li>
</ul>
<h2 id="（3）-说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#（3）-说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="（3） 说一下 MySQL 执行一条查询语句的内部执行过程？"></a>（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</h2><ul>
<li>连接器：客户端先通过连接器连接到 MySQL 服务器。</li>
<li>缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li>
<li>分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li>
<li>优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li>
<li>执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li>
</ul>
<h2 id="（4）-数据库的索引类型"><a href="#（4）-数据库的索引类型" class="headerlink" title="（4） 数据库的索引类型"></a>（4） 数据库的索引类型</h2><p>数据库的索引类型分为逻辑分类和物理分类<br><br>逻辑分类：</p>
<ul>
<li>主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。</li>
<li>唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。</li>
<li>普通索引 一张表可以有多个普通索引，可以重复可以为空值</li>
<li>全文索引 可以加快模糊查询，不常用</li>
</ul>
<p>物理分类：</p>
<ul>
<li>聚集索引（聚簇索引） 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。</li>
<li>非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。</li>
</ul>
<h2 id="（5）-说一下事务是怎么实现的"><a href="#（5）-说一下事务是怎么实现的" class="headerlink" title="（5） 说一下事务是怎么实现的"></a>（5） 说一下事务是怎么实现的</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/103966510">https://blog.csdn.net/u013256816/article/details/103966510</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/takumicx/p/9998844.html">https://www.cnblogs.com/takumicx/p/9998844.html</a></p>
<p>事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p>
<ul>
<li>日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<strong>持久性</strong>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的<strong>原子性</strong>。</li>
<li>并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的<strong>隔离性</strong>。MVCC通过为数据添加时间戳来实现。</li>
</ul>
<h2 id="（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"><a href="#（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？" class="headerlink" title="（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"></a>（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</h2><p>MySQL建立索引有两种方式：用alter table或者create index。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add primary key(column_list) #添加一个主键索引</span><br><span class="line">alter table table_name add index (column_list)      #添加一个普通索引</span><br><span class="line">alter table table_name add unique (column_list)     #添加一个唯一索引</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name (column_list)   #创建一个普通索引</span><br><span class="line">create unique index_name on table_name (column_list)  #创建一个唯一索引</span><br></pre></td></tr></table></figure>

<p>Mysql删除索引同样也有两种方式：alter table 和 drop index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name drop index index_name    #删除一个普通索引</span><br><span class="line">alter table table_name drop primary key         #删除一个主键索引</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name on table table_name</span><br></pre></td></tr></table></figure>


<h2 id="（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"><a href="#（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）" class="headerlink" title="（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"></a>（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wezheng/p/8399305.html">https://www.cnblogs.com/wezheng/p/8399305.html</a></p>
<ul>
<li>经常搜索的列上建索引</li>
<li>作为主键的列上要建索引</li>
<li>经常需要连接（where子句）的列上</li>
<li>经常需要排序的列</li>
<li>经常需要范围查找的列</li>
</ul>
<p>哪些列不适合建索引？</p>
<ul>
<li>很少查询的列</li>
<li>更新很频繁的列</li>
<li>数据值的取值比较少的列（比如性别）</li>
</ul>
<h2 id="（8）-索引的底层实现（重点）"><a href="#（8）-索引的底层实现（重点）" class="headerlink" title="（8） 索引的底层实现（重点）"></a>（8） 索引的底层实现（重点）</h2><p>数据库的索引是使用B+树来实现的。</p>
<p>（为什么要用B+树，为什么不用红黑树和B树）<br><br>B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。</p>
<p>而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。</p>
<h2 id="（9）-B树和B-树的区别（重点）"><a href="#（9）-B树和B-树的区别（重点）" class="headerlink" title="（9） B树和B+树的区别（重点）"></a>（9） B树和B+树的区别（重点）</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/Bptree.png" alt="./fig/Bptree.png"></p>
<p>这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。</p>
<ol>
<li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li>
<li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li>
<li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li>
<li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li>
</ol>
<p>B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。</p>
<h2 id="（10）-索引最左前缀-最左匹配"><a href="#（10）-索引最左前缀-最左匹配" class="headerlink" title="（10） 索引最左前缀&#x2F;最左匹配"></a>（10） 索引最左前缀&#x2F;最左匹配</h2><p>假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。</p>
<h2 id="（11）-Mysql的优化（高频，索引优化，性能优化）"><a href="#（11）-Mysql的优化（高频，索引优化，性能优化）" class="headerlink" title="（11） Mysql的优化（高频，索引优化，性能优化）"></a>（11） Mysql的优化（高频，索引优化，性能优化）</h2><p>高频访问：</p>
<ul>
<li>分表分库：将数据库表进行水平拆分，减少表的长度</li>
<li>增加缓存： 在web和DB之间加上一层缓存层</li>
<li>增加数据库的索引：在合适的字段加上索引，解决高频访问的问题</li>
</ul>
<p>并发优化：</p>
<ul>
<li>主从读写分离：只在主服务器上写，从服务器上读</li>
<li>负载均衡集群：通过集群或者分布式的方式解决并发压力</li>
</ul>
<h2 id="（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别"><a href="#（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别" class="headerlink" title="（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别"></a>（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</h2><ul>
<li>InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁</li>
<li>MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用  表级锁</li>
<li>MEMORY ： memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景</li>
<li>CSV</li>
<li>blackhole</li>
</ul>
<h2 id="（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"><a href="#（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）" class="headerlink" title="（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"></a>（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</h2><p>数据库事务是指逻辑上对数据的一种操作，这个事务要么全部成功，要么全部失败。</p>
<p><strong>A: atom 原子性</strong><br><br>数据库事务的原子性是指：事务是一个不可分割的工作单位，这组操作要么全部发生，要么全部不发生。</p>
<p><strong>C: consistency 一致性</strong><br><br>数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。<br>比如在银行转账操作后两个账户的总额应当不变。</p>
<p><strong>I: isolation 隔离性</strong><br><br>数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响，对于数据库中同时执行的每个事务来说，其他事务要么还没开始执行，要么已经执行结束，它都感觉不到还有别的事务正在执行。</p>
<p><strong>D：durability 持久性</strong><br><br>数据库事务的持久性要求事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。<br>如果事务没有完成，数据库因故断电了，那么重启后也应该是没有执行事务的状态，如果事务已经完成后数据库断电了，那么重启后就应该是事务执行完成后的状态。</p>
<h2 id="（14）什么是脏读，不可重复读和幻读？"><a href="#（14）什么是脏读，不可重复读和幻读？" class="headerlink" title="（14）什么是脏读，不可重复读和幻读？"></a>（14）什么是脏读，不可重复读和幻读？</h2><p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a></p>
<ul>
<li><p>脏读：脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据。</p>
<blockquote>
<p>比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读</p>
</blockquote>
</li>
<li><p>不可重复读：不可重复读是对于数据库中的某一个字段，一个事务多次查询却返回了不同的值，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。</p>
<blockquote>
<p>比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。<br>不可重复读与脏读的不同之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。</p>
</blockquote>
</li>
<li><p>幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。</p>
<blockquote>
<p>比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。<br>不可重复度和幻读的不同之处在于，幻读是多次读取的结果行数不同，不可重复度是读取结果的值不同。</p>
</blockquote>
</li>
</ul>
<p>避免不可重复读需要锁行，避免幻读则需要锁表。</p>
<p>脏读，不可重复读和幻读都是数据库的读一致性问题，是在并行的过程中出现的问题，必须采用一定的隔离级别解决。<br>详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Hakuna-Matata/p/7772794.html">脏读、不可重复读和幻读的区别</a></p>
<h2 id="（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"><a href="#（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）" class="headerlink" title="（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"></a>（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</h2><p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a>和<a target="_blank" rel="noopener" href="https://blog.csdn.net/fg2006/article/details/6937413">数据库隔离级别</a></p>
<p>为了保证数据库事务一致性，解决脏读，不可重复读和幻读的问题，数据库的隔离级别一共有四种隔离级别：</p>
<ul>
<li>读未提交 Read Uncommitted: 最低级别的隔离，不能解决以上问题</li>
<li>读已提交 Read committed:   可以避免脏读的发生 </li>
<li>可重复读 Reapeatable read:  确保事务可以多次从一个字段中读取相同的值，在该事务执行期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读。 通过锁行来实现 </li>
<li>串行化 Serializaion  最严格的事务隔离机制，要求所有事务被串行执行，可以避免以上所有问题。 通过锁表来实现</li>
</ul>
<p>Oracle的默认隔离级别是<strong>读已提交</strong>，实现了四种隔离级别中的读已提交和串行化隔离级别</p>
<p>MySQL的默认隔离级别是<strong>可重复读</strong>，并且实现了所有四种隔离级别</p>
<h2 id="（16）-数据库连接池的作用"><a href="#（16）-数据库连接池的作用" class="headerlink" title="（16） 数据库连接池的作用"></a>（16） 数据库连接池的作用</h2><h2 id="（17）-Mysql的表空间方式，各自特点"><a href="#（17）-Mysql的表空间方式，各自特点" class="headerlink" title="（17） Mysql的表空间方式，各自特点"></a>（17） Mysql的表空间方式，各自特点</h2><ul>
<li>共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 </li>
<li>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题</li>
</ul>
<h2 id="（18）-分布式事务"><a href="#（18）-分布式事务" class="headerlink" title="（18） 分布式事务"></a>（18） 分布式事务</h2><h2 id="（19）-数据库的范式"><a href="#（19）-数据库的范式" class="headerlink" title="（19） 数据库的范式"></a>（19） 数据库的范式</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p>
<ul>
<li><strong>第一范式(确保每列保持原子性)</strong><br><br>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</li>
</ul>
<blockquote>
<p>比如 学生 选课（包括很多课程） 就不符合第一范式</p>
</blockquote>
<ul>
<li><strong>第二范式(确保表中的每列都和主键相关)</strong><br><br>在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。</li>
</ul>
<blockquote>
<p>比如一张学生信息表，由主键（学号）可以唯一确定一个学生的姓名，班级，年龄等信息。但是主键 （学号，班级） 与列 姓名，班主任，教室 就不符合第二范式，因为班主任跟部分主键（班级）是依赖关系</p>
</blockquote>
<ul>
<li><strong>第三范式(确保非主键的列没有传递依赖)</strong><br><br>在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。</li>
</ul>
<blockquote>
<p>比如一张学生信息表，主键是（学号）列包括 姓名，班级，班主任 就不符合第三范式，因为非主键的列中 班主任 依赖于 班级</p>
</blockquote>
<ul>
<li><strong>BCNF范式（确保主键之间没有传递依赖）</strong><br><br>主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。</li>
</ul>
<h2 id="（20）-数据的锁的种类，加锁的方式"><a href="#（20）-数据的锁的种类，加锁的方式" class="headerlink" title="（20） 数据的锁的种类，加锁的方式"></a>（20） 数据的锁的种类，加锁的方式</h2><p>以MYSQL为例，</p>
<ul>
<li>按照类型来分有乐观锁和悲观锁</li>
<li>根据粒度来分有行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁）</li>
<li>根据作用来分有共享锁（读锁）和排他锁（写锁）。</li>
</ul>
<h2 id="（21）-什么是共享锁和排他锁"><a href="#（21）-什么是共享锁和排他锁" class="headerlink" title="（21） 什么是共享锁和排他锁"></a>（21） 什么是共享锁和排他锁</h2><ul>
<li><p>共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。</p>
</li>
<li><p>排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42743933/article/details/81236658">https://blog.csdn.net/qq_42743933/article/details/81236658</a></p>
</li>
</ul>
<h2 id="（22）-分库分表的理解和简介"><a href="#（22）-分库分表的理解和简介" class="headerlink" title="（22） 分库分表的理解和简介"></a>（22） 分库分表的理解和简介</h2><h2 id="（23）数据库高并发的解决方案"><a href="#（23）数据库高并发的解决方案" class="headerlink" title="（23）数据库高并发的解决方案"></a>（23）数据库高并发的解决方案</h2><ol>
<li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li>
<li>增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li>主从读写分离，让主服务器负责写，从服务器负责读。</li>
<li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li>
<li>使用分布式架构，分散计算压力。</li>
</ol>
<h2 id="（24）乐观锁与悲观锁解释一下"><a href="#（24）乐观锁与悲观锁解释一下" class="headerlink" title="（24）乐观锁与悲观锁解释一下"></a>（24）乐观锁与悲观锁解释一下</h2><p>一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。</p>
<p>悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。</p>
<h2 id="（25）乐观锁与悲观锁是怎么实现的"><a href="#（25）乐观锁与悲观锁是怎么实现的" class="headerlink" title="（25）乐观锁与悲观锁是怎么实现的"></a>（25）乐观锁与悲观锁是怎么实现的</h2><p>悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。</p>
<p>悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。</p>
<p>乐观锁有三种常用的实现形式：</p>
<ul>
<li>一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。</li>
<li>一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。</li>
<li>最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。</li>
</ul>
<h2 id="（26）对数据库目前最新技术有什么了解吗"><a href="#（26）对数据库目前最新技术有什么了解吗" class="headerlink" title="（26）对数据库目前最新技术有什么了解吗"></a>（26）对数据库目前最新技术有什么了解吗</h2><h1 id="6-redis"><a href="#6-redis" class="headerlink" title="6. redis"></a>6. redis</h1><h1 id="7-场景题-算法题"><a href="#7-场景题-算法题" class="headerlink" title="7. 场景题&#x2F;算法题"></a>7. 场景题&#x2F;算法题</h1><h2 id="（0）leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！"><a href="#（0）leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！" class="headerlink" title="（0）leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！"></a>（0）leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</h2><p>面试中90%的算法题都从leetcode hot100和剑指offer中出 刷两遍非常有必要</p>
<h2 id="（1）介绍熟悉的设计模式（单例，简单工厂模式）"><a href="#（1）介绍熟悉的设计模式（单例，简单工厂模式）" class="headerlink" title="（1）介绍熟悉的设计模式（单例，简单工厂模式）"></a>（1）介绍熟悉的设计模式（单例，简单工厂模式）</h2><h2 id="（2）写单例模式，线程安全版本"><a href="#（2）写单例模式，线程安全版本" class="headerlink" title="（2）写单例模式，线程安全版本"></a>（2）写单例模式，线程安全版本</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">      <span class="comment">// initialize</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="（3）写三个线程交替打印ABC"><a href="#（3）写三个线程交替打印ABC" class="headerlink" title="（3）写三个线程交替打印ABC"></a>（3）写三个线程交替打印ABC</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mymutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 1: a&quot;</span> &lt;&lt; endl;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;my thread 1 finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">1</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 2: b&quot;</span> &lt;&lt; endl;</span><br><span class="line">        flag = <span class="number">2</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;my thread 2 finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">2</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 3: c&quot;</span> &lt;&lt; endl;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;my thread 3 finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(printa)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(printb)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th3</span><span class="params">(printc)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.<span class="built_in">join</span>();</span><br><span class="line">    th2.<span class="built_in">join</span>();</span><br><span class="line">    th3.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; main thread &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（4）二维码登录的实现过程-场景题"><a href="#（4）二维码登录的实现过程-场景题" class="headerlink" title="（4）二维码登录的实现过程 场景题"></a>（4）二维码登录的实现过程 场景题</h2><p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="（5）不使用临时变量实现swap函数"><a href="#（5）不使用临时变量实现swap函数" class="headerlink" title="（5）不使用临时变量实现swap函数"></a>（5）不使用临时变量实现swap函数</h2><ul>
<li>使用异或&#x2F;加减等方式，下面给出使用异或的实现方法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">  a=a^b;</span><br><span class="line">  b=a^b;</span><br><span class="line">  a=a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（6）实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"><a href="#（6）实现一个strcpy函数（或者memcpy），如果内存可能重叠呢" class="headerlink" title="（6）实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"></a>（6）实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</h2><h2 id="（7）十大排序"><a href="#（7）十大排序" class="headerlink" title="（7）十大排序"></a>（7）十大排序</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://lumingdong.cn/detailed-explanation-of-ten-classic-sorting-algorithms.html">十大经典排序算法详解</a></p>
</blockquote>
<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    vec[a] = vec[a] ^ vec[b];</span><br><span class="line">    vec[b] = vec[a] ^ vec[b];</span><br><span class="line">    vec[a] = vec[a] ^ vec[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = vec[start + (end - start) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end <span class="keyword">and</span> vec[start] &lt; pivot) start++;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end <span class="keyword">and</span> vec[end] &gt; pivot) end--;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end)</span><br><span class="line">            <span class="built_in">swap</span>(vec, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">partition</span>(vec, start, end);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec, start, pivot - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec, pivot + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现一个堆排序"><a href="#实现一个堆排序" class="headerlink" title="实现一个堆排序"></a>实现一个堆排序</h3><p>堆排序的基本过程：</p>
<ul>
<li>将n个元素的序列构建一个大顶堆或小顶堆</li>
<li>将堆顶的元素放到序列末尾</li>
<li>将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</li>
</ul>
<p>整体时间复杂度为nlogn</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    arr[a] = arr[a] ^ arr[b];</span><br><span class="line">    arr[b] = arr[a] ^ arr[b];</span><br><span class="line">    arr[a] = arr[a] ^ arr[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> len, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxid = index;</span><br><span class="line">    <span class="comment">// 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>, right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找当前以index为根的子树中最大/最小的元素的下标</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; len <span class="keyword">and</span> arr[left] &lt; arr[maxid])</span><br><span class="line">        maxid = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len <span class="keyword">and</span> arr[right] &lt; arr[maxid])</span><br><span class="line">        maxid = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行交换，记得要递归进行adjust,传入的index是maxid</span></span><br><span class="line">    <span class="keyword">if</span> (maxid != index) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr, maxid, index);</span><br><span class="line">        <span class="built_in">adjust</span>(arr, len, maxid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (len - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">adjust</span>(arr, len, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr, <span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">adjust</span>(arr, i, <span class="number">0</span>);  <span class="comment">// 注意每次adjust是从根往下调整，所以这里index是0！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : arr) cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">heapsort</span>(arr, arr.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : arr) cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现一个插入排序"><a href="#实现一个插入排序" class="headerlink" title="实现一个插入排序"></a>实现一个插入排序</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/left_la/article/details/8656425">https://blog.csdn.net/left_la/article/details/8656425</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = nums[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; key) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快排存在的问题，如何优化"><a href="#快排存在的问题，如何优化" class="headerlink" title="快排存在的问题，如何优化"></a>快排存在的问题，如何优化</h3><ul>
<li>3 种快排基准选择方法：</li>
</ul>
<p>随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）</p>
<ul>
<li>4种优化方式：</li>
</ul>
<p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</p>
<p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p>
<p>优化3：优化递归操作</p>
<p>优化4：使用并行或多线程处理子序列</p>
<h3 id="希尔排序说一下-手撕"><a href="#希尔排序说一下-手撕" class="headerlink" title="希尔排序说一下&#x2F;手撕"></a>希尔排序说一下&#x2F;手撕</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6104371.html">https://www.cnblogs.com/chengxiao/p/6104371.html</a><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h2 id="（8）反转一个链表（招银网络二面）"><a href="#（8）反转一个链表（招银网络二面）" class="headerlink" title="（8）反转一个链表（招银网络二面）"></a>（8）反转一个链表（招银网络二面）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* root)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>, cur = root, nxt;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        nxt = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（9）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）"><a href="#（9）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）" class="headerlink" title="（9） Top K问题（可以采取的方法有哪些，各自优点？）（重点）"></a>（9） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</h2><p><em>Top K 问题的常见形式：</em></p>
<blockquote>
<p>给定10000个整数，找第K大（第K小）的数<br><br>给定10000个整数，找出最大（最小）的前K个数<br><br>给定100000个单词，求前K词频的单词<br></p>
</blockquote>
<p><em>解决Top K问题若干种方法</em></p>
<ul>
<li>使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。</li>
<li>Quick Select算法。使用类似快排的思路，根据pivot划分数组。</li>
<li>使用排序方法，排序后再寻找top K元素。</li>
<li>使用选择排序的思想，对前K个元素部分排序。</li>
<li>将1000…..个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数。</li>
</ul>
<ol>
<li>使用最大最小堆的思路 （以top K 最大元素为例）<br><br>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</li>
</ol>
<blockquote>
<p>note：最小堆的插入时间复杂度为log(n)，n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p>
</blockquote>
<p>C++中的最大最小堆要用标准库的priority_queue来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> v, <span class="type">int</span> i): <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.value &lt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; pq; <span class="comment">// 此时pq为最大堆</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用Quick Select的思路（以寻找第K大的元素为例）<br><br>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的：<br>首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。<br>此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作；<br>如果左边的数组元素个数等于K-1，则第K大的数就是pivot；<br>如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</li>
</ol>
<p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 此为Java实现</span><br><span class="line">public</span><br><span class="line">int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">    return quickSelect(nums, k, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// quick select to find the kth-largest element</span><br><span class="line">public</span><br><span class="line">int quickSelect(int[] arr, int k, int left, int right) &#123;</span><br><span class="line">    if (left == right)</span><br><span class="line">        return arr[right];</span><br><span class="line">    int index = partition(arr, left, right);</span><br><span class="line">    if (index - left + 1 &gt; k)</span><br><span class="line">        return quickSelect(arr, k, left, index - 1);</span><br><span class="line">    else if (index - left + 1 == k)</span><br><span class="line">        return arr[index];</span><br><span class="line">    else</span><br><span class="line">        return quickSelect(arr, k - (index - left + 1), index + 1, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）<br><br>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K)</li>
</ol>
<h2 id="（10）8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"><a href="#（10）8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）" class="headerlink" title="（10）8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"></a>（10）8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</h2><p>我们可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ailunlee/article/details/84548950">https://blog.csdn.net/ailunlee/article/details/84548950</a></p>
<h2 id="（11）自己构建一棵二叉树，使用带有null标记的前序遍历序列"><a href="#（11）自己构建一棵二叉树，使用带有null标记的前序遍历序列" class="headerlink" title="（11）自己构建一棵二叉树，使用带有null标记的前序遍历序列"></a>（11）自己构建一棵二叉树，使用带有null标记的前序遍历序列</h2><p>在写二叉树相关算法的时候，如果需要自己构造测试用例（自己构造一棵二叉树），往往是一件很麻烦的事情，我们可以用一个带有null标记的前序遍历序列来进行构造。 <strong>需要注意的是vec2tree()参数中的start是引用传递，而不是简单的参数值传递</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treeNode</span> &#123;</span><br><span class="line">    string val;</span><br><span class="line">    treeNode *left, *right;</span><br><span class="line">    <span class="built_in">treeNode</span>(string val) : <span class="built_in">val</span>(val) &#123;</span><br><span class="line">        left = <span class="literal">nullptr</span>;</span><br><span class="line">        right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">treeNode* <span class="title">vec2tree</span><span class="params">(vector&lt;string&gt;&amp; vec, <span class="type">int</span>&amp; start)</span> </span>&#123;</span><br><span class="line">    treeNode* root;</span><br><span class="line">    <span class="keyword">if</span> (vec[start] == <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">        start += <span class="number">1</span>;</span><br><span class="line">        root = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">treeNode</span>(vec[start]);</span><br><span class="line">        start += <span class="number">1</span>;</span><br><span class="line">        root-&gt;left = <span class="built_in">vec2tree</span>(vec, start);</span><br><span class="line">        root-&gt;right = <span class="built_in">vec2tree</span>(vec, start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree2vec</span><span class="params">(treeNode* root, vector&lt;string&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;left, vec);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;right, vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec = &#123;<span class="string">&quot;2&quot;</span>,    <span class="string">&quot;4&quot;</span>,    <span class="string">&quot;5&quot;</span>,    <span class="string">&quot;7&quot;</span>,    <span class="string">&quot;null&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;null&quot;</span>, <span class="string">&quot;null&quot;</span>, <span class="string">&quot;null&quot;</span>, <span class="string">&quot;3&quot;</span>,    <span class="string">&quot;6&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;null&quot;</span>, <span class="string">&quot;null&quot;</span>, <span class="string">&quot;2&quot;</span>,    <span class="string">&quot;null&quot;</span>, <span class="string">&quot;null&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>, &amp;start = index;</span><br><span class="line">    treeNode* root = <span class="built_in">vec2tree</span>(vec, start);</span><br><span class="line">    <span class="comment">// displaytree(root);</span></span><br><span class="line">    vector&lt;string&gt; mvec;</span><br><span class="line">    <span class="built_in">tree2vec</span>(root, mvec);</span><br><span class="line">    <span class="keyword">for</span> (string item : mvec) cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="（12）介绍一下b树和它的应用场景有哪些"><a href="#（12）介绍一下b树和它的应用场景有哪些" class="headerlink" title="（12）介绍一下b树和它的应用场景有哪些"></a>（12）介绍一下b树和它的应用场景有哪些</h2><p>B树也叫做B-树，或者平衡多路树，它是每个节点最多有m个子树的<strong>平衡树</strong>。一个m阶的B树具有如下几个特征：</p>
<ol>
<li>根结点至少有两个子女。</li>
<li>每个中间节点都包含至多m个子树 ， 每个节点包含的元素个数是其子树个数-1（其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m）</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个子树包含的元素的值域分划。</li>
</ol>
<p>b树主要应用于文件系统中，在数据库中（mongoDB）也有应用，与B+树相比好处应该是有时不需要访问到叶节点就可以获取数据。</p>
<p>查询时间复杂度是logN</p>
<h2 id="（13）介绍一下b-树和它的应用场景有哪些"><a href="#（13）介绍一下b-树和它的应用场景有哪些" class="headerlink" title="（13）介绍一下b+树和它的应用场景有哪些"></a>（13）介绍一下b+树和它的应用场景有哪些</h2><p>B+树是一种特殊的B树，它把数据都存储在叶子节点，并且叶节点间有指针连接。内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点。</p>
<p>应用场景主要是数据库的索引</p>
<p>查询时间复杂度也是logN<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110202102">https://zhuanlan.zhihu.com/p/110202102</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hguisu/article/details/7786014">https://blog.csdn.net/hguisu/article/details/7786014</a></p>
<h2 id="（14）介绍一下红黑树和它的应用场景有哪些"><a href="#（14）介绍一下红黑树和它的应用场景有哪些" class="headerlink" title="（14）介绍一下红黑树和它的应用场景有哪些"></a>（14）介绍一下红黑树和它的应用场景有哪些</h2><p>红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。<br>它的性质是这样的：</p>
<ol>
<li>每个节点不是红色就是黑色。</li>
<li>根节点是黑色的。</li>
<li>叶节点的空节点是黑色的。</li>
<li>如果一个节点是红色的，那么它的两个子节点是黑色的。</li>
<li>对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。</li>
</ol>
<p>红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是O(log(n))</p>
<p>应用场景主要是STL中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logN</p>
<h2 id="（15）-怎么写sql取表的前1000行数据（招银网络二面）"><a href="#（15）-怎么写sql取表的前1000行数据（招银网络二面）" class="headerlink" title="（15） 怎么写sql取表的前1000行数据（招银网络二面）"></a>（15） 怎么写sql取表的前1000行数据（招银网络二面）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 limit <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h2 id="（16）-N个骰子出现和为m的概率"><a href="#（16）-N个骰子出现和为m的概率" class="headerlink" title="（16） N个骰子出现和为m的概率"></a>（16） N个骰子出现和为m的概率</h2><h2 id="（17）-海量数据问题（可参考左神的书）"><a href="#（17）-海量数据问题（可参考左神的书）" class="headerlink" title="（17） 海量数据问题（可参考左神的书）"></a>（17） 海量数据问题（可参考左神的书）</h2><h2 id="（18）-一致性哈希"><a href="#（18）-一致性哈希" class="headerlink" title="（18） 一致性哈希"></a>（18） 一致性哈希</h2><h2 id="（19）Dijkstra算法说一下"><a href="#（19）Dijkstra算法说一下" class="headerlink" title="（19）Dijkstra算法说一下"></a>（19）Dijkstra算法说一下</h2><h2 id="（20）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"><a href="#（20）实现一个动态数组要怎么实现，说思路（腾讯teg一面）" class="headerlink" title="（20）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"></a>（20）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</h2><p>模拟STL中vector的实现即可，去看一下vector的源码。</p>
<h2 id="（21）最小生成树算法说一下"><a href="#（21）最小生成树算法说一下" class="headerlink" title="（21）最小生成树算法说一下"></a>（21）最小生成树算法说一下</h2><h2 id="（22）-海量数据的bitmap使用原理"><a href="#（22）-海量数据的bitmap使用原理" class="headerlink" title="（22） 海量数据的bitmap使用原理"></a>（22） 海量数据的bitmap使用原理</h2><p>bitmap算法就是使用一个比特映射一个值，它可以用在整数排序和数据压缩上，因为使用一个比特位去存储一个数，所以它可以大大节省空间。</p>
<p>它的具体过程是：先根据数组中元素最大的数N计算需要分配多大的空间。<br>如果使用int型数组的形式来保存的话，一个int &#x3D; 4字节  &#x3D;4*8比特 &#x3D; 32比特。也就是一个int数可以映射32个数据（图1），然后需要找到最大的数Max，表示最多需要的位数，所以需要开辟的数组空间为int a[1+Max&#x2F;32]。<br>然后需要推导一个整数a内如何映射32个数据，方法是将待存储的数据模32，然后将a中相应位置的比特置为1。<br>依此方法映射每一个元素，待读取的时候扫描每个比特位，遇到值为1的就还原该数字。<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/bitmap1.png"></p>
<p><strong>移位计算公式：</strong><br>N&#x2F;32就是将N的二进制右移log32（也就是5）位 ： N&gt;&gt;5<br><br>N%32就是求N的后5位：N&amp; 0x1F  (0x1F &#x3D; 00011111)<br><br>模32然后相应位置置为1： a[i] |&#x3D; 1&lt;&lt; N &amp; 0x1F<br></p>
<p>所以总的公式为： a[ N&gt;&gt;5 ] |&#x3D; 1&lt;&lt; N &amp; 0x1F<br></p>
<p><strong>BitMap算法评价</strong></p>
<ul>
<li>优点：<ol>
<li>运算效率高，不进行比较和移位；</li>
<li>占用内存少，比如最大的数MAX&#x3D;10000000；只需占用内存为MAX&#x2F;8&#x3D;1250000Byte&#x3D;1.25M。</li>
</ol>
</li>
<li>缺点：<ol>
<li>所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。</li>
<li>所需要的空间随着最大元素的增大而增大，当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</li>
</ol>
</li>
</ul>
<h2 id="（23）-布隆过滤器原理与优点"><a href="#（23）-布隆过滤器原理与优点" class="headerlink" title="（23） 布隆过滤器原理与优点"></a>（23） 布隆过滤器原理与优点</h2><p>布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，用来查找一个元素是否在集合中，支持高效插入和查询某条记录。常作为针对超大数据量下高效查找数据的一种方法。</p>
<p><strong>它的具体工作过程是这样子的：</strong><br>假设布隆过滤器的大小为m（比特向量的长度为m），有k个哈希函数，它对每个数据用这k个哈希函数计算哈希，得到k个哈希值，然后将向量中相应的位设为1。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为1，如果某一个相应的位不为1，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。</p>
<p><strong>为什么说有可能存在呢？</strong><br>因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到1也可能是由于某个另外的数据映射得到的。</p>
<p><strong>支持删除操作吗</strong><br>目前布隆过滤器只支持插入和查找操作，不支持删除操作，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为1则计数加一，删除则减一。</p>
<p>布隆过滤器中哈希函数的个数需要选择。如果太多则很快所有位都置为1，如果太少会容易误报。</p>
<p><strong>布隆过滤器的大小以及哈希函数的个数怎么选择？</strong><br>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png"></p>
<h2 id="（24）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"><a href="#（24）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题" class="headerlink" title="（24） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"></a>（24） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</h2><h2 id="（25）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"><a href="#（25）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）" class="headerlink" title="（25）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"></a>（25）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 评测题目:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFOQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// isFull</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        unique_lock&lt;mutex&gt;&lt;/ mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">        <span class="keyword">while</span> (flag == <span class="literal">true</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        end = (end + <span class="number">1</span>) % initCap;</span><br><span class="line">        vec[end] = v;</span><br><span class="line">        cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unique_lock&lt;mutex&gt;&lt;/ mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">        <span class="keyword">if</span> (start != end) &#123;</span><br><span class="line">            <span class="type">int</span> val = vec[start];</span><br><span class="line">            start = (start + <span class="number">1</span>) % initCap;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            cv.<span class="built_in">notifyall</span>();</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            cv.<span class="built_in">notifyall</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(initCap, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是面试时写的，并没有运行，也许有错误，请客观参考</p>
<h2 id="（26）位图排序"><a href="#（26）位图排序" class="headerlink" title="（26）位图排序"></a>（26）位图排序</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/songzitea/article/details/8759635">位图排序</a></p>
<h1 id="8-智力题"><a href="#8-智力题" class="headerlink" title="8. 智力题"></a>8. 智力题</h1><h2 id="（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"><a href="#（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）" class="headerlink" title="（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"></a>（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）</h2><ul>
<li>（给定了楼层数和鸡蛋数的情况）二分法+线性查找  从100&#x2F;2&#x3D;50楼扔起，如果破了就用另一个从0扔起直到破。如果没破就从50&#x2F;2&#x3D;25楼扔起，重复。</li>
<li>动态规划</li>
</ul>
<h2 id="（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"><a href="#（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠" class="headerlink" title="（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"></a>（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠</h2><p>用二进制的思路解决问题。2的十次方是1024，使用十只小鼠喝一次即可。方法是先将每瓶水编号，同时10个小鼠分别表示二进制中的一个位。将每瓶水混合到水瓶编号中二进制为1的小鼠对应的水中。喝完后统计，将死亡小鼠对应的位置为1，没死的置为0，根据死亡小鼠的编号确定有毒的是哪瓶水，如0000001010表示10号水有毒。</p>
<h2 id="（5）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"><a href="#（5）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿" class="headerlink" title="（5） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"></a>（5） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿</h2><p>寻找每个回合固定的拿取模式。最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。关键是第一次我必须先手拿（100%6&#x3D;4）本（这不算在第一回合里面）。</p>
<h2 id="（6）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"><a href="#（6）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。" class="headerlink" title="（6） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"></a>（6） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。</h2><p>碰到就当没发生，继续走，相当于碰到的两个蚂蚁交换了一下身体。其实就是每个蚂蚁从当前位置一直走直到停止的总距离或者时间。</p>
<h2 id="（7）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"><a href="#（7）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶" class="headerlink" title="（7） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"></a>（7） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶</h2><p>拿走3瓶，换回1瓶，相当于减少2瓶。但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4&#x3D;996，996&#x2F;2&#x3D;498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1&#x3D;1499瓶。</p>
<h2 id="（8）在24小时里面时针分针秒针可以重合几次"><a href="#（8）在24小时里面时针分针秒针可以重合几次" class="headerlink" title="（8）在24小时里面时针分针秒针可以重合几次"></a>（8）在24小时里面时针分针秒针可以重合几次</h2><p>24小时中时针走2圈，而分针走24圈，时针和分针重合24-2&#x3D;22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次</p>
<h2 id="（9）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"><a href="#（9）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？" class="headerlink" title="（9） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"></a>（9） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？</h2><p>至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；<br>第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；</p>
<h2 id="（10）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"><a href="#（10）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？" class="headerlink" title="（10） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"></a>（10） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？</h2><p>砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y &#x3D; 550 - x，第y组就是轻的那组</p>
<h2 id="（11）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？"><a href="#（11）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？" class="headerlink" title="（11）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？"></a>（11）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</h2><p>思路：由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。<br>记住下面这个式子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandNN= N( RandN()-1 ) + RandN() ;// 生成1到N^2之间的随机数</span><br><span class="line">可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度，RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙</span><br></pre></td></tr></table></figure>

<p>比如<code> Rand25= 5( Rand5()-1 ) + Rand5()</code>可以生成1到25之间的随机数。我们可以只要1到21（3*7）之间的数字，所以可以这么写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rand7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">21</span>) &#123;</span><br><span class="line">        x = <span class="number">5</span> * (<span class="built_in">rand5</span>() - <span class="number">1</span>) + <span class="built_in">rand5</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">7</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（12）赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"><a href="#（12）赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？" class="headerlink" title="（12）赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"></a>（12）赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？</h2><ul>
<li>第一次，分成5个赛道ABCDE，每个赛道5匹马，每个赛道比赛一场，每个赛道的第12345名记为 A1,A2,A3,A4,A5  B1,B2,B3,B4,B5等等，这一步要赛5场。 </li>
<li>第二次，我们将每个赛道的前三名，共15匹。分成三组，然后每组进行比赛。这一步要赛3场。</li>
<li>第三次，我们取每组的前三名。共9匹，第一名赛道的马编号为1a,1b,1c，第二名赛道的马编号为2a,2b,2c，第三名赛道的马编号为3a,3b,3c。这时进行分析，1a表示第一名里面的第一名，绝对是所有马中的第一，所以不用再比了。2c表示第二名的三匹里头的最后一匹，3b和3c表示第三名里面的倒数两匹，不可能是所有马里面的前三名，所以也直接排除，剩下1b,1c,2a,2b,,3a，共5匹，再赛跑一次取第一第二名，加上刚筛选出来的1a就是所有马里面的最快3匹了。这一步要赛1场。</li>
<li>所以一共是5+3+1&#x3D;9场。</li>
</ul>
<h2 id="（13）烧-香-绳子-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"><a href="#（13）烧-香-绳子-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？" class="headerlink" title="（13）烧 香&#x2F;绳子&#x2F;其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"></a>（13）烧 香&#x2F;绳子&#x2F;其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？</h2><p>（说了求15分钟，没说开始的15分钟还是结束的15分钟，这里是可以求最后的15分钟）点燃一根A，同时点燃另一根B的两端，当另一根B烧完的时候就是半小时，这是再将A的另一端也点燃，从这时到A燃烧完就正好15分钟。</p>
<h2 id="（13）掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"><a href="#（13）掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）" class="headerlink" title="（13）掰巧克力问题 NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"></a>（13）掰巧克力问题 N<em>M块巧克力，每次掰一块的一行或一列，掰成1</em>1的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）</h2><p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有N*M块，所以要掰N*M-1次，-1是因为最开始的一块是不用算进去的。</p>
<p>每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1&#x3D;999场。</p>
<h1 id="9-大数据（暂时不用）"><a href="#9-大数据（暂时不用）" class="headerlink" title="9. 大数据（暂时不用）"></a>9. 大数据（暂时不用）</h1><h2 id="1-介绍一下Hadoop"><a href="#1-介绍一下Hadoop" class="headerlink" title="1. 介绍一下Hadoop"></a>1. 介绍一下Hadoop</h2><p>Hadoop是一套大数据解决方案，提供了一套分布式的系统基础架构，包括HDFS，MapReduce和YARN。</p>
<ul>
<li>HDFS提供分布式的数据存储</li>
<li>MapReduce负责进行数据运算 </li>
<li>YARN负责任务调度</li>
</ul>
<p>HDFS是主从架构的，包括namenode，secondarynamenode和datanode。datanode负责存储数据，namenode负责管理HDFS的目录树和文件元信息。<br><br>MapReduce包括jobtracker,tasktracker和client。Jobtracker负责进行资源调度和作业监控。tasktracker会周期性的通过心跳向jobtracker汇报资源使用情况。</p>
<h2 id="2-说一下MapReduce的运行机制"><a href="#2-说一下MapReduce的运行机制" class="headerlink" title="2. 说一下MapReduce的运行机制"></a>2. 说一下MapReduce的运行机制</h2><p>MapReduce包括输入分片、map阶段、combine阶段、shuffle阶段和reduce阶段。分布式计算框架包括client，jobtracker和tasktracker和调度器。</p>
<ul>
<li>输入分片阶段，mapreduce会根据输入文件计算分片，每个分片对应一个map任务</li>
<li>map阶段会根据mapper方法的业务逻辑进行计算，映射成键值对</li>
<li>combine阶段是在节点本机进行一个reduce，减少传输结果对带宽的占用</li>
<li>shuffle阶段是对map阶段的结果进行分区，排序，溢出然后写入磁盘。将map端输出的无规则的数据整理成为有一定规则的数据，方便reduce端进行处理，有点像洗牌的逆过程。  <a target="_blank" rel="noopener" href="https://blog.csdn.net/ASN_forever/article/details/81233547">https://blog.csdn.net/ASN_forever/article/details/81233547</a></li>
<li>reduce阶段是根据reducer方法的业务逻辑进行计算，最终结果会存在hdfs上。</li>
</ul>
<h2 id="3-介绍一下kafka"><a href="#3-介绍一下kafka" class="headerlink" title="3. 介绍一下kafka"></a>3. 介绍一下kafka</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29186199/article/details/80827085">https://blog.csdn.net/qq_29186199/article/details/80827085</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/student__software/article/details/81486431">https://blog.csdn.net/student__software/article/details/81486431</a></p>
<p>kafka是一个分布式消息队列，包括producer、broker和consumer。kafka会对每个消息根据topic进行归类，每个topic又会分成多个partition，消息会根据先进先出的方式存储。消费者通过offset进行消费。 </p>
<p>kafka的特点是吞吐量高，可以进行持久化，高可用。</p>
<h2 id="4-为什么kafka吞吐量高？-介绍一下零拷贝"><a href="#4-为什么kafka吞吐量高？-介绍一下零拷贝" class="headerlink" title="4. 为什么kafka吞吐量高？&#x2F;介绍一下零拷贝"></a>4. 为什么kafka吞吐量高？&#x2F;介绍一下零拷贝</h2><p>kafka吞吐量高是因为一个利用了磁盘顺序读写的特性，速度比随机读写要快很多，另一个是使用了零拷贝，数据直接在内核进行输入和输出，减少了用户空间和内核空间的切换。</p>
<p>零拷贝：传统文件读取并发送至网络的步骤是：先将文件从磁盘拷贝到内核空间，然后内核空间拷贝到用户空间的缓冲区，再从用户空间拷贝到内核空间的socket缓冲区，最后拷贝到网卡并发送。而零拷贝技术是先将文件从磁盘空间拷贝到内核缓冲区，然后直接拷贝至网卡进行发送，减少了重复拷贝操作。</p>
<h2 id="5-介绍一下spark"><a href="#5-介绍一下spark" class="headerlink" title="5. 介绍一下spark"></a>5. 介绍一下spark</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011204847/article/details/51010205">https://blog.csdn.net/u011204847/article/details/51010205</a></p>
<p>spark是一个通用内存并行计算框架。它可以在内存中对数据进行计算，效率很高，spark的数据被抽象成RDD（弹性分布式数据集）并且拥有DAG执行引擎，兼容性和通用性很好。可以和Hadoop协同工作。</p>
<h2 id="6-介绍一下spark-streaming"><a href="#6-介绍一下spark-streaming" class="headerlink" title="6. 介绍一下spark-streaming"></a>6. 介绍一下spark-streaming</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yu0_zhang0/article/details/80569946">https://blog.csdn.net/yu0_zhang0/article/details/80569946</a></p>
<p>spark-streaming是spark的核心组件之一。主要提供高效的流计算能力。spark-streaming的原理是将输入数据流以时间片进行拆分，然后经过spark引擎以类似批处理的方式处理每个时间片数据。</p>
<p>spark-streaming将输入根据时间片划分成一段一段的Dstream（也就是离散数据流），然后将每一段数据转换成RDD进行操作。 </p>
<h2 id="7-spark的transformation和action有什么区别"><a href="#7-spark的transformation和action有什么区别" class="headerlink" title="7. spark的transformation和action有什么区别"></a>7. spark的transformation和action有什么区别</h2><p>spark的算子分成transformation和action两类</p>
<ul>
<li>transformation是变换算子，这类算子不会触发提交，是延迟执行的。也就是说执行到transformation算子的时候数据并没有马上进行计算，只是记住了对RDD的逻辑操作 </li>
<li>action算子是执行算子，会出发spark提交作业，并将数据输出到spark</li>
</ul>
<h2 id="8-spark常用的算子说几个"><a href="#8-spark常用的算子说几个" class="headerlink" title="8. spark常用的算子说几个"></a>8. spark常用的算子说几个</h2><p>spark的算子分为两类：transformation和action</p>
<p>常用的transformation算子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union 求并集</span></span><br><span class="line"><span class="keyword">val</span> rdd8 = rdd6.union(rdd7)</span><br><span class="line"></span><br><span class="line"><span class="comment">// intersection 求交集 </span></span><br><span class="line"><span class="keyword">val</span> rdd9 = rdd6.intersection(rdd7)</span><br><span class="line"></span><br><span class="line"><span class="comment">// join 将rdd进行聚合连接，类似数据库的join </span></span><br><span class="line"><span class="keyword">val</span> rdd3 = rdd1.join(rdd2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map flatMap mapPartition 传入一个函数对数据集中的每一个数据进行操作 </span></span><br><span class="line"><span class="keyword">val</span> arr1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> arr2 = rdd1.map(_+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// countByKey reduceByKey partitionByKey 统计每个key有多少个键值对 </span></span><br></pre></td></tr></table></figure>

<p>常用的action算子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce 按照一定的方法将元素进行合并 </span></span><br><span class="line"><span class="keyword">val</span> rdd2 = rdd1.reduce(_+_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// collect 将RDD转换为数组</span></span><br><span class="line">rdd1.collect</span><br><span class="line"></span><br><span class="line"><span class="comment">// top 返回最大的k个元素</span></span><br><span class="line">rdd1.top(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="9-如何保证kafka的消息不丢失"><a href="#9-如何保证kafka的消息不丢失" class="headerlink" title="9. 如何保证kafka的消息不丢失"></a>9. 如何保证kafka的消息不丢失</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liudashuang2017/article/details/88576274">https://blog.csdn.net/liudashuang2017/article/details/88576274</a></p>
<p>我们可以从三个方面保证kafka不丢失消息</p>
<ul>
<li>首先从producer生产者方面，为send()方法注册一个回调函数，可以得知消息发送有没有成功；将重试次数retrie设置为3；设置acks参数为all，当消息被写入所有同步副本之后才算发送成功。</li>
<li>在consumer消费者方面，关闭自动提交；</li>
<li>在broker集群方面，设置复制系数replica.factor为大于等于3</li>
</ul>
<h2 id="10-kafka如何选举leader"><a href="#10-kafka如何选举leader" class="headerlink" title="10. kafka如何选举leader"></a>10. kafka如何选举leader</h2><p>首先启动的broker在zookeeper中创建一个临时节点并让自己称为leader，其他的节点会创建watch对象进行监听并成为follower，当broker宕机的时候，其他follower会尝试创建这个临时节点，但是只有一个能够创建成功，创建成功的broker就会成为leader。</p>
<h2 id="11-说下spark中的宽依赖和窄依赖"><a href="#11-说下spark中的宽依赖和窄依赖" class="headerlink" title="11. 说下spark中的宽依赖和窄依赖"></a>11. 说下spark中的宽依赖和窄依赖</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a1043498776/article/details/54889922">https://blog.csdn.net/a1043498776/article/details/54889922</a></p>
<ul>
<li>宽依赖：指子RDD的分区依赖于父RDD的所有分区，举例：groupbykey,join</li>
<li>窄依赖：指父RDD的每个分区被最多一个子RDD的分区所依赖,举例：map，filter<br><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/SouthEast.png"></li>
</ul>
<h2 id="12-说下spark中stage是依照什么划分的"><a href="#12-说下spark中stage是依照什么划分的" class="headerlink" title="12. 说下spark中stage是依照什么划分的"></a>12. 说下spark中stage是依照什么划分的</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57124273">https://zhuanlan.zhihu.com/p/57124273</a></p>
<p>spark中的stage其实是一组并行的任务，spark会将多个RDD根据依赖关系划分成有向无环图DAG，DAG会被划分成多个stage，划分的依据是RDD之间的宽窄依赖。遇到宽依赖就划分stage。因为宽依赖与窄依赖的区别之一就是宽依赖会发生shuffle操作，所以也可以说stage的划分依据是是否发生shuffle操作。</p>
<h2 id="13-spark的内存管理是怎样的"><a href="#13-spark的内存管理是怎样的" class="headerlink" title="13. spark的内存管理是怎样的"></a>13. spark的内存管理是怎样的</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4f1e551553ae">https://www.jianshu.com/p/4f1e551553ae</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wzj4858/p/8204282.html">https://www.cnblogs.com/wzj4858/p/8204282.html</a></p>
<p>spark的内存包括静态内存管理和统一内存管理两种机制。静态内存管理中存储和执行两块内存区域是分开的，统一内存管理中两块内存之间可以相互借用<br></p>
<ul>
<li>静态内存管理：静态内存管理机制下堆内内存包括安全内存，存储内存，shuffle内存和unroll内存</li>
</ul>
<p><img src="/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88.assets/spark%E5%86%85%E5%AD%98%E4%B8%80.png"></p>
<ul>
<li>统一内存管理：统一内存管理机制下内存分为spark内存，用户内存和保留内存三部分。用户内存存放用户代码逻辑和自定义数据结构等，保留内存存放的是spark的内部对象和逻辑。<br><img src="https://upload-images.jianshu.io/upload_images/195230-f119edabb5683f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></li>
</ul>
<h2 id="14-spark的容错机制是什么样的"><a href="#14-spark的容错机制是什么样的" class="headerlink" title="14. spark的容错机制是什么样的"></a>14. spark的容错机制是什么样的</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dengxing1234/article/details/73613484">https://blog.csdn.net/dengxing1234/article/details/73613484</a></p>
<p>spark的容错机制是通过血统（lineage）和checkpoint来实现的 。</p>
<ul>
<li>RDD的lineage可以看作是一个重做日志（redo log）记录的是它粗粒度上的transformation操作。当rdd的分区数据丢失时，它可以根据lineage重新计算来恢复数据。 在窄依赖上可以直接计算父RDD的节点数据进行恢复，在宽依赖上则要等到父RDD所有数据计算完后并将结果shuffle到子RDD上才能完成恢复。</li>
<li>如果DAG中的lineage过长，或者在宽依赖上进行checkpoint的收益更大，就会使用checkpoint进行容错，将RDD写入磁盘进行持久化存储，如果节点数据丢失，就从磁盘读取数据进行恢复。</li>
</ul>
<h1 id="10-HR面"><a href="#10-HR面" class="headerlink" title="10. HR面"></a>10. HR面</h1><h2 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h2><p>（HR面试的自我介绍可以侧重软实力部分，项目技术方面介绍可以适当少一些）</p>
<h2 id="2-项目中遇到的最大难点"><a href="#2-项目中遇到的最大难点" class="headerlink" title="2. 项目中遇到的最大难点"></a>2. 项目中遇到的最大难点</h2><ul>
<li><p>在项目中曾经遇到了新的框架不知道该如何上手的问题，以及面对新的概念，新的技术不知道从何学起。解决的办法是在官网寻找说明文档和demo，按照说明文档上的内容一步步了解，以及咨询身边有用过这个框架的同学，或者在CSDN上寻找相关博客。</p>
</li>
<li><p>项目的时间比较紧迫，没有那么多的时间可以用。解决方法是把还没有完成的项目分一个轻重缓急，在有限的时间里，先做重要而且紧急的，然后完成紧急的，再做重要的。利用轻重缓急做一个取舍。</p>
</li>
</ul>
<h2 id="3-项目中的收获"><a href="#3-项目中的收获" class="headerlink" title="3. 项目中的收获"></a>3. 项目中的收获</h2><p>一个是了解了相关框架的使用方法（比如Dataframe的使用，xgboost的使用等等），这些框架或者技术可以在以后的开发中使用到。和对自己开发能力的锻炼。</p>
<p>一个是锻炼了与他人的交流能力，因为在团队项目里经常会跟别人汇报自己的想法和进度，同时也会跟其他成员沟通模块之间的交互，所以在这个过程中对自己的表达能力和理解能力都是一个很大的提升。</p>
<h2 id="4-可以实习的时间，实习时长"><a href="#4-可以实习的时间，实习时长" class="headerlink" title="4. 可以实习的时间，实习时长"></a>4. 可以实习的时间，实习时长</h2><p>一定要往长了说！半年起步，最好七八个月，因为实习生是可以随时跑路的。而且实习时间越长HR越青睐。</p>
<h2 id="5-哪里人"><a href="#5-哪里人" class="headerlink" title="5. 哪里人"></a>5. 哪里人</h2><h2 id="6-说一下自己的性格"><a href="#6-说一下自己的性格" class="headerlink" title="6. 说一下自己的性格"></a>6. 说一下自己的性格</h2><p>我是比较内向谨慎的人，平时做的多说的少。比较善于总结，在与人交流的时候更倾向于倾听别人的意见后才发言。并且别人都说我办事认真靠谱。</p>
<h2 id="7-你的优缺点是什么"><a href="#7-你的优缺点是什么" class="headerlink" title="7. 你的优缺点是什么"></a>7. 你的优缺点是什么</h2><p>我的缺点是容易在一些细节的地方花费太多的时间，有时候过分追求细节。并且我的实习经验比较缺乏，对于实际项目的业务流程和工作流程不是很了解。（所以我打算通过实习来熟悉实际的软件开发的流程和技术。）</p>
<p>我的优点是责任心比较强，做事比较负责，在校期间我负责的大创项目进展很顺利，我经常组织组员们进行讨论和推进项目的开发，最后这个项目得到了92的评分，在同级别里面是比较高的。</p>
<h2 id="8-有什么兴趣爱好，画的怎么样-球打的如何-游戏打的怎么样"><a href="#8-有什么兴趣爱好，画的怎么样-球打的如何-游戏打的怎么样" class="headerlink" title="8. 有什么兴趣爱好，画的怎么样&#x2F;球打的如何&#x2F;游戏打的怎么样"></a>8. 有什么兴趣爱好，画的怎么样&#x2F;球打的如何&#x2F;游戏打的怎么样</h2><p>平时的爱好是画画打游戏，在CSDN写写博客，还有就是看书，我很喜欢学到新知识掌握新技能的感觉。</p>
<h2 id="9-看过最好的一本书是什么"><a href="#9-看过最好的一本书是什么" class="headerlink" title="9. 看过最好的一本书是什么"></a>9. 看过最好的一本书是什么</h2><p>技术类：编程之美 机器学习西瓜书 STL源码剖析 剑指offer C++primer</p>
<p>非技术类：明朝那些事儿 香水（聚斯金德） 解忧杂货店 人类简史 沉默的大多数 与时间做朋友（李笑来） 千年历史千年诗</p>
<h2 id="10-学习技术中有什么难点"><a href="#10-学习技术中有什么难点" class="headerlink" title="10. 学习技术中有什么难点"></a>10. 学习技术中有什么难点</h2><h2 id="11-怎么看待加班"><a href="#11-怎么看待加班" class="headerlink" title="11. 怎么看待加班"></a>11. 怎么看待加班</h2><p>我觉得 任何一家单位都有可能要加班。如果自己的工作没有按时完成，那自觉加班是理所当然的，当然，自己要不断提高工作效率，避免这种原因导致的加班。如果遇到紧急任务或者突发状况时，为了顺利配合团队完成任务，我会尽自己所能加班共同完成。</p>
<h2 id="12-觉得深圳怎么样（或者其他地点）"><a href="#12-觉得深圳怎么样（或者其他地点）" class="headerlink" title="12. 觉得深圳怎么样（或者其他地点）"></a>12. 觉得深圳怎么样（或者其他地点）</h2><h2 id="13-遇见过最大的挫折是什么，怎么解决的"><a href="#13-遇见过最大的挫折是什么，怎么解决的" class="headerlink" title="13. 遇见过最大的挫折是什么，怎么解决的"></a>13. 遇见过最大的挫折是什么，怎么解决的</h2><h2 id="14-职业规划"><a href="#14-职业规划" class="headerlink" title="14. 职业规划"></a>14. 职业规划</h2><p>在工作的第一个阶段，先尽快适应工作的环境，包括开发环境开发工具和工作流程等，把自己负责的部分快速的完成，不能出差错。第二个阶段要熟悉整个项目的业务流程，所有模块的结构和依赖关系，知道每个模块为什么要这么设计，以及它们的实现细节。第三个阶段要培养独立设计一个项目的能力，可以独立或者在别人的协作下设计项目的模块分工和架构。</p>
<p>在工作和项目中多写博客或者笔记，积累技术影响力，将经验总结成文档。同时与同事搞好关系，尝试培养领导能力和组织能力。</p>
<h2 id="15-目前的offer情况"><a href="#15-目前的offer情况" class="headerlink" title="15. 目前的offer情况"></a>15. 目前的offer情况</h2><p>可以如实说</p>
<h2 id="16-你最大的优势和劣势是什么"><a href="#16-你最大的优势和劣势是什么" class="headerlink" title="16. 你最大的优势和劣势是什么"></a>16. 你最大的优势和劣势是什么</h2><h2 id="17-介绍在项目里面充当的角色"><a href="#17-介绍在项目里面充当的角色" class="headerlink" title="17. 介绍在项目里面充当的角色"></a>17. 介绍在项目里面充当的角色</h2><h2 id="18-介绍一下本科获得的全国赛奖项的情况"><a href="#18-介绍一下本科获得的全国赛奖项的情况" class="headerlink" title="18. 介绍一下本科获得的全国赛奖项的情况"></a>18. 介绍一下本科获得的全国赛奖项的情况</h2><h2 id="19-最有成就感的事情-最骄傲的一件事情"><a href="#19-最有成就感的事情-最骄傲的一件事情" class="headerlink" title="19. 最有成就感的事情&#x2F;最骄傲的一件事情"></a>19. 最有成就感的事情&#x2F;最骄傲的一件事情</h2><h2 id="20-在实验室中担任什么角色，参加的XXX能聊聊吗"><a href="#20-在实验室中担任什么角色，参加的XXX能聊聊吗" class="headerlink" title="20. 在实验室中担任什么角色，参加的XXX能聊聊吗"></a>20. 在实验室中担任什么角色，参加的XXX能聊聊吗</h2><h2 id="21-如何学习的"><a href="#21-如何学习的" class="headerlink" title="21.如何学习的"></a>21.如何学习的</h2><h2 id="22-用两个词来形容自己"><a href="#22-用两个词来形容自己" class="headerlink" title="22. 用两个词来形容自己"></a>22. 用两个词来形容自己</h2><p>踏实 认真</p>
<h1 id="看阿秀补充知识——不需要背，相同跳过，重要记录，其他了解"><a href="#看阿秀补充知识——不需要背，相同跳过，重要记录，其他了解" class="headerlink" title="看阿秀补充知识——不需要背，相同跳过，重要记录，其他了解"></a>看阿秀补充知识——不需要背，相同跳过，重要记录，其他了解</h1><ul>
<li><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</strong></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://estrellaxiaoyu.github.io">Estrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://estrellaxiaoyu.github.io/2023/07/25/C++%E9%9D%A2%E7%BB%8F/">https://estrellaxiaoyu.github.io/2023/07/25/C++%E9%9D%A2%E7%BB%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://estrellaxiaoyu.github.io" target="_blank">Estrella博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/%E7%AC%94%E8%AE%B0p1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/07/25/Effective%20C++/" title="Effective C++笔记"><img class="cover" src="/./img/%E7%AC%94%E8%AE%B0p2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Effective C++笔记</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/%E5%A4%B4%E5%83%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Estrella</div><div class="author-info__description">hi，欢迎你来到我的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Estrellaxiaoyu" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:estrellaxiaoyu@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Estrella的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-C-C-over"><span class="toc-number">1.</span> <span class="toc-text">1. 语言基础 (C&#x2F;C++)&#x3D;&#x3D;over&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%880%EF%BC%89-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">（0） 指针和引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9C%A8%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E5%A0%86%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">（2） 堆和栈有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%A0%86%E5%BF%AB%E4%B8%80%E7%82%B9%E8%BF%98%E6%98%AF%E6%A0%88%E5%BF%AB%E4%B8%80%E7%82%B9%EF%BC%9F%EF%BC%88%E5%AD%97%E8%8A%82%E6%8F%90%E5%89%8D%E6%89%B9%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">（3）堆快一点还是栈快一点？（字节提前批一面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8Cnew-%E4%B8%8E-malloc%E7%9A%84%E5%BC%82%E5%90%8C%E5%A4%84"><span class="toc-number">1.5.</span> <span class="toc-text">（4） new和delete是如何实现的，new 与 malloc的异同处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86malloc-free%EF%BC%8CC-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81new-delete%E5%91%A2%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">（5）既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-C%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">（6） C和C++的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89delete%E5%92%8Cdelete-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.</span> <span class="toc-text">（7）delete和delete[]的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-C-%E3%80%81Java%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%AD%89%EF%BC%88java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%889%EF%BC%89C-%E5%92%8Cpython%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.</span> <span class="toc-text">（9）C++和python的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89-struct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.</span> <span class="toc-text">（10） struct和class的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89-define-%E5%92%8Cconst%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%81%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%AD%89%EF%BC%89"><span class="toc-number">1.12.</span> <span class="toc-text">（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89-%E5%9C%A8C-%E4%B8%ADconst%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%94%A8%E9%80%94%EF%BC%89"><span class="toc-number">1.13.</span> <span class="toc-text">（12） 在C++中const的用法（定义，用途）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89-C-%E4%B8%AD%E7%9A%84static%E7%94%A8%E6%B3%95%E5%92%8C%E6%84%8F%E4%B9%89"><span class="toc-number">1.14.</span> <span class="toc-text">（13） C++中的static用法和意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89-%E8%AE%A1%E7%AE%97%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9A"><span class="toc-number">1.15.</span> <span class="toc-text">（14） 计算下面几个类的大小：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89-C-%E7%9A%84STL%E4%BB%8B%E7%BB%8D%EF%BC%88%E8%BF%99%E4%B8%AA%E7%B3%BB%E5%88%97%E4%B9%9F%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BE%AF%E6%8D%B7%E8%80%81%E5%B8%88%E7%9A%84%E8%BF%99%E6%96%B9%E9%9D%A2%E7%9A%84%E4%B9%A6%E7%B1%8D%E4%B8%8E%E8%A7%86%E9%A2%91%EF%BC%89%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E6%8B%AC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86allocator%EF%BC%8C%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%AD%89"><span class="toc-number">1.16.</span> <span class="toc-text">（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89-STL%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84hash%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.17.</span> <span class="toc-text">（16） STL源码中的hash表的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8817%EF%BC%89%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">（17）解决哈希冲突的方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8818%EF%BC%89-STL%E4%B8%ADunordered-map%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.19.</span> <span class="toc-text">（18） STL中unordered_map和map的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8819%EF%BC%89-STL%E4%B8%ADvector%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.20.</span> <span class="toc-text">（19） STL中vector的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8820%EF%BC%89-vector%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%E5%8F%8A%E5%85%B6%E5%8E%9F%E5%9B%A0%EF%BC%8C%E9%A2%91%E7%B9%81%E5%AF%B9vector%E8%B0%83%E7%94%A8push-back-%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E5%8E%9F%E5%9B%A0%E3%80%82"><span class="toc-number">1.21.</span> <span class="toc-text">（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8821%EF%BC%89C-%E4%B8%ADvector%E5%92%8Clist%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.22.</span> <span class="toc-text">（21）C++中vector和list的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8822%EF%BC%89-C-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.23.</span> <span class="toc-text">（22） C++中的重载和重写的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89-C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E7%83%AD%E9%97%A8%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">1.24.</span> <span class="toc-text">（23） C ++内存管理（热门问题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89-%E4%BB%8B%E7%BB%8D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%AF%8F%E4%B8%80%E4%B8%AA%E3%80%82"><span class="toc-number">1.25.</span> <span class="toc-text">（24） 介绍面向对象的三大特性，并且举例说明每一个。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%92%8C%E4%B8%8B%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%80%E8%B5%B7%E5%9B%9E%E7%AD%94%EF%BC%89"><span class="toc-number">1.26.</span> <span class="toc-text">（25） 多态的实现（和下个问题一起回答）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8826%EF%BC%89-C-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%EF%BC%88%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E7%83%AD%E9%97%A8%EF%BC%8C%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.27.</span> <span class="toc-text">（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8827%EF%BC%89-%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%84%E7%90%86%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">1.28.</span> <span class="toc-text">（27） 编译器如何处理处理虚函数表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8828%EF%BC%89-%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.29.</span> <span class="toc-text">（28） 基类的析构函数一般写成虚函数的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8829%EF%BC%89-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E8%88%AC%E4%B8%8D%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.30.</span> <span class="toc-text">（29） 构造函数为什么一般不定义为虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8830%EF%BC%89-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">1.31.</span> <span class="toc-text">（30） 构造函数或者析构函数中调用虚函数会怎样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8831%EF%BC%89-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.32.</span> <span class="toc-text">（31） 纯虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8832%EF%BC%89-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.33.</span> <span class="toc-text">（32） 静态绑定和动态绑定的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8833%EF%BC%89-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%89"><span class="toc-number">1.34.</span> <span class="toc-text">（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8834%EF%BC%89-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">1.35.</span> <span class="toc-text">（34） 对象复用的了解，零拷贝的了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8835%EF%BC%89-%E4%BB%8B%E7%BB%8DC-%E6%89%80%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.36.</span> <span class="toc-text">（35） 介绍C++所有的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8836%EF%BC%89-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%89"><span class="toc-number">1.37.</span> <span class="toc-text">（36） 什么情况下会调用拷贝构造函数（三种情况）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8837%EF%BC%89-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%92%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-number">1.38.</span> <span class="toc-text">（37） 结构体内存对齐方式和为什么要进行内存对齐？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8838%EF%BC%89%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">1.39.</span> <span class="toc-text">（38）内存泄漏的定义，产生原因，如何检测与避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8839%EF%BC%89-C-%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.40.</span> <span class="toc-text">（39） C++的智能指针有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8840%EF%BC%89-%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.41.</span> <span class="toc-text">（40） 调试程序的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8841%EF%BC%89-%E9%81%87%E5%88%B0coredump%E8%A6%81%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95"><span class="toc-number">1.42.</span> <span class="toc-text">（41） 遇到coredump要怎么调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8842%EF%BC%89-inline%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%B4%E4%B8%80%E4%B8%8B-%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.43.</span> <span class="toc-text">（42） inline关键字说一下 和宏定义有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8843%EF%BC%89-%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.44.</span> <span class="toc-text">（43） 模板的用法与适用场景 实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8844%EF%BC%89-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%BC%9A%E5%BF%AB%E4%B8%80%E4%BA%9B%EF%BC%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF%EF%BC%89%EF%BC%9F"><span class="toc-number">1.45.</span> <span class="toc-text">（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8845%EF%BC%89-%E7%94%A8%E8%BF%87C11%E5%90%97%EF%BC%8C%E7%9F%A5%E9%81%93C11%E6%96%B0%E7%89%B9%E6%80%A7%E5%90%97%EF%BC%9F%EF%BC%88%E6%9C%89%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BB%BA%E8%AE%AE%E7%86%9F%E6%82%89C11%EF%BC%89"><span class="toc-number">1.46.</span> <span class="toc-text">（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8846%EF%BC%89C-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%8B%E6%A0%88%E8%BF%87%E7%A8%8B"><span class="toc-number">1.47.</span> <span class="toc-text">（46）C++函数调用的压栈过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8847%EF%BC%89-C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.48.</span> <span class="toc-text">（47） C++的四种强制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8848%EF%BC%89string%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.49.</span> <span class="toc-text">（48）string的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8849%EF%BC%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B%E6%88%96%E8%80%85%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">1.50.</span> <span class="toc-text">（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">1.50.1.</span> <span class="toc-text">（1）预编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%BC%96%E8%AF%91"><span class="toc-number">1.50.2.</span> <span class="toc-text">（2）编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%B1%87%E7%BC%96"><span class="toc-number">1.50.3.</span> <span class="toc-text">（3）汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E9%93%BE%E6%8E%A5"><span class="toc-number">1.50.4.</span> <span class="toc-text">（4）链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8850%EF%BC%89set%EF%BC%8Cmap%E5%92%8Cvector%E7%9A%84%E6%8F%92%E5%85%A5%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.51.</span> <span class="toc-text">（50）set，map和vector的插入复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8851%EF%BC%89%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.52.</span> <span class="toc-text">（51）定义和声明的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8852%EF%BC%89typdef%E5%92%8Cdefine%E5%8C%BA%E5%88%AB"><span class="toc-number">1.53.</span> <span class="toc-text">（52）typdef和define区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8853%EF%BC%89%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">1.54.</span> <span class="toc-text">（53）被free回收的内存是立即返还给操作系统吗？为什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8854%EF%BC%89%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.55.</span> <span class="toc-text">（54）引用作为函数参数以及返回值的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8855%EF%BC%89%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">1.56.</span> <span class="toc-text">（55）友元函数和友元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8856%EF%BC%89%E8%AF%B4%E4%B8%80%E4%B8%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.57.</span> <span class="toc-text">（56）说一下volatile关键字的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8857%EF%BC%89STL%E4%B8%AD%E7%9A%84sort-%E7%AE%97%E6%B3%95%E6%98%AF%E7%94%A8%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8Cstable-sort-%E5%91%A2%E2%80%94%E2%80%94-%E5%92%8C%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E5%86%8D%E7%BB%93%E5%90%88%E7%9C%8B"><span class="toc-number">1.58.</span> <span class="toc-text">（57）STL中的sort()算法是用什么实现的，stable_sort()呢——&#x3D;&#x3D;和十大排序再结合看&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8858%EF%BC%89vector%E4%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">1.59.</span> <span class="toc-text">（58）vector会迭代器失效吗？什么情况下会迭代器失效？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8859%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88C-%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">1.60.</span> <span class="toc-text">（59）为什么C++没有实现垃圾回收？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8860%EF%BC%89%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.61.</span> <span class="toc-text">（60）左值引用与右值引用的区别？右值引用的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8861%EF%BC%89move%E5%92%8Cforward%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">1.62.</span> <span class="toc-text">（61）move和forward完美转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#std-move"><span class="toc-number">1.62.1.</span> <span class="toc-text">std::move</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91-std-forward"><span class="toc-number">1.62.2.</span> <span class="toc-text">完美转发 std::forward</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8862%EF%BC%89%E5%9C%A8-operator-%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9C"><span class="toc-number">1.63.</span> <span class="toc-text">（62）在 operator&#x3D; 中处理“自我赋值“</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8863%EF%BC%89C-%E7%9A%84deque%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.64.</span> <span class="toc-text">（63）C++的deque的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8864%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E5%A0%86%E5%92%8C%E6%A0%88%E5%8C%BA%E5%88%86%E5%87%BA%E6%9D%A5%E5%91%A2%EF%BC%9F%E6%A0%88%E4%B8%AD%E4%B8%8D%E6%98%AF%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="toc-number">1.65.</span> <span class="toc-text">（64）为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8865%EF%BC%89%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92"><span class="toc-number">1.66.</span> <span class="toc-text">（65）指针引用 &amp;&amp; 二级指针传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8866%EF%BC%89%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E5%88%B0%E6%9C%80%E4%BD%8E"><span class="toc-number">1.67.</span> <span class="toc-text">（66）将文件间的编译依存关系降到最低</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8867%EF%BC%89%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8"><span class="toc-number">1.68.</span> <span class="toc-text">（67）异常安全</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3"><span class="toc-number">2.</span> <span class="toc-text">2. 计网相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E5%A6%82www-baidu-com%EF%BC%89-over"><span class="toc-number">2.1.</span> <span class="toc-text">（1）在浏览器中输入URL后执行的全部过程（如www.baidu.com）&#x3D;&#x3D;over&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89HTTP"><span class="toc-number">2.2.</span> <span class="toc-text">（2）HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text">（1）HTTP基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%83%BD%E5%90%A6%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E3%80%8C%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E3%80%8D%EF%BC%9F"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">（1）能否详细解释「超文本传输协议」？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%82%A3%E3%80%8CHTTP-%E6%98%AF%E7%94%A8%E4%BA%8E%E4%BB%8E%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%A0%E8%BE%93%E8%B6%85%E6%96%87%E6%9C%AC%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8D%8F%E8%AE%AE%E3%80%8D%EF%BC%8C%E8%BF%99%E7%A7%8D%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">（2）那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89http%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81-403-201%E7%AD%89%E7%AD%89%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">（3）http的状态码 403 201等等是什么意思</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89HTTP-%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">（4）HTTP 常见字段有哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89GET-%E4%B8%8E-POST"><span class="toc-number">2.2.2.</span> <span class="toc-text">（2）GET 与 POST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-http%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fget%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">（1） http的请求方法有哪些？get和post的区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89GET-%E5%92%8C-POST-%E6%96%B9%E6%B3%95%E9%83%BD%E6%98%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">（2）GET 和 POST 方法都是安全和幂等的吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89HTTP-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-number">2.2.3.</span> <span class="toc-text">（3）HTTP 缓存技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89HTTP-%E7%BC%93%E5%AD%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">（1）HTTP 缓存有哪些实现方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">（2）什么是强制缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">（3）什么是协商缓存？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89HTTP-%E7%89%B9%E6%80%A7"><span class="toc-number">2.2.4.</span> <span class="toc-text">（4）HTTP 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89HTTP-1-1-%E7%9A%84%E4%BC%98%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">（1）HTTP&#x2F;1.1 的优点有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89HTTP-1-1-%E7%9A%84%E7%BC%BA%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">（2）HTTP&#x2F;1.1 的缺点有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89HTTP-1-1-%E7%9A%84%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">（3）HTTP&#x2F;1.1 的性能如何？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89HTTP-%E4%B8%8E-HTTPS"><span class="toc-number">2.2.5.</span> <span class="toc-text">（5）HTTP 与 HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89HTTP-%E4%B8%8E-HTTPS-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">（1）HTTP 与 HTTPS 有哪些区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89HTTPS-%E8%A7%A3%E5%86%B3%E4%BA%86-HTTP-%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">（2）HTTPS 解决了 HTTP 的哪些问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89HTTPS-SSL-TSL%E4%BC%A0%E8%BE%93%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F%E5%85%B6%E9%97%B4%E4%BA%A4%E4%BA%92%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">（3）HTTPS SSL\TSL传输层是如何建立连接的？其间交互了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-HTTPS-%E7%9A%84%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">2.2.5.4.</span> <span class="toc-text">（4） HTTPS 的应用数据是如何保证完整性的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89HTTPS-%E4%B8%80%E5%AE%9A%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.5.5.</span> <span class="toc-text">（5）HTTPS 一定安全可靠吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E8%83%BD%E6%88%AA%E5%8F%96-HTTPS-%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">2.2.5.6.</span> <span class="toc-text">（6）为什么抓包工具能截取 HTTPS 数据？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%A2%AB%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">2.2.5.7.</span> <span class="toc-text">（7）如何避免被中间人抓取数据？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89HTTP-1-1%E3%80%81HTTP-2%E3%80%81HTTP-3-%E6%BC%94%E5%8F%98"><span class="toc-number">2.2.6.</span> <span class="toc-text">（6）HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89HTTP-1-1-%E7%9B%B8%E6%AF%94-HTTP-1-0-%E6%8F%90%E9%AB%98%E4%BA%86%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">（1）HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89HTTP-2-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">（2）HTTP&#x2F;2 做了什么优化？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%EF%BC%89-http%E5%8D%8F%E8%AE%AE%E4%B8%8ETCP%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">2.2.7.</span> <span class="toc-text">（） http协议与TCP的区别与联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%EF%BC%89-http-1-0%E5%92%8Chttp-1-1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.8.</span> <span class="toc-text">（） http&#x2F;1.0和http&#x2F;1.1的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E5%BB%BA%E7%AB%8BTCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%84%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-over"><span class="toc-number">2.3.</span> <span class="toc-text">（2） 建立TCP服务器的各个系统调用&#x3D;&#x3D;over&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89-%E7%BB%A7%E4%B8%8A%E4%B8%80%E9%A2%98%EF%BC%8C%E8%AF%B4%E6%98%8Esocket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9F%E5%85%B6%E4%B8%ADclose%E6%98%AF%E4%B8%80%E6%AC%A1%E5%B0%B1%E8%83%BD%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%AD%E7%9A%84%E5%90%97%EF%BC%8C%E5%8D%8A%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">（3） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89-%E5%AF%B9%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BB%8B%E7%BB%8D%E3%80%82%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEIGP%E5%8C%85%E6%8B%ACRIP%EF%BC%8COSPF%EF%BC%8C%E5%92%8C%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEEGP%E5%92%8CBGP"><span class="toc-number">2.5.</span> <span class="toc-text">（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-UDP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">2.6.</span> <span class="toc-text">（4） UDP如何实现可靠传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text">（5） TCP和UDP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-TCP%E5%92%8CUDP%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">2.8.</span> <span class="toc-text">（6） TCP和UDP相关的协议与端口号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89-TCP%EF%BC%88UDP%EF%BC%8CIP%EF%BC%89%E7%AD%89%E9%A6%96%E9%83%A8%E7%9A%84%E8%AE%A4%E8%AF%86%EF%BC%88http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E6%9E%84%E6%88%90%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-%E7%BD%91%E9%A1%B5%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.</span> <span class="toc-text">（8） 网页解析的过程与实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%88%86%E7%89%87%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.11.</span> <span class="toc-text">（10） 网络层分片的原因与具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89-TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%EF%BC%88TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80%E6%98%AF%E7%83%AD%E9%97%A8%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">2.12.</span> <span class="toc-text">（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89-TCP%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%A4%84%E4%BA%8E%E5%93%AA%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="toc-number">2.13.</span> <span class="toc-text">（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">（13） 为什么使用三次握手，两次握手可不可以？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89-TIME-WAIT%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%AD%89%E4%BA%8E2MSL%EF%BC%89"><span class="toc-number">2.15.</span> <span class="toc-text">（14） TIME_WAIT的意义（为什么要等于2MSL）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%8D%E5%A4%AA%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.16.</span> <span class="toc-text">（15） 超时重传机制（不太高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89-TCP%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">（16） TCP怎么保证可靠性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8817%EF%BC%89-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%8C%E9%87%87%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%88%E6%AD%BB%E9%94%81%E5%8F%AF%E8%83%BD%EF%BC%8C%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E5%BE%81%EF%BC%89%EF%BC%9F"><span class="toc-number">2.18.</span> <span class="toc-text">（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8818%EF%BC%89-tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.19.</span> <span class="toc-text">（18） tcp滑动窗口协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8819%EF%BC%89-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.20.</span> <span class="toc-text">（19） 拥塞控制和流量控制的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8820%EF%BC%89-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%8C%E7%AE%97%E6%B3%95%E5%90%8D%E5%AD%97%EF%BC%9F%EF%BC%88%E6%9E%81%E5%85%B6%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">2.21.</span> <span class="toc-text">（20） TCP拥塞控制，算法名字？（极其重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8822%EF%BC%89-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%97%B6%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9A%84seq%E5%BA%8F%E5%8F%B7%E6%98%AF%E6%80%8E%E6%A0%B7%E4%BA%A7%E7%94%9F%E7%9A%84"><span class="toc-number">2.22.</span> <span class="toc-text">（22） TCP三次握手时的第一次的seq序号是怎样产生的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89-%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%8A%E9%99%90%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%90%97%EF%BC%9F%E9%82%A3%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%B6%85%E8%BF%87%E8%BF%99%E4%B8%AA%E9%99%90%E5%88%B6%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">2.23.</span> <span class="toc-text">（23） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89-%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E7%B3%BB"><span class="toc-number">2.24.</span> <span class="toc-text">（24） 对称密码和非对称密码体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.25.</span> <span class="toc-text">（25） 数字证书的了解（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8826%EF%BC%89-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8Fclose-wait%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">2.26.</span> <span class="toc-text">（26） 服务器出现大量close_wait的连接的原因以及解决方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8827%EF%BC%89-%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B%EF%BC%8C%E4%BB%8B%E7%BB%8DMD5%E7%AE%97%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88MD5%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%80%86%E7%9A%84%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%8A%A0%E5%BC%BA%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A9%E5%AE%83%E4%B8%8D%E9%82%A3%E4%B9%88%E5%AE%B9%E6%98%93%E8%A2%AB%E7%A0%B4%E8%A7%A3%E5%91%A2%EF%BC%9F%EF%BC%88%E7%99%BE%E5%BA%A6%E5%AE%89%E5%85%A8%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-number">2.27.</span> <span class="toc-text">（27） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8828%EF%BC%89-%E5%8D%95%E6%9D%A1%E8%AE%B0%E5%BD%95%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.28.</span> <span class="toc-text">（28） 单条记录高并发访问的优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8829%EF%BC%89-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bping%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%88%86%E5%88%AB%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.29.</span> <span class="toc-text">（29） 介绍一下ping的过程，分别用到了哪些协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8830%EF%BC%89-TCP-IP%E7%9A%84%E7%B2%98%E5%8C%85%E4%B8%8E%E9%81%BF%E5%85%8D%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="toc-number">2.30.</span> <span class="toc-text">（30） TCP&#x2F;IP的粘包与避免介绍一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8831%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8BTCP%E7%9A%84%E5%B0%81%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85"><span class="toc-number">2.31.</span> <span class="toc-text">（31） 说一下TCP的封包和拆包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8832%EF%BC%89-%E4%B8%80%E4%B8%AAip%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%EF%BC%8C%E9%9D%A0%E4%BB%80%E4%B9%88%E8%AF%86%E5%88%AB%EF%BC%9F"><span class="toc-number">2.32.</span> <span class="toc-text">（32） 一个ip配置多个域名，靠什么识别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8833%EF%BC%89-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%EF%BC%88DDos%E6%94%BB%E5%87%BB%EF%BC%89"><span class="toc-number">2.33.</span> <span class="toc-text">（33） 服务器攻击（DDos攻击）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8834%EF%BC%89DNS%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.34.</span> <span class="toc-text">（34）DNS的工作过程和原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8835%EF%BC%89OSA%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%8CTCP-IP%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B-over"><span class="toc-number">2.35.</span> <span class="toc-text">（35）OSA七层协议和五层协议，TCP&#x2F;IP四层网络模型，分别有哪些&#x3D;&#x3D;over&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC"><span class="toc-number">2.35.1.</span> <span class="toc-text">简要概括</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">2.35.2.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.35.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8836%EF%BC%89IP%E5%AF%BB%E5%9D%80%E5%92%8CMAC%E5%AF%BB%E5%9D%80%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">2.36.</span> <span class="toc-text">（36）IP寻址和MAC寻址有什么不同，怎么实现的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">3. 操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">（1） 进程与线程的区别和联系（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-Linux%E7%90%86%E8%AE%BA%E4%B8%8A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3"><span class="toc-number">3.2.</span> <span class="toc-text">（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%9F%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F%EF%BC%88%E7%99%BE%E5%BA%A6%E5%AE%89%E5%85%A8%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D-%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">（4） 进程之间的通信方法有哪几种 （重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.5.</span> <span class="toc-text">（5） 进程调度方法详细介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%9C%80%E8%A6%81%E5%81%9A%E5%93%AA%E4%BA%9B%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-number">3.7.</span> <span class="toc-text">（6） 操作系统的内存管理说一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU%E7%AE%97%E6%B3%95"><span class="toc-number">3.8.</span> <span class="toc-text">（7） 实现一个LRU算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%88%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">3.9.</span> <span class="toc-text">（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-%E6%AD%BB%E9%94%81%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-number">3.10.</span> <span class="toc-text">（8） 死锁的恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E9%A5%A5%E9%A5%BF"><span class="toc-number">3.11.</span> <span class="toc-text">（8）什么是饥饿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAmutex%E4%BA%92%E6%96%A5%E9%94%81%E4%BD%A0%E8%A6%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.12.</span> <span class="toc-text">（9） 如果要你实现一个mutex互斥锁你要怎么实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%8F%88%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.13.</span> <span class="toc-text">（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.14.</span> <span class="toc-text">（13） 什么时候用多进程，什么时候用多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.15.</span> <span class="toc-text">（14） 文件读写使用的系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BD%A2%E6%88%90%E7%9A%84%EF%BC%9F"><span class="toc-number">3.16.</span> <span class="toc-text">（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8BPCB-%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">3.17.</span> <span class="toc-text">（16） 说一下PCB&#x2F;说一下进程地址空间&#x2F;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8817%EF%BC%89-%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%98%AF%E6%80%8E%E6%A0%B7%E5%8C%BA%E5%88%86%E7%9A%84"><span class="toc-number">3.18.</span> <span class="toc-text">（17） 内核空间和用户空间是怎样区分的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8818%EF%BC%89-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%88%E5%B0%A4%E5%85%B6%E6%98%AF%E5%A6%82%E6%9E%9C%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BE%88%E5%A4%A7%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%BB%93%E5%90%88%E8%AE%A8%E8%AE%BA%EF%BC%89"><span class="toc-number">3.19.</span> <span class="toc-text">（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8819%EF%BC%89-%E5%90%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%86%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%85%B1%E4%BA%AB%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="toc-number">3.20.</span> <span class="toc-text">（19） 同一个进程内的线程会共享什么资源？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8820%EF%BC%89-%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.21.</span> <span class="toc-text">（20） 异常和中断的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8821%EF%BC%89-%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%A8Linux-windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.22.</span> <span class="toc-text">（21） 一般情况下在Linux&#x2F;windows平台下栈空间的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8822%EF%BC%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">3.23.</span> <span class="toc-text">（22）虚拟内存的了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.24.</span> <span class="toc-text">（23）服务器高并发的解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89%E5%8D%8F%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.25.</span> <span class="toc-text">（24）协程了解吗（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89%E9%82%A3%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.26.</span> <span class="toc-text">（25）那协程的底层是怎么实现的，怎么使用协程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-number">3.27.</span> <span class="toc-text">（23）进程的状态以及转换图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89%E5%9C%A8%E6%89%A7%E8%A1%8Cmalloc%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%B4%E4%B8%80%E4%B8%8B-malloc%E5%87%BD%E6%95%B0%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-%E8%BF%9B%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%EF%BC%9F"><span class="toc-number">3.28.</span> <span class="toc-text">（24）在执行malloc申请内存的时候，操作系统是怎么做的？&#x2F;内存分配的原理说一下&#x2F;malloc函数底层是怎么实现的？&#x2F;进程是怎么分配内存的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E6%98%AF%E5%A4%A7%E7%AB%AF%E8%BF%98%E6%98%AF%E5%B0%8F%E7%AB%AF%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">3.29.</span> <span class="toc-text">（25）什么是字节序？怎么判断是大端还是小端？有什么用？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Linux"><span class="toc-number">4.</span> <span class="toc-text">4. Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-Linux%E7%9A%84I-O%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E8%B6%85%E7%BA%A7%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">（1） Linux的I&#x2F;O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88EXT4%EF%BC%8CXFS%EF%BC%8CBTRFS%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">（2） 文件系统的理解（EXT4，XFS，BTRFS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89-EPOLL%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BA%86%E8%A7%A3"><span class="toc-number">4.3.</span> <span class="toc-text">（3） EPOLL的介绍和了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-IO%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88select-poll-epoll%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-Epoll%E7%9A%84ET%E6%A8%A1%E5%BC%8F%E5%92%8CLT%E6%A8%A1%E5%BC%8F%EF%BC%88ET%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">（5） Epoll的ET模式和LT模式（ET的非阻塞）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-%E6%9F%A5%E8%AF%A2%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8CPU%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%88%E6%B3%A8%E6%84%8F%E8%A6%81%E4%BA%86%E8%A7%A3%E5%88%B0used%EF%BC%8Cbuf%EF%BC%8C%E4%BB%A3%E8%A1%A8%E6%84%8F%E4%B9%89%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89-linux%E7%9A%84%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%EF%BC%88kill%EF%BC%8Cfind%EF%BC%8Ccp%E7%AD%89%E7%AD%89%EF%BC%89"><span class="toc-number">4.7.</span> <span class="toc-text">（7） linux的其他常见命令（kill，find，cp等等）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-shell%E8%84%9A%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">4.8.</span> <span class="toc-text">（8） shell脚本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.9.</span> <span class="toc-text">（9） 硬连接和软连接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E7%9C%8B%EF%BC%88rwx%EF%BC%89"><span class="toc-number">4.10.</span> <span class="toc-text">（10） 文件权限怎么看（rwx）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89-%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%97%B6%E9%97%B4%EF%BC%88mtime-atime%EF%BC%8Cctime%EF%BC%89%EF%BC%8C%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%94%B9%E5%8F%98"><span class="toc-number">4.11.</span> <span class="toc-text">（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89-Linux%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8D%A0%E7%94%A8%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E6%83%85%E5%86%B5%E5%91%BD%E4%BB%A4"><span class="toc-number">4.12.</span> <span class="toc-text">（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89Linux%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.13.</span> <span class="toc-text">（13）Linux中线程的同步方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">4.14.</span> <span class="toc-text">（14）怎么修改一个文件的权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.15.</span> <span class="toc-text">（15）查看文件内容常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89%E6%80%8E%E4%B9%88%E6%89%BE%E5%87%BA%E5%90%AB%E6%9C%89%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%89%8D%E5%90%8E4%E8%A1%8C"><span class="toc-number">4.16.</span> <span class="toc-text">（16）怎么找出含有关键字的前后4行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8817%EF%BC%89Linux%E7%9A%84GDB%E8%B0%83%E8%AF%95"><span class="toc-number">4.17.</span> <span class="toc-text">（17）Linux的GDB调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8818%EF%BC%89coredump%E6%98%AF%E4%BB%80%E4%B9%88-%E6%80%8E%E4%B9%88%E6%89%8D%E8%83%BDcoredump%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%A7%E7%94%9Fcore%E6%96%87%E4%BB%B6"><span class="toc-number">4.18.</span> <span class="toc-text">（18）coredump是什么 怎么才能coredump，为什么产生core文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8819%EF%BC%89tcpdump%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.19.</span> <span class="toc-text">（19）tcpdump常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8820%EF%BC%89-crontab%E5%91%BD%E4%BB%A4"><span class="toc-number">4.20.</span> <span class="toc-text">（20） crontab命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8821%EF%BC%89-%E6%9F%A5%E7%9C%8B%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.21.</span> <span class="toc-text">（21） 查看后台进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8822%EF%BC%89%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">4.22.</span> <span class="toc-text">（22）池化技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%92%8C%E8%BD%AF%E4%B8%AD%E6%96%AD%E2%80%94%E2%80%94-new"><span class="toc-number">4.23.</span> <span class="toc-text">（23）硬中断和软中断——&#x3D;&#x3D;new&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%BC%9A%E5%81%9A%E5%A6%82%E4%B8%8B%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%9A"><span class="toc-number">4.23.1.</span> <span class="toc-text">硬件中断处理函数会做如下的事情：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">4.23.2.</span> <span class="toc-text">软中断的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%B6%89%E5%8F%8A%E5%87%A0%E6%AC%A1%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E6%93%8D%E4%BD%9C%EF%BC%9F%E2%80%94%E2%80%94-new"><span class="toc-number">4.24.</span> <span class="toc-text">（23）发送网络数据的时候，涉及几次内存拷贝操作？——&#x3D;&#x3D;new&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89Linux%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94-new"><span class="toc-number">4.25.</span> <span class="toc-text">（24）Linux网络模型——&#x3D;&#x3D;new&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">5.</span> <span class="toc-text">5. 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E5%85%B3%E7%B3%BB%E5%9E%8B%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BD%8E%E9%A2%91%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">（1） 关系型和非关系型数据库的区别（低频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BD%8E%E9%A2%91%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">（2） 什么是非关系型数据库（低频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8B-MySQL-%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%86%85%E9%83%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">（4） 数据库的索引类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">5.5.</span> <span class="toc-text">（5） 说一下事务是怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-MySQL%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.8.</span> <span class="toc-text">（8） 索引的底层实现（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.9.</span> <span class="toc-text">（9） B树和B+树的区别（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89-%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80-%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">5.10.</span> <span class="toc-text">（10） 索引最左前缀&#x2F;最左匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89-Mysql%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%8C%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-number">5.11.</span> <span class="toc-text">（11） Mysql的优化（高频，索引优化，性能优化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89-MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D%EF%BC%8Cinnodb%E5%92%8Cmyisam%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">5.12.</span> <span class="toc-text">（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%EF%BC%88%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E9%83%BD%E8%A6%81%E8%83%BD%E5%A4%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%8C%E7%90%86%E8%A7%A3%E9%80%8F%E5%BD%BB%EF%BC%8C%E6%AF%94%E5%A6%82%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%85%B3%E8%81%94%EF%BC%8C%E9%9A%94%E7%A6%BB%E6%80%A7%E4%B8%8D%E5%A5%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">5.13.</span> <span class="toc-text">（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="toc-number">5.14.</span> <span class="toc-text">（14）什么是脏读，不可重复读和幻读？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8Cmysql%E5%92%8COracle%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.15.</span> <span class="toc-text">（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.16.</span> <span class="toc-text">（16） 数据库连接池的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8817%EF%BC%89-Mysql%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%90%84%E8%87%AA%E7%89%B9%E7%82%B9"><span class="toc-number">5.17.</span> <span class="toc-text">（17） Mysql的表空间方式，各自特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8818%EF%BC%89-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.18.</span> <span class="toc-text">（18） 分布式事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8819%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8C%83%E5%BC%8F"><span class="toc-number">5.19.</span> <span class="toc-text">（19） 数据库的范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8820%EF%BC%89-%E6%95%B0%E6%8D%AE%E7%9A%84%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%8C%E5%8A%A0%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">5.20.</span> <span class="toc-text">（20） 数据的锁的种类，加锁的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8821%EF%BC%89-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-number">5.21.</span> <span class="toc-text">（21） 什么是共享锁和排他锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8822%EF%BC%89-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E7%AE%80%E4%BB%8B"><span class="toc-number">5.22.</span> <span class="toc-text">（22） 分库分表的理解和简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.23.</span> <span class="toc-text">（23）数据库高并发的解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B"><span class="toc-number">5.24.</span> <span class="toc-text">（24）乐观锁与悲观锁解释一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">5.25.</span> <span class="toc-text">（25）乐观锁与悲观锁是怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8826%EF%BC%89%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E6%8A%80%E6%9C%AF%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">5.26.</span> <span class="toc-text">（26）对数据库目前最新技术有什么了解吗</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-redis"><span class="toc-number">6.</span> <span class="toc-text">6. redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%9C%BA%E6%99%AF%E9%A2%98-%E7%AE%97%E6%B3%95%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">7. 场景题&#x2F;算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%880%EF%BC%89leetcode-hot100%E8%87%B3%E5%B0%91%E5%88%B7%E4%B8%A4%E9%81%8D%EF%BC%8C%E5%89%91%E6%8C%87offer%E8%87%B3%E5%B0%91%E5%88%B7%E4%B8%A4%E9%81%8D-%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D%EF%BC%81%EF%BC%81"><span class="toc-number">7.1.</span> <span class="toc-text">（0）leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BB%8B%E7%BB%8D%E7%86%9F%E6%82%89%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%95%E4%BE%8B%EF%BC%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">（1）介绍熟悉的设计模式（单例，简单工厂模式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%99%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%88%E6%9C%AC"><span class="toc-number">7.3.</span> <span class="toc-text">（2）写单例模式，线程安全版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%86%99%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0ABC"><span class="toc-number">7.4.</span> <span class="toc-text">（3）写三个线程交替打印ABC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B-%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-number">7.5.</span> <span class="toc-text">（4）二维码登录的实现过程 场景题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0swap%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">（5）不使用临时变量实现swap函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAstrcpy%E5%87%BD%E6%95%B0%EF%BC%88%E6%88%96%E8%80%85memcpy%EF%BC%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%86%85%E5%AD%98%E5%8F%AF%E8%83%BD%E9%87%8D%E5%8F%A0%E5%91%A2"><span class="toc-number">7.7.</span> <span class="toc-text">（6）实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F"><span class="toc-number">7.8.</span> <span class="toc-text">（7）十大排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92"><span class="toc-number">7.8.1.</span> <span class="toc-text">快排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">7.8.2.</span> <span class="toc-text">实现一个堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.8.3.</span> <span class="toc-text">实现一个插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">7.8.4.</span> <span class="toc-text">快排存在的问题，如何优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E8%AF%B4%E4%B8%80%E4%B8%8B-%E6%89%8B%E6%92%95"><span class="toc-number">7.8.5.</span> <span class="toc-text">希尔排序说一下&#x2F;手撕</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8B%9B%E9%93%B6%E7%BD%91%E7%BB%9C%E4%BA%8C%E9%9D%A2%EF%BC%89"><span class="toc-number">7.9.</span> <span class="toc-text">（8）反转一个链表（招银网络二面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-Top-K%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%AF%E4%BB%A5%E9%87%87%E5%8F%96%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%90%84%E8%87%AA%E4%BC%98%E7%82%B9%EF%BC%9F%EF%BC%89%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">7.10.</span> <span class="toc-text">（9） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8810%EF%BC%898G%E7%9A%84int%E5%9E%8B%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%AA%E6%9C%892G%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AF%B9%E5%AE%83%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%9F%EF%BC%88%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%EF%BC%89%EF%BC%88%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-number">7.11.</span> <span class="toc-text">（10）8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BA%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%B8%A6%E6%9C%89null%E6%A0%87%E8%AE%B0%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">7.12.</span> <span class="toc-text">（11）自己构建一棵二叉树，使用带有null标记的前序遍历序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bb%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">7.13.</span> <span class="toc-text">（12）介绍一下b树和它的应用场景有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bb-%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">7.14.</span> <span class="toc-text">（13）介绍一下b+树和它的应用场景有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">7.15.</span> <span class="toc-text">（14）介绍一下红黑树和它的应用场景有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89-%E6%80%8E%E4%B9%88%E5%86%99sql%E5%8F%96%E8%A1%A8%E7%9A%84%E5%89%8D1000%E8%A1%8C%E6%95%B0%E6%8D%AE%EF%BC%88%E6%8B%9B%E9%93%B6%E7%BD%91%E7%BB%9C%E4%BA%8C%E9%9D%A2%EF%BC%89"><span class="toc-number">7.16.</span> <span class="toc-text">（15） 怎么写sql取表的前1000行数据（招银网络二面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89-N%E4%B8%AA%E9%AA%B0%E5%AD%90%E5%87%BA%E7%8E%B0%E5%92%8C%E4%B8%BAm%E7%9A%84%E6%A6%82%E7%8E%87"><span class="toc-number">7.17.</span> <span class="toc-text">（16） N个骰子出现和为m的概率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8817%EF%BC%89-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%AF%E5%8F%82%E8%80%83%E5%B7%A6%E7%A5%9E%E7%9A%84%E4%B9%A6%EF%BC%89"><span class="toc-number">7.18.</span> <span class="toc-text">（17） 海量数据问题（可参考左神的书）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8818%EF%BC%89-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">7.19.</span> <span class="toc-text">（18） 一致性哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8819%EF%BC%89Dijkstra%E7%AE%97%E6%B3%95%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-number">7.20.</span> <span class="toc-text">（19）Dijkstra算法说一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8820%EF%BC%89%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E8%A6%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%AF%B4%E6%80%9D%E8%B7%AF%EF%BC%88%E8%85%BE%E8%AE%AFteg%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-number">7.21.</span> <span class="toc-text">（20）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8821%EF%BC%89%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-number">7.22.</span> <span class="toc-text">（21）最小生成树算法说一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8822%EF%BC%89-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84bitmap%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">7.23.</span> <span class="toc-text">（22） 海量数据的bitmap使用原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E7%82%B9"><span class="toc-number">7.24.</span> <span class="toc-text">（23） 布隆过滤器原理与优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A4%84%E7%90%86%E5%A4%A7%E8%A7%84%E6%A8%A1%E9%97%AE%E9%A2%98%E6%97%B6%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%8F%97%E9%99%90%E3%80%81%E7%A3%81%E7%9B%98%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">7.25.</span> <span class="toc-text">（24） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BD%BF%E5%AE%83%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E9%98%BF%E9%87%8C%E4%B8%89%E9%9D%A2%EF%BC%89"><span class="toc-number">7.26.</span> <span class="toc-text">（25）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8826%EF%BC%89%E4%BD%8D%E5%9B%BE%E6%8E%92%E5%BA%8F"><span class="toc-number">7.27.</span> <span class="toc-text">（26）位图排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%99%BA%E5%8A%9B%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">8. 智力题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-100%E5%B1%82%E6%A5%BC%EF%BC%8C%E5%8F%AA%E6%9C%892%E4%B8%AA%E9%B8%A1%E8%9B%8B%EF%BC%8C%E6%83%B3%E8%A6%81%E5%88%A4%E6%96%AD%E5%87%BA%E9%82%A3%E4%B8%80%E5%B1%82%E5%88%9A%E5%A5%BD%E8%AE%A9%E9%B8%A1%E8%9B%8B%E7%A2%8E%E6%8E%89%EF%BC%8C%E7%BB%99%E5%87%BA%E7%AD%96%E7%95%A5%EF%BC%88%E6%BB%B4%E6%BB%B4%E7%AC%94%E8%AF%95%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%93%81%E7%90%83%E8%B7%9F%E8%BF%99%E4%B8%AA%E6%98%AF%E4%B8%80%E7%B1%BB%E9%A2%98%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E6%AF%92%E8%8D%AF%E9%97%AE%E9%A2%98%EF%BC%8C1000%E7%93%B6%E6%B0%B4%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89%E4%B8%80%E7%93%B6%E5%8F%AF%E4%BB%A5%E6%97%A0%E9%99%90%E7%A8%80%E9%87%8A%E7%9A%84%E6%AF%92%E8%8D%AF%EF%BC%8C%E8%A6%81%E5%BF%AB%E9%80%9F%E6%89%BE%E5%87%BA%E5%93%AA%E4%B8%80%E7%93%B6%E6%9C%89%E6%AF%92%EF%BC%8C%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%AA%E5%B0%8F%E7%99%BD%E9%BC%A0"><span class="toc-number">8.2.</span> <span class="toc-text">（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-%E5%85%88%E6%89%8B%E5%BF%85%E8%83%9C%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98%EF%BC%9A100%E6%9C%AC%E4%B9%A6%EF%BC%8C%E6%AF%8F%E6%AC%A1%E8%83%BD%E5%A4%9F%E6%8B%BF1-5%E6%9C%AC%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8B%BF%E8%83%BD%E4%BF%9D%E8%AF%81%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%98%AF%E4%BD%A0%E6%8B%BF"><span class="toc-number">8.3.</span> <span class="toc-text">（5） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-%E6%94%BEn%E5%8F%AA%E8%9A%82%E8%9A%81%E5%9C%A8%E4%B8%80%E6%9D%A1%E6%A0%91%E6%9E%9D%E4%B8%8A%EF%BC%8C%E8%9A%82%E8%9A%81%E4%B8%8E%E8%9A%82%E8%9A%81%E4%B9%8B%E9%97%B4%E7%A2%B0%E5%88%B0%E5%B0%B1%E5%90%84%E8%87%AA%E5%BE%80%E5%8F%8D%E6%96%B9%E5%90%91%E8%B5%B0%EF%BC%8C%E9%97%AE%E6%80%BB%E8%B7%9D%E7%A6%BB%E6%88%96%E8%80%85%E6%97%B6%E9%97%B4%E3%80%82"><span class="toc-number">8.4.</span> <span class="toc-text">（6） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89-%E7%93%B6%E5%AD%90%E6%8D%A2%E9%A5%AE%E6%96%99%E9%97%AE%E9%A2%98%EF%BC%9A1000%E7%93%B6%E9%A5%AE%E6%96%99%EF%BC%8C3%E4%B8%AA%E7%A9%BA%E7%93%B6%E5%AD%90%E8%83%BD%E5%A4%9F%E6%8D%A21%E7%93%B6%E9%A5%AE%E6%96%99%EF%BC%8C%E9%97%AE%E6%9C%80%E5%A4%9A%E8%83%BD%E5%96%9D%E5%87%A0%E7%93%B6"><span class="toc-number">8.5.</span> <span class="toc-text">（7） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E5%9C%A824%E5%B0%8F%E6%97%B6%E9%87%8C%E9%9D%A2%E6%97%B6%E9%92%88%E5%88%86%E9%92%88%E7%A7%92%E9%92%88%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%88%E5%87%A0%E6%AC%A1"><span class="toc-number">8.6.</span> <span class="toc-text">（8）在24小时里面时针分针秒针可以重合几次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A4%A9%E5%B9%B3%EF%BC%8C%E4%B9%9D%E4%B8%AA%E7%A0%9D%E7%A0%81%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%BD%BB%E4%B8%80%E4%BA%9B%EF%BC%8C%E7%94%A8%E5%A4%A9%E5%B9%B3%E8%87%B3%E5%B0%91%E5%87%A0%E6%AC%A1%E8%83%BD%E6%89%BE%E5%88%B0%E8%BD%BB%E7%9A%84%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">（9） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89-%E6%9C%89%E5%8D%81%E7%BB%84%E7%A0%9D%E7%A0%81%E6%AF%8F%E7%BB%84%E5%8D%81%E4%B8%AA%EF%BC%8C%E6%AF%8F%E4%B8%AA%E7%A0%9D%E7%A0%81%E9%87%8D10g%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E7%BB%84%E6%AF%8F%E4%B8%AA%E5%8F%AA%E6%9C%899g%EF%BC%8C%E6%9C%89%E8%83%BD%E6%98%BE%E7%A4%BA%E5%85%8B%E6%95%B0%E7%9A%84%E7%A7%A4%E6%9C%80%E5%B0%91%E5%87%A0%E6%AC%A1%E8%83%BD%E6%89%BE%E5%88%B0%E8%BD%BB%E7%9A%84%E9%82%A3%E4%B8%80%E7%BB%84%E7%A0%9D%E7%A0%81%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">（10） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BB%99%E5%AE%9A%E7%94%9F%E6%88%901%E5%88%B05%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0Rand5-%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E7%94%9F%E6%88%901%E5%88%B07%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%87%BD%E6%95%B0Rand7-%EF%BC%9F"><span class="toc-number">8.9.</span> <span class="toc-text">（11）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89%E8%B5%9B%E9%A9%AC%EF%BC%9A%E6%9C%8925%E5%8C%B9%E9%A9%AC%EF%BC%8C%E6%AF%8F%E5%9C%BA%E6%AF%94%E8%B5%9B%E5%8F%AA%E8%83%BD%E8%B5%9B5%E5%8C%B9%EF%BC%8C%E8%87%B3%E5%B0%91%E8%A6%81%E8%B5%9B%E5%A4%9A%E5%B0%91%E5%9C%BA%E6%89%8D%E8%83%BD%E6%89%BE%E5%88%B0%E6%9C%80%E5%BF%AB%E7%9A%843%E5%8C%B9%E9%A9%AC%EF%BC%9F"><span class="toc-number">8.10.</span> <span class="toc-text">（12）赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89%E7%83%A7-%E9%A6%99-%E7%BB%B3%E5%AD%90-%E5%85%B6%E4%BB%96-%E7%A1%AE%E5%AE%9A%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%9A%E6%9C%89%E4%B8%A4%E6%A0%B9%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E9%A6%99%EF%BC%8C%E7%87%83%E7%83%A7%E5%AE%8C%E9%83%BD%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%EF%BC%8C%E9%97%AE%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A15%E5%88%86%E9%92%9F%E7%9A%84%E6%97%B6%E9%95%BF%EF%BC%9F"><span class="toc-number">8.11.</span> <span class="toc-text">（13）烧 香&#x2F;绳子&#x2F;其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89%E6%8E%B0%E5%B7%A7%E5%85%8B%E5%8A%9B%E9%97%AE%E9%A2%98-NM%E5%9D%97%E5%B7%A7%E5%85%8B%E5%8A%9B%EF%BC%8C%E6%AF%8F%E6%AC%A1%E6%8E%B0%E4%B8%80%E5%9D%97%E7%9A%84%E4%B8%80%E8%A1%8C%E6%88%96%E4%B8%80%E5%88%97%EF%BC%8C%E6%8E%B0%E6%88%9011%E7%9A%84%E5%B7%A7%E5%85%8B%E5%8A%9B%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E6%AC%A1%EF%BC%9F%EF%BC%881000%E4%B8%AA%E4%BA%BA%E5%8F%82%E5%8A%A0%E8%BE%A9%E8%AE%BA%E8%B5%9B%EF%BC%8C1V1%EF%BC%8C%E8%BE%93%E4%BA%86%E5%B0%B1%E9%80%80%E5%87%BA%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AE%89%E6%8E%92%E5%A4%9A%E5%B0%91%E5%9C%BA%E6%AF%94%E8%B5%9B%EF%BC%89"><span class="toc-number">8.12.</span> <span class="toc-text">（13）掰巧克力问题 NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%88%E6%9A%82%E6%97%B6%E4%B8%8D%E7%94%A8%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">9. 大数据（暂时不用）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BHadoop"><span class="toc-number">9.1.</span> <span class="toc-text">1. 介绍一下Hadoop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AF%B4%E4%B8%80%E4%B8%8BMapReduce%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">9.2.</span> <span class="toc-text">2. 说一下MapReduce的运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bkafka"><span class="toc-number">9.3.</span> <span class="toc-text">3. 介绍一下kafka</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88kafka%E5%90%9E%E5%90%90%E9%87%8F%E9%AB%98%EF%BC%9F-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">9.4.</span> <span class="toc-text">4. 为什么kafka吞吐量高？&#x2F;介绍一下零拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bspark"><span class="toc-number">9.5.</span> <span class="toc-text">5. 介绍一下spark</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bspark-streaming"><span class="toc-number">9.6.</span> <span class="toc-text">6. 介绍一下spark-streaming</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-spark%E7%9A%84transformation%E5%92%8Caction%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">9.7.</span> <span class="toc-text">7. spark的transformation和action有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-spark%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E5%AD%90%E8%AF%B4%E5%87%A0%E4%B8%AA"><span class="toc-number">9.8.</span> <span class="toc-text">8. spark常用的算子说几个</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81kafka%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">9.9.</span> <span class="toc-text">9. 如何保证kafka的消息不丢失</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-kafka%E5%A6%82%E4%BD%95%E9%80%89%E4%B8%BEleader"><span class="toc-number">9.10.</span> <span class="toc-text">10. kafka如何选举leader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%AF%B4%E4%B8%8Bspark%E4%B8%AD%E7%9A%84%E5%AE%BD%E4%BE%9D%E8%B5%96%E5%92%8C%E7%AA%84%E4%BE%9D%E8%B5%96"><span class="toc-number">9.11.</span> <span class="toc-text">11. 说下spark中的宽依赖和窄依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%AF%B4%E4%B8%8Bspark%E4%B8%ADstage%E6%98%AF%E4%BE%9D%E7%85%A7%E4%BB%80%E4%B9%88%E5%88%92%E5%88%86%E7%9A%84"><span class="toc-number">9.12.</span> <span class="toc-text">12. 说下spark中stage是依照什么划分的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-spark%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">9.13.</span> <span class="toc-text">13. spark的内存管理是怎样的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-spark%E7%9A%84%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">9.14.</span> <span class="toc-text">14. spark的容错机制是什么样的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-HR%E9%9D%A2"><span class="toc-number">10.</span> <span class="toc-text">10. HR面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.1.</span> <span class="toc-text">1. 自我介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9A%BE%E7%82%B9"><span class="toc-number">10.2.</span> <span class="toc-text">2. 项目中遇到的最大难点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%94%B6%E8%8E%B7"><span class="toc-number">10.3.</span> <span class="toc-text">3. 项目中的收获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%AF%E4%BB%A5%E5%AE%9E%E4%B9%A0%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E5%AE%9E%E4%B9%A0%E6%97%B6%E9%95%BF"><span class="toc-number">10.4.</span> <span class="toc-text">4. 可以实习的时间，实习时长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%93%AA%E9%87%8C%E4%BA%BA"><span class="toc-number">10.5.</span> <span class="toc-text">5. 哪里人</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%A7%E6%A0%BC"><span class="toc-number">10.6.</span> <span class="toc-text">6. 说一下自己的性格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BD%A0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">10.7.</span> <span class="toc-text">7. 你的优缺点是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD%EF%BC%8C%E7%94%BB%E7%9A%84%E6%80%8E%E4%B9%88%E6%A0%B7-%E7%90%83%E6%89%93%E7%9A%84%E5%A6%82%E4%BD%95-%E6%B8%B8%E6%88%8F%E6%89%93%E7%9A%84%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">10.8.</span> <span class="toc-text">8. 有什么兴趣爱好，画的怎么样&#x2F;球打的如何&#x2F;游戏打的怎么样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%9C%8B%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84%E4%B8%80%E6%9C%AC%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">10.9.</span> <span class="toc-text">9. 看过最好的一本书是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E9%9A%BE%E7%82%B9"><span class="toc-number">10.10.</span> <span class="toc-text">10. 学习技术中有什么难点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%8A%A0%E7%8F%AD"><span class="toc-number">10.11.</span> <span class="toc-text">11. 怎么看待加班</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%A7%89%E5%BE%97%E6%B7%B1%E5%9C%B3%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%88%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E5%9C%B0%E7%82%B9%EF%BC%89"><span class="toc-number">10.12.</span> <span class="toc-text">12. 觉得深圳怎么样（或者其他地点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E9%81%87%E8%A7%81%E8%BF%87%E6%9C%80%E5%A4%A7%E7%9A%84%E6%8C%AB%E6%8A%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="toc-number">10.13.</span> <span class="toc-text">13. 遇见过最大的挫折是什么，怎么解决的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92"><span class="toc-number">10.14.</span> <span class="toc-text">14. 职业规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E7%9B%AE%E5%89%8D%E7%9A%84offer%E6%83%85%E5%86%B5"><span class="toc-number">10.15.</span> <span class="toc-text">15. 目前的offer情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E4%BD%A0%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">10.16.</span> <span class="toc-text">16. 你最大的优势和劣势是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E4%BB%8B%E7%BB%8D%E5%9C%A8%E9%A1%B9%E7%9B%AE%E9%87%8C%E9%9D%A2%E5%85%85%E5%BD%93%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">10.17.</span> <span class="toc-text">17. 介绍在项目里面充当的角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%9C%AC%E7%A7%91%E8%8E%B7%E5%BE%97%E7%9A%84%E5%85%A8%E5%9B%BD%E8%B5%9B%E5%A5%96%E9%A1%B9%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">10.18.</span> <span class="toc-text">18. 介绍一下本科获得的全国赛奖项的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E6%9C%80%E6%9C%89%E6%88%90%E5%B0%B1%E6%84%9F%E7%9A%84%E4%BA%8B%E6%83%85-%E6%9C%80%E9%AA%84%E5%82%B2%E7%9A%84%E4%B8%80%E4%BB%B6%E4%BA%8B%E6%83%85"><span class="toc-number">10.19.</span> <span class="toc-text">19. 最有成就感的事情&#x2F;最骄傲的一件事情</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%9C%A8%E5%AE%9E%E9%AA%8C%E5%AE%A4%E4%B8%AD%E6%8B%85%E4%BB%BB%E4%BB%80%E4%B9%88%E8%A7%92%E8%89%B2%EF%BC%8C%E5%8F%82%E5%8A%A0%E7%9A%84XXX%E8%83%BD%E8%81%8A%E8%81%8A%E5%90%97"><span class="toc-number">10.20.</span> <span class="toc-text">20. 在实验室中担任什么角色，参加的XXX能聊聊吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%9A%84"><span class="toc-number">10.21.</span> <span class="toc-text">21.如何学习的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E7%94%A8%E4%B8%A4%E4%B8%AA%E8%AF%8D%E6%9D%A5%E5%BD%A2%E5%AE%B9%E8%87%AA%E5%B7%B1"><span class="toc-number">10.22.</span> <span class="toc-text">22. 用两个词来形容自己</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9C%8B%E9%98%BF%E7%A7%80%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E4%B8%8D%E9%9C%80%E8%A6%81%E8%83%8C%EF%BC%8C%E7%9B%B8%E5%90%8C%E8%B7%B3%E8%BF%87%EF%BC%8C%E9%87%8D%E8%A6%81%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%85%B6%E4%BB%96%E4%BA%86%E8%A7%A3"><span class="toc-number">11.</span> <span class="toc-text">看阿秀补充知识——不需要背，相同跳过，重要记录，其他了解</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/C++%E9%9D%A2%E7%BB%8F/" title="C++面经整理集"><img src="/./img/%E7%AC%94%E8%AE%B0p1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++面经整理集"/></a><div class="content"><a class="title" href="/2023/07/25/C++%E9%9D%A2%E7%BB%8F/" title="C++面经整理集">C++面经整理集</a><time datetime="2023-07-25T09:55:13.000Z" title="发表于 2023-07-25 17:55:13">2023-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/Effective%20C++/" title="Effective C++笔记"><img src="/./img/%E7%AC%94%E8%AE%B0p2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective C++笔记"/></a><div class="content"><a class="title" href="/2023/07/25/Effective%20C++/" title="Effective C++笔记">Effective C++笔记</a><time datetime="2023-07-25T09:54:53.000Z" title="发表于 2023-07-25 17:54:53">2023-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/MySQL%E7%AC%94%E8%AE%B0/" title="MySQL笔记"><img src="/./img/%E7%AC%94%E8%AE%B0p4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL笔记"/></a><div class="content"><a class="title" href="/2023/07/25/MySQL%E7%AC%94%E8%AE%B0/" title="MySQL笔记">MySQL笔记</a><time datetime="2023-07-25T09:54:50.000Z" title="发表于 2023-07-25 17:54:50">2023-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/C++%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" title="C++Primer查漏补缺"><img src="https://images.pexels.com/photos/917463/pexels-photo-917463.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++Primer查漏补缺"/></a><div class="content"><a class="title" href="/2023/07/25/C++%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" title="C++Primer查漏补缺">C++Primer查漏补缺</a><time datetime="2023-07-25T09:54:13.000Z" title="发表于 2023-07-25 17:54:13">2023-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/C++Primer%E7%AC%94%E8%AE%B0/" title="C++Primer笔记"><img src="/./img/%E7%AC%94%E8%AE%B0p3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++Primer笔记"/></a><div class="content"><a class="title" href="/2023/07/25/C++Primer%E7%AC%94%E8%AE%B0/" title="C++Primer笔记">C++Primer笔记</a><time datetime="2023-07-25T09:53:56.000Z" title="发表于 2023-07-25 17:53:56">2023-07-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Estrella</div><div class="footer_custom_text">Wlcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>